<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: vacbsup.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>vacbsup.c File Reference</h1><code>#include "<a class="el" href="../../d6/d4/cc_8h-source.html">cc.h</a>"</code><br>

<p>
<a href="../../d6/d2/vacbsup_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a0">me</a>&nbsp;&nbsp;&nbsp;0x000000040</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a1">GetVacb</a>(SCM, OFF)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a2">CcMoveVacbToReuseHead</a>(V)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a3">CcMoveVacbToReuseTail</a>(V)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a4">SizeOfVacbArray</a>(LSZ)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(N)</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a6">CcUnmapVacb</a> (IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb, IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN BOOLEAN UnmapBehind)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a7">CcGetVacbMiss</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LARGE_INTEGER FileOffset, IN OUT PKIRQL OldIrql)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a8">CcCalculateVacbLevelLockCount</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray, IN ULONG Level)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a9">CcGetVacbLargeOffset</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LONGLONG FileOffset)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a10">CcSetVacbLargeOffset</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LONGLONG FileOffset, IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>_inline VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LARGE_INTEGER <a class="el" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>, IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>_inline VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray, IN ULONG Level, IN LONG Amount, IN BOOLEAN Special)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a13">CcInitializeVacbs</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a14">CcGetVirtualAddressIfMapped</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LONGLONG FileOffset, OUT <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> *Vacb, OUT PULONG ReceivedLength)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LARGE_INTEGER FileOffset, OUT <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> *Vacb, IN OUT PULONG ReceivedLength)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a> (IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a17">CcReferenceFileOffset</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LARGE_INTEGER FileOffset)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a18">CcDereferenceFileOffset</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LARGE_INTEGER FileOffset)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a19">CcWaitOnActiveCount</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a20">CcCreateVacbArray</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LARGE_INTEGER NewSectionSize)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a21">CcExtendVacbArray</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LARGE_INTEGER NewSectionSize)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a22">CcUnmapVacbArray</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN PLARGE_INTEGER FileOffset OPTIONAL, IN ULONG Length, IN BOOLEAN UnmapBehind)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a23">CcPrefillVacbLevelZone</a> (IN ULONG NumberNeeded, OUT PKIRQL OldIrql, IN ULONG NeedBcbListHeads)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a24">CcDrainVacbLevelZone</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PLIST_ENTRY&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a25">CcGetBcbListHeadLargeOffset</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LONGLONG FileOffset, IN BOOLEAN FailToSuccessor)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d3/vacbsup_8c.html#a26">CcAdjustVacbLevelLockCount</a> (IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap, IN LONGLONG FileOffset, IN LONG Adjustment)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a2" doxytag="vacbsup.c::CcMoveVacbToReuseHead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CcMoveVacbToReuseHead          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">V&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>RemoveEntryList( &amp;(V)-&gt;LruList );                 \
                                        InsertHeadList( &amp;CcVacbLru, &amp;(V)-&gt;LruList );
</div></pre>
<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00163">163</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">CcFreeVirtualAddress()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00401">CcGetVacbMiss()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01784">CcUnmapVacbArray()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="vacbsup.c::CcMoveVacbToReuseTail" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CcMoveVacbToReuseTail          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">V&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>RemoveEntryList( &amp;(V)-&gt;LruList );                 \
                                        InsertTailList( &amp;CcVacbLru, &amp;(V)-&gt;LruList );
</div></pre>
<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00166">166</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">CcFreeVirtualAddress()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">CcGetVirtualAddress()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00230">CcGetVirtualAddressIfMapped()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="vacbsup.c::CheckedDec" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CheckedDec          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">N&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>{  \
    <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((N) != 0);    \
    (N) -= 1;            \
}
</div></pre>
<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00181">181</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">CcFreeVirtualAddress()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00401">CcGetVacbMiss()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="vacbsup.c::GetVacb" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define GetVacb          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SCM,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OFF&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>(                                                                \
    ((SCM)-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) ?                            \
    <a class="code" href="../../d5/d3/vacbsup_8c.html#a9">CcGetVacbLargeOffset</a>((SCM),(OFF).QuadPart) :                                          \
    (SCM)-&gt;Vacbs[(OFF).LowPart &gt;&gt; <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a>]                                      \
)
</div></pre>
<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00078">78</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00401">CcGetVacbMiss()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">CcGetVirtualAddress()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00230">CcGetVirtualAddressIfMapped()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01784">CcUnmapVacbArray()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="vacbsup.c::me" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define me&nbsp;&nbsp;&nbsp;0x000000040          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00030">30</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="vacbsup.c::SizeOfVacbArray" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SizeOfVacbArray          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LSZ&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>(                                                            \
    ((LSZ).HighPart != 0) ? MAXULONG :                                                    \
    ((LSZ).LowPart &gt; (<a class="code" href="../../d5/d5/cc_8h.html#a64">PREALLOCATED_VACBS</a> * <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a>) ?                    \
     (((LSZ).LowPart &gt;&gt; <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a>) * <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)) :                             \
     (<a class="code" href="../../d5/d5/cc_8h.html#a64">PREALLOCATED_VACBS</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)))                                                \
)
</div></pre>
<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00174">174</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01208">CcCreateVacbArray()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01377">CcExtendVacbArray()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a26" doxytag="vacbsup.c::CcAdjustVacbLevelLockCount" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcAdjustVacbLevelLockCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LONGLONG&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Adjustment</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02335">2335</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02621">CcSetVacbLargeOffset()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02110">IsVacbLevelReferenced()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00125">ReferenceVacbLevel()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00307">VACB_LEVEL_SHIFT</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00327">VACB_SIZE_OF_FIRST_LEVEL</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00629">VACB_SPECIAL_DEREFERENCE</a>.
<p>
<pre class="fragment"><div>02343                    :
02344 
02345     This routine may be called to adjust <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lock count of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bottom Vacb level when
02346     Bcbs are inserted or deleted.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> count goes to zero, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> level will be
02347     eliminated.  The bottom level must exist, or we crash!
02348 
02349 Arguments:
02350 
02351     SharedCacheMap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> SharedCacheMap <span class="keywordflow">for</span> which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb
02352                      <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> desired.
02353 
02354     FileOffset - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fileOffset corresponding to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired Vacb.
02355 
02356     Adjustment - Generally -1 or +1.
02357 
02358 Return Value:
02359 
02360     None.
02361 
02362 Environment:
02363 
02364     <a class="code" href="../../d5/d2/cachedat_8c.html#a18">CcVacbSpinLock</a> should be held on entry.
02365 
02366 --*/
02367 
02368 {
02369     ULONG Level, Shift;
02370     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray;
02371     LONGLONG OriginalFileOffset = FileOffset;
02372 
02373     <span class="comment">//</span>
02374     <span class="comment">//  Initialize variables controlling our descent into the hierarchy.</span>
02375     <span class="comment">//</span>
02376 
02377     Level = 0;
02378     Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02379 
02380     VacbArray = SharedCacheMap-&gt;Vacbs;
02381 
02382     <span class="comment">//</span>
02383     <span class="comment">//  Caller must have verified that we have a hierarchy, otherwise this routine</span>
02384     <span class="comment">//  would fail.</span>
02385     <span class="comment">//</span>
02386 
02387     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SharedCacheMap-&gt;SectionSize.QuadPart &gt; VACB_SIZE_OF_FIRST_LEVEL);
02388 
02389     <span class="comment">//</span>
02390     <span class="comment">//  Loop to calculate how many levels we have and how much we have to</span>
02391     <span class="comment">//  shift to index into the first level.</span>
02392     <span class="comment">//</span>
02393 
02394     <span class="keywordflow">do</span> {
02395 
02396         Level += 1;
02397         Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02398 
02399     } <span class="keywordflow">while</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift));
02400 
02401     <span class="comment">//</span>
02402     <span class="comment">//  Now descend the tree to the bottom level to get the caller's Vacb.</span>
02403     <span class="comment">//</span>
02404 
02405     Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02406     <span class="keywordflow">do</span> {
02407 
02408         VacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)VacbArray[(ULONG)(FileOffset &gt;&gt; Shift)];
02409 
02410         Level -= 1;
02411 
02412         FileOffset &amp;= ((LONGLONG)1 &lt;&lt; Shift) - 1;
02413 
02414         Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02415 
02416     } <span class="keywordflow">while</span> (Level != 0);
02417 
02418     <span class="comment">//</span>
02419     <span class="comment">//  Now we have reached the final level, do the adjustment.</span>
02420     <span class="comment">//</span>
02421 
02422     <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, VacbArray, Level, Adjustment, FALSE );
02423 
02424     <span class="comment">//</span>
02425     <span class="comment">//  Now, if we decremented the count to 0, then force the collapse to happen by</span>
02426     <span class="comment">//  upping count and resetting to NULL.  Then smash OriginalFileOffset to be</span>
02427     <span class="comment">//  the first entry so we do not recalculate!</span>
02428     <span class="comment">//</span>
02429 
02430     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a209">IsVacbLevelReferenced</a>( SharedCacheMap, VacbArray, Level )) {
02431         <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, VacbArray, Level, 1, TRUE );
02432         OriginalFileOffset &amp;= ~(<a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a> - 1);
02433         <a class="code" href="../../d5/d3/vacbsup_8c.html#a10">CcSetVacbLargeOffset</a>( SharedCacheMap, OriginalFileOffset, VACB_SPECIAL_DEREFERENCE );
02434     }
02435 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="vacbsup.c::CcCalculateVacbLevelLockCount" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcCalculateVacbLevelLockCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>VacbArray</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Level</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02439">2439</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l01261">_BCB::BcbLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00155">CACHE_NTC_BCB</a>, <a class="el" href="../../d5/d9/cmconfig_8c-source.html#l00051">Count</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d2/d9/cmchek_8c-source.html#l00095">Index</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01247">_BCB::NodeTypeCode</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00342">_VACB_LEVEL_REFERENCE::Reference</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00321">VACB_LAST_INDEX_FOR_LEVEL</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l02094">VacbLevelReference()</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01377">CcExtendVacbArray()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00125">ReferenceVacbLevel()</a>.
<p>
<pre class="fragment"><div>02447                    :
02448 
02449     This routine may be called to calculate or recalculate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lock count on a
02450     given Vacb level array.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called, <span class="keywordflow">for</span> example, when we are extending a
02451     section up to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> point where we activate multilevel logic and want to start
02452     keeping <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> count.
02453 
02454 Arguments:
02455 
02456     SharedCacheMap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> SharedCacheMap <span class="keywordflow">for</span> which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb
02457                      <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> desired.
02458 
02459     VacbArray - The Vacb Level array to recalculate
02460 
02461     Level - Supplies 0 <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bottom level, nonzero otherwise.
02462 
02463 Return Value:
02464 
02465     None.
02466 
02467 Environment:
02468 
02469     <a class="code" href="../../d5/d2/cachedat_8c.html#a18">CcVacbSpinLock</a> should be held on entry.
02470 
02471 --*/
02472 
02473 {
02474     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
02475     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02476     LONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0;
02477     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbTemp = VacbArray;
02478     <a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">PVACB_LEVEL_REFERENCE</a> VacbReference;
02479 
02480     <span class="comment">//</span>
02481     <span class="comment">//  First loop through to count how many Vacb pointers are in use.</span>
02482     <span class="comment">//</span>
02483 
02484     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt;= <a class="code" href="../../d5/d5/cc_8h.html#a40">VACB_LAST_INDEX_FOR_LEVEL</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
02485         <span class="keywordflow">if</span> (*(VacbTemp++) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02486             <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1;
02487         }
02488     }
02489 
02490     <span class="comment">//</span>
02491     <span class="comment">//  If this is a metadata stream, we also have to count the Bcbs in the</span>
02492     <span class="comment">//  corresponding listheads.</span>
02493     <span class="comment">//</span>
02494 
02495     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, MODIFIED_WRITE_DISABLED) &amp;&amp; (Level == 0)) {
02496 
02497         <span class="comment">//</span>
02498         <span class="comment">//  Pick up the Blink of the first listhead, casting it to a Bcb.</span>
02499         <span class="comment">//</span>
02500 
02501         Bcb = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)CONTAINING_RECORD(((PLIST_ENTRY)VacbTemp)-&gt;Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks);
02502         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
02503 
02504         <span class="comment">//</span>
02505         <span class="comment">//  Now loop through the list.  For each Bcb we see, increment the count,</span>
02506         <span class="comment">//  and for each listhead, increment Index.  We are done when we hit the</span>
02507         <span class="comment">//  last listhead, which is actually the next listhead past the ones in this</span>
02508         <span class="comment">//  block.</span>
02509         <span class="comment">//</span>
02510 
02511         <span class="keywordflow">do</span> {
02512 
02513             <span class="keywordflow">if</span> (Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
02514                 <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1;
02515             } <span class="keywordflow">else</span> {
02516                 <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1;
02517             }
02518 
02519             Bcb = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)CONTAINING_RECORD(Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks);
02520 
02521         } <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt;= (<a class="code" href="../../d5/d5/cc_8h.html#a40">VACB_LAST_INDEX_FOR_LEVEL</a> / 2));
02522     }
02523 
02524     <span class="comment">//</span>
02525     <span class="comment">//  Store the count and get out... (by hand, don't touch the special count)</span>
02526     <span class="comment">//</span>
02527 
02528     VacbReference = <a class="code" href="../../d5/d5/cc_8h.html#a208">VacbLevelReference</a>( SharedCacheMap, VacbArray, Level );
02529     VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a> = <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
02530 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="vacbsup.c::CcCreateVacbArray" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID FASTCALL CcCreateVacbArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>NewSectionSize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01208">1208</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00385">BEGIN_BCB_LIST_ARRAY</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00085">CcMaxVacbLevelsSeen</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00571">PREALLOCATED_VACBS</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00386">SIZE_PER_BCB_LIST</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00174">SizeOfVacbArray</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00315">VACB_LEVEL_BLOCK_SIZE</a>, <a class="el" href="../../d5/d5/cc_8h.html#a95">VACB_LEVEL_REFERENCE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00307">VACB_LEVEL_SHIFT</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00334">VACB_NUMBER_OF_LEVELS</a>, and <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>.
<p>
Referenced by <a class="el" href="../../d6/d7/fssup_8c-source.html#l00387">CcInitializeCacheMap()</a>.
<p>
<pre class="fragment"><div>01215                    :
01216 
01217     This routine must be called when a SharedCacheMap <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> created to create
01218     and initialize <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> initial Vacb array.
01219 
01220 Arguments:
01221 
01222     SharedCacheMap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> shared cache map <span class="keywordflow">for</span> which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> array <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01223                      to be created.
01224 
01225     NewSectionSize - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current size of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> section which must be
01226                      covered by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb array.
01227 
01228 Return Value:
01229 
01230     None.
01231 
01232 --*/
01233 
01234 {
01235     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *NewAddresses;
01236     ULONG NewSize, SizeToAllocate;
01237     PLIST_ENTRY BcbListHead;
01238     BOOLEAN CreateBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, CreateReference = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01239 
01240     NewSize = SizeToAllocate = <a class="code" href="../../d5/d3/vacbsup_8c.html#a4">SizeOfVacbArray</a>(NewSectionSize);
01241 
01242     <span class="comment">//</span>
01243     <span class="comment">//  The following limit is greater than the MM limit</span>
01244     <span class="comment">//  (i.e., MM actually only supports even smaller sections).</span>
01245     <span class="comment">//  We have to reject the sign bit, and testing the high byte</span>
01246     <span class="comment">//  for nonzero will surely only catch errors.</span>
01247     <span class="comment">//</span>
01248 
01249     <span class="keywordflow">if</span> (NewSectionSize.HighPart &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) {
01250         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_SECTION_TOO_BIG);
01251     }
01252 
01253     <span class="comment">//</span>
01254     <span class="comment">//  See if we can use the array inside the shared cache map.</span>
01255     <span class="comment">//</span>
01256 
01257     <span class="keywordflow">if</span> (NewSize == (<a class="code" href="../../d5/d5/cc_8h.html#a64">PREALLOCATED_VACBS</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>))) {
01258 
01259         NewAddresses = &amp;SharedCacheMap-&gt;InitialVacbs[0];
01260 
01261     <span class="comment">//</span>
01262     <span class="comment">//  Else allocate the array.</span>
01263     <span class="comment">//</span>
01264 
01265     } <span class="keywordflow">else</span> {
01266 
01267         <span class="comment">//</span>
01268         <span class="comment">//  For large metadata streams, double the size to allocate</span>
01269         <span class="comment">//  an array of Bcb listheads.  Each two Vacb pointers also</span>
01270         <span class="comment">//  gets its own Bcb listhead, thus requiring double the size.</span>
01271         <span class="comment">//</span>
01272 
01273         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SIZE_PER_BCB_LIST == (VACB_MAPPING_GRANULARITY * 2));
01274 
01275         <span class="comment">//</span>
01276         <span class="comment">//  If this stream is larger than the size for multi-level Vacbs,</span>
01277         <span class="comment">//  then fix the size to allocate the root.</span>
01278         <span class="comment">//</span>
01279 
01280         <span class="keywordflow">if</span> (NewSize &gt; <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>) {
01281 
01282             ULONG Level = 0;
01283             ULONG Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
01284 
01285             NewSize = SizeToAllocate = <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>;
01286             SizeToAllocate += <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>);
01287             CreateReference = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01288 
01289             <span class="comment">//</span>
01290             <span class="comment">//  Loop to calculate how many levels we have and how much we have to</span>
01291             <span class="comment">//  shift to index into the first level.</span>
01292             <span class="comment">//</span>
01293 
01294             <span class="keywordflow">do</span> {
01295 
01296                 Level += 1;
01297                 Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
01298 
01299             } <span class="keywordflow">while</span> ((NewSectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift)) != 0);
01300 
01301             <span class="comment">//</span>
01302             <span class="comment">//  Remember the maximum level ever seen (which is actually Level + 1).</span>
01303             <span class="comment">//</span>
01304 
01305             <span class="keywordflow">if</span> (Level &gt;= <a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a>) {
01306                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Level &lt;= VACB_NUMBER_OF_LEVELS);
01307                 <a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a> = Level + 1;
01308             }
01309 
01310         } <span class="keywordflow">else</span> {
01311 
01312             <span class="comment">//</span>
01313             <span class="comment">//  Does this stream get a Bcb Listhead array?</span>
01314             <span class="comment">//</span>
01315 
01316             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, MODIFIED_WRITE_DISABLED) &amp;&amp;
01317                 (NewSectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a46">BEGIN_BCB_LIST_ARRAY</a>)) {
01318 
01319                 SizeToAllocate *= 2;
01320                 CreateBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01321             }
01322 
01323             <span class="comment">//</span>
01324             <span class="comment">//  Handle the boundary case by giving the proto-level a</span>
01325             <span class="comment">//  reference count.  This will allow us to simply push it</span>
01326             <span class="comment">//  in the expansion case.  In practice, due to pool granularity</span>
01327             <span class="comment">//  this will not change the amount of space allocated</span>
01328             <span class="comment">//</span>
01329 
01330             <span class="keywordflow">if</span> (NewSize == <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>) {
01331 
01332                 SizeToAllocate += <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>);
01333                 CreateReference = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01334             }
01335         }
01336 
01337         NewAddresses = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, SizeToAllocate, 'pVcC' );
01338         <span class="keywordflow">if</span> (NewAddresses == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01339             SharedCacheMap-&gt;Status = STATUS_INSUFFICIENT_RESOURCES;
01340             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
01341         }
01342     }
01343 
01344     <span class="comment">//</span>
01345     <span class="comment">//  Zero out the Vacb array and the trailing reference counts.</span>
01346     <span class="comment">//</span>
01347 
01348     RtlZeroMemory( (PCHAR)NewAddresses, NewSize );
01349 
01350     <span class="keywordflow">if</span> (CreateReference) {
01351 
01352         SizeToAllocate -= <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>);
01353         RtlZeroMemory( (PCHAR)NewAddresses + SizeToAllocate, <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>) );
01354     }
01355 
01356     <span class="comment">//</span>
01357     <span class="comment">//  Loop to insert the Bcb listheads (if any) in the *descending* order</span>
01358     <span class="comment">//  Bcb list.</span>
01359     <span class="comment">//</span>
01360 
01361     <span class="keywordflow">if</span> (CreateBcbListHeads) {
01362 
01363         <span class="keywordflow">for</span> (BcbListHead = (PLIST_ENTRY)((PCHAR)NewAddresses + NewSize);
01364              BcbListHead &lt; (PLIST_ENTRY)((PCHAR)NewAddresses + SizeToAllocate);
01365              BcbListHead++) {
01366 
01367             InsertHeadList( &amp;SharedCacheMap-&gt;BcbList, BcbListHead );
01368         }
01369     }
01370 
01371     SharedCacheMap-&gt;Vacbs = NewAddresses;
01372     SharedCacheMap-&gt;SectionSize = NewSectionSize;
01373 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="vacbsup.c::CcDereferenceFileOffset" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcDereferenceFileOffset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01007">1007</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00076">CcAcquireVacbLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00087">DISPATCH_LEVEL</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00086">SetVacb()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00327">VACB_SIZE_OF_FIRST_LEVEL</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00629">VACB_SPECIAL_DEREFERENCE</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>.
<p>
<pre class="fragment"><div>01014                    :
01015 
01016     This routine must be called once <span class="keywordflow">for</span> each call to <a class="code" href="../../d5/d5/cc_8h.html#a196">CcReferenceFileOffset</a>
01017     to remove <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> reference.
01018 
01019 Arguments:
01020 
01021     SharedCacheMap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Shared Cache Map <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
01022 
01023     FileOffset - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired FileOffset within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
01024 
01025 Return Value:
01026 
01027     None
01028 
01029 --*/
01030 
01031 {
01032     KIRQL OldIrql;
01033 
01034     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; DISPATCH_LEVEL);
01035 
01036     <span class="comment">//</span>
01037     <span class="comment">//  This operation only has meaning if the Vacbs are in the multilevel form.</span>
01038     <span class="comment">//</span>
01039 
01040     <span class="keywordflow">if</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
01041 
01042         <span class="comment">//</span>
01043         <span class="comment">//  Acquire the Vacb lock to synchronize the dereference.</span>
01044         <span class="comment">//</span>
01045 
01046         <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
01047 
01048         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileOffset.QuadPart &lt;= SharedCacheMap-&gt;SectionSize.QuadPart );
01049 
01050         <a class="code" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a>( SharedCacheMap, FileOffset, VACB_SPECIAL_DEREFERENCE );
01051 
01052         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01053     }
01054 
01055     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; DISPATCH_LEVEL);
01056 
01057     <span class="keywordflow">return</span>;
01058 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="vacbsup.c::CcDrainVacbLevelZone" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcDrainVacbLevelZone           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02044">2044</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00076">CcAcquireVacbLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00085">CcMaxVacbLevelsSeen</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00086">CcVacbLevelEntries</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00087">CcVacbLevelFreeList</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00088">CcVacbLevelWithBcbsEntries</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00089">CcVacbLevelWithBcbsFreeList</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, and <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>.
<p>
Referenced by <a class="el" href="../../d6/d7/fssup_8c-source.html#l02626">CcDeleteMbcb()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00401">CcGetVacbMiss()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01784">CcUnmapVacbArray()</a>.
<p>
<pre class="fragment"><div>02049                    :
02050 
02051     This routine should be called any time some entries have been deallocated to
02052     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> VacbLevel zone, and we want to insure <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> zone <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned to a normal level.
02053 
02054 Arguments:
02055 
02056 Return Value:
02057 
02058     None.
02059 
02060 Environment:
02061 
02062     No spinlocks should be held upon entry.
02063 
02064 --*/
02065 
02066 {
02067     KIRQL OldIrql;
02068     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *NextVacbArray;
02069 
02070     <span class="comment">//</span>
02071     <span class="comment">//  This is an unsafe loop to see if it looks like there is stuff to</span>
02072     <span class="comment">//  clean up.</span>
02073     <span class="comment">//</span>
02074 
02075     <span class="keywordflow">while</span> ((<a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a> &gt; (<a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a> * 4)) ||
02076            (<a class="code" href="../../d5/d2/cachedat_8c.html#a26">CcVacbLevelWithBcbsEntries</a> &gt; 2)) {
02077 
02078         <span class="comment">//</span>
02079         <span class="comment">//  Now go in and try to pick up one entry to free under a FastLock.</span>
02080         <span class="comment">//</span>
02081 
02082         NextVacbArray = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02083         <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
02084         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a> &gt; (<a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a> * 4)) {
02085             NextVacbArray = <a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a>;
02086             <a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a> = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)NextVacbArray[0];
02087             <a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a> -= 1;
02088         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/cachedat_8c.html#a26">CcVacbLevelWithBcbsEntries</a> &gt; 2) {
02089             NextVacbArray = <a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a>;
02090             <a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a> = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)NextVacbArray[0];
02091             <a class="code" href="../../d5/d2/cachedat_8c.html#a26">CcVacbLevelWithBcbsEntries</a> -= 1;
02092         }
02093         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
02094 
02095         <span class="comment">//</span>
02096         <span class="comment">//  Since the loop is unsafe, we may not have gotten anything.</span>
02097         <span class="comment">//</span>
02098 
02099         <span class="keywordflow">if</span> (NextVacbArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02100             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(NextVacbArray);
02101         }
02102     }
02103 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="vacbsup.c::CcExtendVacbArray" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcExtendVacbArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>NewSectionSize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01377">1377</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d5/d5/cc_8h.html#a109">BCB</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00385">BEGIN_BCB_LIST_ARRAY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00076">CcAcquireVacbLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00082">CcAcquireVacbLockAtDpcLevel</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02048">CcAllocateVacbLevel()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02439">CcCalculateVacbLevelLockCount()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02070">CcDeallocateVacbLevel()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00085">CcMaxVacbLevelsSeen</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01931">CcPrefillVacbLevelZone()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00085">CcReleaseVacbLockFromDpcLevel</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00086">CcVacbLevelEntries</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01101">FsRtlAllocatePoolWithTag</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02110">IsVacbLevelReferenced()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00033">Offset</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00125">ReferenceVacbLevel()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00386">SIZE_PER_BCB_LIST</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00174">SizeOfVacbArray</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00315">VACB_LEVEL_BLOCK_SIZE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00307">VACB_LEVEL_SHIFT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00334">VACB_NUMBER_OF_LEVELS</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00327">VACB_SIZE_OF_FIRST_LEVEL</a>.
<p>
Referenced by <a class="el" href="../../d6/d7/fssup_8c-source.html#l00387">CcInitializeCacheMap()</a>, and <a class="el" href="../../d6/d7/fssup_8c-source.html#l01821">CcSetFileSizes()</a>.
<p>
<pre class="fragment"><div>01384                    :
01385 
01386     This routine must be called any time <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> section <span class="keywordflow">for</span> a shared cache
01387     map <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> extended, in order to extend <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb array (<span class="keywordflow">if</span> necessary).
01388 
01389 Arguments:
01390 
01391     SharedCacheMap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> shared cache map <span class="keywordflow">for</span> which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> array <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01392                      to be created.
01393 
01394     NewSectionSize - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> size of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> section which must be
01395                      covered by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb array.
01396 
01397 Return Value:
01398 
01399     None.
01400 
01401 --*/
01402 
01403 {
01404     KIRQL OldIrql;
01405     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *OldAddresses;
01406     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *NewAddresses;
01407     ULONG OldSize;
01408     ULONG NewSize, SizeToAllocate;
01409     LARGE_INTEGER NextLevelSize;
01410     BOOLEAN GrowingBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, CreateReference = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01411 
01412     <span class="comment">//</span>
01413     <span class="comment">//  The following limit is greater than the MM limit</span>
01414     <span class="comment">//  (i.e., MM actually only supports even smaller sections).</span>
01415     <span class="comment">//  We have to reject the sign bit, and testing the high byte</span>
01416     <span class="comment">//  for nonzero will surely only catch errors.</span>
01417     <span class="comment">//</span>
01418 
01419     <span class="keywordflow">if</span> (NewSectionSize.HighPart &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) {
01420         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_SECTION_TOO_BIG);
01421     }
01422 
01423     <span class="comment">//</span>
01424     <span class="comment">//  See if we will be growing the Bcb ListHeads, so we can take out the</span>
01425     <span class="comment">//  master lock if so.</span>
01426     <span class="comment">//</span>
01427 
01428     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, MODIFIED_WRITE_DISABLED) &amp;&amp;
01429         (NewSectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a46">BEGIN_BCB_LIST_ARRAY</a>)) {
01430 
01431         GrowingBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01432     }
01433 
01434     <span class="comment">//</span>
01435     <span class="comment">//  Is there any work to do?</span>
01436     <span class="comment">//</span>
01437 
01438     <span class="keywordflow">if</span> (NewSectionSize.QuadPart &gt; SharedCacheMap-&gt;SectionSize.QuadPart) {
01439 
01440         <span class="comment">//</span>
01441         <span class="comment">//  Handle the growth of the first level here.</span>
01442         <span class="comment">//</span>
01443 
01444         <span class="keywordflow">if</span> (SharedCacheMap-&gt;SectionSize.QuadPart &lt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
01445 
01446             NextLevelSize = NewSectionSize;
01447 
01448             <span class="comment">//</span>
01449             <span class="comment">//  Limit the growth of this level</span>
01450             <span class="comment">//</span>
01451 
01452             <span class="keywordflow">if</span> (NextLevelSize.QuadPart &gt;= <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
01453                 NextLevelSize.QuadPart = <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>;
01454                 CreateReference = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01455             }
01456 
01457             <span class="comment">//</span>
01458             <span class="comment">//  N.B.: SizeOfVacbArray only calculates the size of the VACB</span>
01459             <span class="comment">//  pointer block.  We must adjust for Bcb listheads and the</span>
01460             <span class="comment">//  multilevel reference count.</span>
01461             <span class="comment">//</span>
01462 
01463             NewSize = SizeToAllocate = <a class="code" href="../../d5/d3/vacbsup_8c.html#a4">SizeOfVacbArray</a>(NextLevelSize);
01464             OldSize = <a class="code" href="../../d5/d3/vacbsup_8c.html#a4">SizeOfVacbArray</a>(SharedCacheMap-&gt;SectionSize);
01465 
01466             <span class="comment">//</span>
01467             <span class="comment">//  Only do something if the size is growing.</span>
01468             <span class="comment">//</span>
01469 
01470             <span class="keywordflow">if</span> (NewSize &gt; OldSize) {
01471 
01472                 <span class="comment">//</span>
01473                 <span class="comment">//  Does this stream get a Bcb Listhead array?</span>
01474                 <span class="comment">//</span>
01475 
01476                 <span class="keywordflow">if</span> (GrowingBcbListHeads) {
01477                     SizeToAllocate *= 2;
01478                 }
01479 
01480                 <span class="comment">//</span>
01481                 <span class="comment">//  Do we need space for the reference count?</span>
01482                 <span class="comment">//</span>
01483 
01484                 <span class="keywordflow">if</span> (CreateReference) {
01485                     SizeToAllocate += <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>);
01486                 }
01487 
01488                 NewAddresses = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( NonPagedPool, SizeToAllocate, 'pVcC' );
01489 
01490                 <span class="comment">//</span>
01491                 <span class="comment">//  See if we will be growing the Bcb ListHeads, so we can take out the</span>
01492                 <span class="comment">//  master lock if so.</span>
01493                 <span class="comment">//</span>
01494 
01495                 <span class="keywordflow">if</span> (GrowingBcbListHeads) {
01496 
01497                     ExAcquireSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
01498                     <a class="code" href="../../d5/d5/cc_8h.html#a6">CcAcquireVacbLockAtDpcLevel</a>();
01499 
01500                 } <span class="keywordflow">else</span> {
01501 
01502                     <span class="comment">//</span>
01503                     <span class="comment">//  Acquire the spin lock to serialize with anyone who might like</span>
01504                     <span class="comment">//  to "steal" one of the mappings we are going to move.</span>
01505                     <span class="comment">//</span>
01506 
01507                     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
01508                 }
01509 
01510                 OldAddresses = SharedCacheMap-&gt;Vacbs;
01511                 <span class="keywordflow">if</span> (OldAddresses != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01512                     RtlCopyMemory( NewAddresses, OldAddresses, OldSize );
01513                 } <span class="keywordflow">else</span> {
01514                     OldSize = 0;
01515                 }
01516 
01517                 RtlZeroMemory( (PCHAR)NewAddresses + OldSize, NewSize - OldSize );
01518 
01519                 <span class="keywordflow">if</span> (CreateReference) {
01520 
01521                     SizeToAllocate -= <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>);
01522                     RtlZeroMemory( (PCHAR)NewAddresses + SizeToAllocate, <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>) );
01523                 }
01524 
01525                 <span class="comment">//</span>
01526                 <span class="comment">//  See if we have to initialize Bcb Listheads.</span>
01527                 <span class="comment">//</span>
01528 
01529                 <span class="keywordflow">if</span> (GrowingBcbListHeads) {
01530 
01531                     LARGE_INTEGER <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01532                     PLIST_ENTRY BcbListHeadNew, TempEntry;
01533 
01534                     <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart = 0;
01535                     BcbListHeadNew = (PLIST_ENTRY)((PCHAR)NewAddresses + NewSize );
01536 
01537                     <span class="comment">//</span>
01538                     <span class="comment">//  Handle case where the old array had Bcb Listheads.</span>
01539                     <span class="comment">//</span>
01540 
01541                     <span class="keywordflow">if</span> ((SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a46">BEGIN_BCB_LIST_ARRAY</a>) &amp;&amp;
01542                         (OldAddresses != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01543 
01544                         PLIST_ENTRY BcbListHeadOld;
01545 
01546                         BcbListHeadOld = (PLIST_ENTRY)((PCHAR)OldAddresses + OldSize);
01547 
01548                         <span class="comment">//</span>
01549                         <span class="comment">//  Loop to remove each old listhead and insert the new one</span>
01550                         <span class="comment">//  in its place.</span>
01551                         <span class="comment">//</span>
01552 
01553                         <span class="keywordflow">do</span> {
01554                             TempEntry = BcbListHeadOld-&gt;Flink;
01555                             RemoveEntryList( BcbListHeadOld );
01556                             InsertTailList( TempEntry, BcbListHeadNew );
01557                             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart += <a class="code" href="../../d5/d5/cc_8h.html#a47">SIZE_PER_BCB_LIST</a>;
01558                             BcbListHeadOld += 1;
01559                             BcbListHeadNew += 1;
01560                         } <span class="keywordflow">while</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart &lt; SharedCacheMap-&gt;SectionSize.QuadPart);
01561 
01562                     <span class="comment">//</span>
01563                     <span class="comment">//  Otherwise, handle the case where we are adding Bcb</span>
01564                     <span class="comment">//  Listheads.</span>
01565                     <span class="comment">//</span>
01566 
01567                     } <span class="keywordflow">else</span> {
01568 
01569                         TempEntry = SharedCacheMap-&gt;BcbList.Blink;
01570 
01571                         <span class="comment">//</span>
01572                         <span class="comment">//  Loop through any/all Bcbs to insert the new listheads.</span>
01573                         <span class="comment">//</span>
01574 
01575                         <span class="keywordflow">while</span> (TempEntry != &amp;SharedCacheMap-&gt;BcbList) {
01576 
01577                             <span class="comment">//</span>
01578                             <span class="comment">//  Sit on this Bcb until we have inserted all listheads</span>
01579                             <span class="comment">//  that go before it.</span>
01580                             <span class="comment">//</span>
01581 
01582                             <span class="keywordflow">while</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart &lt;= ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)CONTAINING_RECORD(TempEntry, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks))-&gt;FileOffset.QuadPart) {
01583 
01584                                 InsertHeadList(TempEntry, BcbListHeadNew);
01585                                 <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart += <a class="code" href="../../d5/d5/cc_8h.html#a47">SIZE_PER_BCB_LIST</a>;
01586                                 BcbListHeadNew += 1;
01587                             }
01588                             TempEntry = TempEntry-&gt;Blink;
01589                         }
01590                     }
01591 
01592                     <span class="comment">//</span>
01593                     <span class="comment">//  Now insert the rest of the new listhead entries that were</span>
01594                     <span class="comment">//  not finished in either loop above.</span>
01595                     <span class="comment">//</span>
01596 
01597                     <span class="keywordflow">while</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart &lt; NextLevelSize.QuadPart) {
01598 
01599                         InsertHeadList(&amp;SharedCacheMap-&gt;BcbList, BcbListHeadNew);
01600                         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart += <a class="code" href="../../d5/d5/cc_8h.html#a47">SIZE_PER_BCB_LIST</a>;
01601                         BcbListHeadNew += 1;
01602                     }
01603                 }
01604 
01605                 <span class="comment">//</span>
01606                 <span class="comment">//  These two fields must be changed while still holding the spinlock.</span>
01607                 <span class="comment">//</span>
01608 
01609                 SharedCacheMap-&gt;Vacbs = NewAddresses;
01610                 SharedCacheMap-&gt;SectionSize = NextLevelSize;
01611 
01612                 <span class="comment">//</span>
01613                 <span class="comment">//  Now we can free the spinlocks ahead of freeing pool.</span>
01614                 <span class="comment">//</span>
01615 
01616                 <span class="keywordflow">if</span> (GrowingBcbListHeads) {
01617                     <a class="code" href="../../d5/d5/cc_8h.html#a7">CcReleaseVacbLockFromDpcLevel</a>();
01618                     ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
01619                 } <span class="keywordflow">else</span> {
01620                     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01621                 }
01622 
01623                 <span class="keywordflow">if</span> ((OldAddresses != &amp;SharedCacheMap-&gt;InitialVacbs[0]) &amp;&amp;
01624                     (OldAddresses != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01625                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( OldAddresses );
01626                 }
01627             }
01628 
01629             <span class="comment">//</span>
01630             <span class="comment">//  Make sure SectionSize gets updated.  It is ok to fall through here</span>
01631             <span class="comment">//  without a spinlock, so long as either Vacbs was not changed, or it</span>
01632             <span class="comment">//  was changed together with SectionSize under the spinlock(s) above.</span>
01633             <span class="comment">//</span>
01634 
01635             SharedCacheMap-&gt;SectionSize = NextLevelSize;
01636         }
01637 
01638         <span class="comment">//</span>
01639         <span class="comment">//  Handle extends up to and within multi-level Vacb arrays here.  This is fairly simple.</span>
01640         <span class="comment">//  If no additional Vacb levels are required, then there is no work to do, otherwise</span>
01641         <span class="comment">//  we just have to push the root one or more levels linked through the first pointer</span>
01642         <span class="comment">//  in the new root(s).</span>
01643         <span class="comment">//</span>
01644 
01645         <span class="keywordflow">if</span> (NewSectionSize.QuadPart &gt; SharedCacheMap-&gt;SectionSize.QuadPart) {
01646 
01647             <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *NextVacbArray;
01648             ULONG NewLevel;
01649             ULONG Level = 1;
01650             ULONG Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
01651 
01652             <span class="comment">//</span>
01653             <span class="comment">//  Loop to calculate how many levels we currently have.</span>
01654             <span class="comment">//</span>
01655 
01656             <span class="keywordflow">while</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift)) {
01657 
01658                 Level += 1;
01659                 Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
01660             }
01661 
01662             NewLevel = Level;
01663 
01664             <span class="comment">//</span>
01665             <span class="comment">//  Loop to calculate how many levels we need.</span>
01666             <span class="comment">//</span>
01667 
01668             <span class="keywordflow">while</span> (((NewSectionSize.QuadPart - 1) &gt;&gt; Shift) != 0) {
01669 
01670                 NewLevel += 1;
01671                 Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
01672             }
01673 
01674             <span class="comment">//</span>
01675             <span class="comment">//  Now see if we have any work to do.</span>
01676             <span class="comment">//</span>
01677 
01678             <span class="keywordflow">if</span> (NewLevel &gt; Level) {
01679 
01680                 <span class="comment">//</span>
01681                 <span class="comment">//  Remember the maximum level ever seen (which is actually NewLevel + 1).</span>
01682                 <span class="comment">//</span>
01683 
01684                 <span class="keywordflow">if</span> (NewLevel &gt;= <a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a>) {
01685                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(NewLevel &lt;= VACB_NUMBER_OF_LEVELS);
01686                     <a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a> = NewLevel + 1;
01687                 }
01688 
01689                 <span class="comment">//</span>
01690                 <span class="comment">//  Raise if we cannot preallocate enough buffers.</span>
01691                 <span class="comment">//</span>
01692 
01693                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d3/vacbsup_8c.html#a23">CcPrefillVacbLevelZone</a>( NewLevel - Level, &amp;OldIrql, FALSE )) {
01694 
01695                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
01696                 }
01697 
01698                 <span class="comment">//</span>
01699                 <span class="comment">//  Now if the current Level of the file is 1, we have not been maintaining</span>
01700                 <span class="comment">//  a reference count, so we have to calculate it before pushing.  In the</span>
01701                 <span class="comment">//  boundary case we have made sure that the reference space is avaliable.</span>
01702                 <span class="comment">//</span>
01703 
01704                 <span class="keywordflow">if</span> (Level == 1) {
01705 
01706                     <span class="comment">//</span>
01707                     <span class="comment">//  We know this is always a leaf-like level right now.</span>
01708                     <span class="comment">//</span>
01709 
01710                     <a class="code" href="../../d5/d3/vacbsup_8c.html#a8">CcCalculateVacbLevelLockCount</a>( SharedCacheMap, SharedCacheMap-&gt;Vacbs, 0 );
01711                 }
01712 
01713                 <span class="comment">//</span>
01714                 <span class="comment">//  Finally, if there are any active pointers in the first level, then we</span>
01715                 <span class="comment">//  have to create new levels by adding a new root enough times to create</span>
01716                 <span class="comment">//  additional levels.  On the other hand, if the pointer count in the top</span>
01717                 <span class="comment">//  level is zero, then we must not do any pushes, because we never allow</span>
01718                 <span class="comment">//  empty leaves!</span>
01719                 <span class="comment">//</span>
01720 
01721                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a209">IsVacbLevelReferenced</a>( SharedCacheMap, SharedCacheMap-&gt;Vacbs, Level - 1 )) {
01722 
01723                     <span class="keywordflow">while</span> (NewLevel &gt; Level++) {
01724 
01725                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(CcVacbLevelEntries != 0);
01726                         NextVacbArray = <a class="code" href="../../d5/d5/cc_8h.html#a206">CcAllocateVacbLevel</a>(FALSE);
01727 
01728                         NextVacbArray[0] = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)SharedCacheMap-&gt;Vacbs;
01729                         <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, NextVacbArray, Level, 1, FALSE );
01730 
01731                         SharedCacheMap-&gt;Vacbs = NextVacbArray;
01732                     }
01733 
01734                 } <span class="keywordflow">else</span> {
01735 
01736                     <span class="comment">//</span>
01737                     <span class="comment">//  We are now possesed of the additional problem that this level has no</span>
01738                     <span class="comment">//  references but may have Bcb listheads due to the boundary case where</span>
01739                     <span class="comment">//  we have expanded up to the multilevel Vacbs above.  This level can't</span>
01740                     <span class="comment">//  remain at the root and needs to be destroyed.  What we need to do is</span>
01741                     <span class="comment">//  replace it with one of our prefilled (non Bcb) levels and unlink the</span>
01742                     <span class="comment">//  Bcb listheads in the old one.</span>
01743                     <span class="comment">//</span>
01744 
01745                     <span class="keywordflow">if</span> (Level == 1 &amp;&amp; <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, MODIFIED_WRITE_DISABLED)) {
01746 
01747                         PLIST_ENTRY PredecessorListHead, SuccessorListHead;
01748 
01749                         NextVacbArray = SharedCacheMap-&gt;Vacbs;
01750                         SharedCacheMap-&gt;Vacbs = <a class="code" href="../../d5/d5/cc_8h.html#a206">CcAllocateVacbLevel</a>(FALSE);
01751 
01752                         PredecessorListHead = ((PLIST_ENTRY)((PCHAR)NextVacbArray + <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>))-&gt;Flink;
01753                         SuccessorListHead = ((PLIST_ENTRY)((PCHAR)NextVacbArray + (<a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> * 2) - <span class="keyword">sizeof</span>(LIST_ENTRY)))-&gt;Blink;
01754                         PredecessorListHead-&gt;Blink = SuccessorListHead;
01755                         SuccessorListHead-&gt;Flink = PredecessorListHead;
01756 
01757                         <a class="code" href="../../d5/d5/cc_8h.html#a207">CcDeallocateVacbLevel</a>( NextVacbArray, TRUE );
01758                     }
01759                 }
01760 
01761                 <span class="comment">//</span>
01762                 <span class="comment">//  These two fields (Vacbs and SectionSize) must be changed while still</span>
01763                 <span class="comment">//  holding the spinlock.</span>
01764                 <span class="comment">//</span>
01765 
01766                 SharedCacheMap-&gt;SectionSize = NewSectionSize;
01767                 <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01768             }
01769 
01770             <span class="comment">//</span>
01771             <span class="comment">//  Make sure SectionSize gets updated.  It is ok to fall through here</span>
01772             <span class="comment">//  without a spinlock, so long as either Vacbs was not changed, or it</span>
01773             <span class="comment">//  was changed together with SectionSize under the spinlock(s) above.</span>
01774             <span class="comment">//</span>
01775 
01776             SharedCacheMap-&gt;SectionSize = NewSectionSize;
01777         }
01778     }
01779 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="vacbsup.c::CcFreeVirtualAddress" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID FASTCALL CcFreeVirtualAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Vacb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">862</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00076">CcAcquireVacbLock</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00163">CcMoveVacbToReuseHead</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00166">CcMoveVacbToReuseTail</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00181">CheckedDec</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d3/d7/eventobj_8c-source.html#l00343">KeSetEvent()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00817">_SHARED_CACHE_MAP::VacbActiveCount</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00877">_SHARED_CACHE_MAP::WaitOnActiveCount</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l01517">CcDeleteSharedCacheMap()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">CcFastCopyRead()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l04411">CcFlushCache()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l06024">CcMapAndCopy()</a>, <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00030">CcMdlRead()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01633">CcPerformReadAhead()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00271">CcPinMappedData()</a>, <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00466">CcPrepareMdlWrite()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l02194">CcPurgeAndClearCacheSection()</a>, and <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00974">CcUnpinFileData()</a>.
<p>
<pre class="fragment"><div>00868                    :
00869 
00870     This routine must be called once <span class="keywordflow">for</span> each call to <a class="code" href="../../d5/d5/cc_8h.html#a194">CcGetVirtualAddress</a>
00871     to free that <span class="keyword">virtual</span> address.
00872 
00873 Arguments:
00874 
00875     Vacb - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb which was returned from <a class="code" href="../../d5/d5/cc_8h.html#a194">CcGetVirtualAddress</a>.
00876 
00877 Return Value:
00878 
00879     None.
00880 
00881 --*/
00882 
00883 {
00884     KIRQL OldIrql;
00885     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap = Vacb-&gt;SharedCacheMap;
00886 
00887     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
00888 
00889     <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(Vacb-&gt;Overlay.ActiveCount);
00890 
00891     <span class="comment">//</span>
00892     <span class="comment">//  If the count goes to zero, then we want to decrement the global</span>
00893     <span class="comment">//  Active count.</span>
00894     <span class="comment">//</span>
00895 
00896     <span class="keywordflow">if</span> (Vacb-&gt;Overlay.ActiveCount == 0) {
00897 
00898         <span class="comment">//</span>
00899         <span class="comment">//  If the SharedCacheMap address is not NULL, then this one is</span>
00900         <span class="comment">//  in use by a shared cache map, and we have to decrement his</span>
00901         <span class="comment">//  count and see if anyone is waiting.</span>
00902         <span class="comment">//</span>
00903 
00904         <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00905 
00906             <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o16">VacbActiveCount</a>);
00907 
00908             <span class="comment">//</span>
00909             <span class="comment">//  If there is someone waiting for this count to go to zero,</span>
00910             <span class="comment">//  wake them here.</span>
00911             <span class="comment">//</span>
00912 
00913             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o24">WaitOnActiveCount</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00914                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o24">WaitOnActiveCount</a>, 0, FALSE );
00915             }
00916 
00917             <span class="comment">//</span>
00918             <span class="comment">//  Go to the back of the LRU to save this range for a bit</span>
00919             <span class="comment">//</span>
00920 
00921             <a class="code" href="../../d5/d3/vacbsup_8c.html#a3">CcMoveVacbToReuseTail</a>( Vacb );
00922 
00923         } <span class="keywordflow">else</span> {
00924 
00925             <span class="comment">//</span>
00926             <span class="comment">//  This range is no longer referenced, so make it avaliable</span>
00927             <span class="comment">//</span>
00928 
00929             <a class="code" href="../../d5/d3/vacbsup_8c.html#a2">CcMoveVacbToReuseHead</a>( Vacb );
00930         }
00931 
00932     } <span class="keywordflow">else</span> {
00933 
00934         <span class="comment">//</span>
00935         <span class="comment">//  This range is still in use, so move it away from the front</span>
00936         <span class="comment">//  so that it doesn't consume cycles being checked.</span>
00937         <span class="comment">//</span>
00938 
00939         <a class="code" href="../../d5/d3/vacbsup_8c.html#a3">CcMoveVacbToReuseTail</a>( Vacb );
00940     }
00941 
00942     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
00943 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="vacbsup.c::CcGetBcbListHeadLargeOffset" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PLIST_ENTRY CcGetBcbListHeadLargeOffset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LONGLONG&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>FailToSuccessor</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02107">2107</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d2/d9/cmchek_8c-source.html#l00095">Index</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00321">VACB_LAST_INDEX_FOR_LEVEL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00315">VACB_LEVEL_BLOCK_SIZE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00307">VACB_LEVEL_SHIFT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00334">VACB_NUMBER_OF_LEVELS</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00327">VACB_SIZE_OF_FIRST_LEVEL</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02621">CcSetVacbLargeOffset()</a>.
<p>
<pre class="fragment"><div>02115                    :
02116 
02117     This routine may be called to <span class="keywordflow">return</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Bcb listhead <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified FileOffset.
02118     It should <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> be called <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> SectionSize <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> greater than <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>.
02119 
02120 Arguments:
02121 
02122     SharedCacheMap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> SharedCacheMap <span class="keywordflow">for</span> which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> listhead
02123                      <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> desired.
02124 
02125     FileOffset - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fileOffset corresponding to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired listhead.
02126 
02127     FailToSuccessor - Instructs whether not finding <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exact listhead should cause us to
02128         <span class="keywordflow">return</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> predecessor or successor Bcb listhead.
02129 
02130 Return Value:
02131 
02132     Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired Listhead pointer.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired listhead does not actually exist
02133     yet, then <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate listhead.
02134 
02135 Environment:
02136 
02137     The BcbSpinlock should be held on entry.
02138 
02139 --*/
02140 
02141 {
02142     ULONG Level, Shift;
02143     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray, *NextVacbArray;
02144     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02145     ULONG SavedIndexes[<a class="code" href="../../d5/d5/cc_8h.html#a42">VACB_NUMBER_OF_LEVELS</a>];
02146     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *SavedVacbArrays[<a class="code" href="../../d5/d5/cc_8h.html#a42">VACB_NUMBER_OF_LEVELS</a>];
02147     ULONG SavedLevels = 0;
02148 
02149     <span class="comment">//</span>
02150     <span class="comment">//  Initialize variables controlling our descent into the hierarchy.</span>
02151     <span class="comment">//</span>
02152 
02153     Level = 0;
02154     Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02155     VacbArray = SharedCacheMap-&gt;Vacbs;
02156 
02157     <span class="comment">//</span>
02158     <span class="comment">//  Caller must have verified that we have a hierarchy, otherwise this routine</span>
02159     <span class="comment">//  would fail.</span>
02160     <span class="comment">//</span>
02161 
02162     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SharedCacheMap-&gt;SectionSize.QuadPart &gt; VACB_SIZE_OF_FIRST_LEVEL);
02163 
02164     <span class="comment">//</span>
02165     <span class="comment">//  Loop to calculate how many levels we have and how much we have to</span>
02166     <span class="comment">//  shift to index into the first level.</span>
02167     <span class="comment">//</span>
02168 
02169     <span class="keywordflow">do</span> {
02170 
02171         Level += 1;
02172         Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02173 
02174     } <span class="keywordflow">while</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift));
02175 
02176     <span class="comment">//</span>
02177     <span class="comment">//  Our caller could be asking for an offset off the end of section size, so if he</span>
02178     <span class="comment">//  is actually off the size of the level, then return the main listhead.</span>
02179     <span class="comment">//</span>
02180 
02181     <span class="keywordflow">if</span> (FileOffset &gt;= ((LONGLONG)1 &lt;&lt; Shift)) {
02182         <span class="keywordflow">return</span> &amp;SharedCacheMap-&gt;BcbList;
02183     }
02184 
02185     <span class="comment">//</span>
02186     <span class="comment">//  Now descend the tree to the bottom level to get the caller's Bcb ListHead.</span>
02187     <span class="comment">//</span>
02188 
02189     Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02190     <span class="keywordflow">do</span> {
02191 
02192         <span class="comment">//</span>
02193         <span class="comment">//  Decrement back to the level that describes the size we are within.</span>
02194         <span class="comment">//</span>
02195 
02196         Level -= 1;
02197 
02198         <span class="comment">//</span>
02199         <span class="comment">//  Calculate the index into the Vacb block for this level.</span>
02200         <span class="comment">//</span>
02201 
02202         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(FileOffset &gt;&gt; Shift);
02203         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Index &lt;= VACB_LAST_INDEX_FOR_LEVEL);
02204 
02205         <span class="comment">//</span>
02206         <span class="comment">//  Get block address for next level.</span>
02207         <span class="comment">//</span>
02208 
02209         NextVacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
02210 
02211         <span class="comment">//</span>
02212         <span class="comment">//  If it is NULL then we have to go find the highest Bcb or listhead which</span>
02213         <span class="comment">//  comes before the guy we are looking for, i.e., its predecessor.</span>
02214         <span class="comment">//</span>
02215 
02216         <span class="keywordflow">if</span> (NextVacbArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02217 
02218             <span class="comment">//</span>
02219             <span class="comment">//  Back up to look for the highest guy earlier in this tree, i.e., the</span>
02220             <span class="comment">//  predecessor listhead.</span>
02221             <span class="comment">//</span>
02222 
02223             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02224 
02225                 <span class="comment">//</span>
02226                 <span class="comment">//  Scan, if we can, in the current array for a non-null index.</span>
02227                 <span class="comment">//</span>
02228 
02229                 <span class="keywordflow">if</span> (FailToSuccessor) {
02230 
02231                     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != <a class="code" href="../../d5/d5/cc_8h.html#a40">VACB_LAST_INDEX_FOR_LEVEL</a>) {
02232 
02233                         <span class="keywordflow">while</span> ((<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != <a class="code" href="../../d5/d5/cc_8h.html#a40">VACB_LAST_INDEX_FOR_LEVEL</a>) &amp;&amp; (VacbArray[++<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02234                             <span class="keywordflow">continue</span>;
02235                         }
02236 
02237                         <span class="comment">//</span>
02238                         <span class="comment">//  If we found a non-null index, get out and try to return the</span>
02239                         <span class="comment">//  listhead.</span>
02240                         <span class="comment">//</span>
02241 
02242                         <span class="keywordflow">if</span> ((NextVacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02243                             <span class="keywordflow">break</span>;
02244                         }
02245                     }
02246 
02247                 } <span class="keywordflow">else</span> {
02248 
02249                     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != 0) {
02250 
02251                         <span class="keywordflow">while</span> ((<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != 0) &amp;&amp; (VacbArray[--<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02252                             <span class="keywordflow">continue</span>;
02253                         }
02254 
02255                         <span class="comment">//</span>
02256                         <span class="comment">//  If we found a non-null index, get out and try to return the</span>
02257                         <span class="comment">//  listhead.</span>
02258                         <span class="comment">//</span>
02259 
02260                         <span class="keywordflow">if</span> ((NextVacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02261                             <span class="keywordflow">break</span>;
02262                         }
02263                     }
02264                 }
02265 
02266                 <span class="comment">//</span>
02267                 <span class="comment">//  If there are no saved levels yet, then there is no predecessor or</span>
02268                 <span class="comment">//  successor - it is the main listhead.</span>
02269                 <span class="comment">//</span>
02270 
02271                 <span class="keywordflow">if</span> (SavedLevels == 0) {
02272                     <span class="keywordflow">return</span> &amp;SharedCacheMap-&gt;BcbList;
02273                 }
02274 
02275                 <span class="comment">//</span>
02276                 <span class="comment">//  Otherwise, we can pop up a level in the tree and start scanning</span>
02277                 <span class="comment">//  from that guy for a path to the right listhead.</span>
02278                 <span class="comment">//</span>
02279 
02280                 Level += 1;
02281                 <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = SavedIndexes[--SavedLevels];
02282                 VacbArray = SavedVacbArrays[SavedLevels];
02283             }
02284 
02285             <span class="comment">//</span>
02286             <span class="comment">//  We have backed up in the hierarchy, so now we are just looking for the</span>
02287             <span class="comment">//  highest/lowest guy in the level we want, i.e., the level-linking listhead.</span>
02288             <span class="comment">//  So smash FileOffset accordingly (we mask the high bits out anyway).</span>
02289             <span class="comment">//</span>
02290 
02291             <span class="keywordflow">if</span> (FailToSuccessor) {
02292                 FileOffset = 0;
02293             } <span class="keywordflow">else</span> {
02294                 FileOffset = MAXLONGLONG;
02295             }
02296         }
02297 
02298         <span class="comment">//</span>
02299         <span class="comment">//  We save Index and VacbArray at each level, for the case that we</span>
02300         <span class="comment">//  have to walk back up the tree to find a predecessor.</span>
02301         <span class="comment">//</span>
02302 
02303         SavedIndexes[SavedLevels] = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02304         SavedVacbArrays[SavedLevels] = VacbArray;
02305         SavedLevels += 1;
02306 
02307         <span class="comment">//</span>
02308         <span class="comment">//  Now make this one our current pointer, and mask away the extraneous high-order</span>
02309         <span class="comment">//  FileOffset bits for this level.</span>
02310         <span class="comment">//</span>
02311 
02312         VacbArray = NextVacbArray;
02313         FileOffset &amp;= ((LONGLONG)1 &lt;&lt; Shift) - 1;
02314         Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02315 
02316     <span class="comment">//</span>
02317     <span class="comment">//  Loop until we hit the bottom level.</span>
02318     <span class="comment">//</span>
02319 
02320     } <span class="keywordflow">while</span> (Level != 0);
02321 
02322     <span class="comment">//</span>
02323     <span class="comment">//  Now calculate the index for the bottom level and return the appropriate listhead.</span>
02324     <span class="comment">//  (The normal Vacb index indexes to a pointer to a Vacb for a .25MB view, so dropping</span>
02325     <span class="comment">//  the low bit gets you to the even-indexed Vacb pointer which is one block size below</span>
02326     <span class="comment">//  the two-pointer listhead for the Bcbs for that .5MB range...)</span>
02327     <span class="comment">//</span>
02328 
02329     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(FileOffset &gt;&gt; Shift);
02330     <span class="keywordflow">return</span> (PLIST_ENTRY)((PCHAR)&amp;VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &amp; ~1] + <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>);
02331 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="vacbsup.c::CcGetVacbLargeOffset" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> CcGetVacbLargeOffset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LONGLONG&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02534">2534</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00083">CcBeyondVacbs</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00082">CcVacbs</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00307">VACB_LEVEL_SHIFT</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00327">VACB_SIZE_OF_FIRST_LEVEL</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00086">SetVacb()</a>.
<p>
<pre class="fragment"><div>02541                    :
02542 
02543     This routine may be called to <span class="keywordflow">return</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified FileOffset.
02544     It should <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> be called <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> SectionSize <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> greater than <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>.
02545 
02546 Arguments:
02547 
02548     SharedCacheMap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> SharedCacheMap <span class="keywordflow">for</span> which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb
02549                      <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> desired.
02550 
02551     FileOffset - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fileOffset corresponding to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired Vacb.
02552 
02553 Return Value:
02554 
02555     Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired Vacb pointer or <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <span class="keywordflow">if</span> there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> none.
02556 
02557 Environment:
02558 
02559     <a class="code" href="../../d5/d2/cachedat_8c.html#a18">CcVacbSpinLock</a> should be held on entry.
02560 
02561 --*/
02562 
02563 {
02564     ULONG Level, Shift;
02565     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray;
02566     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
02567 
02568     <span class="comment">//</span>
02569     <span class="comment">//  Initialize variables controlling our descent into the hierarchy.</span>
02570     <span class="comment">//</span>
02571 
02572     Level = 0;
02573     Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02574     VacbArray = SharedCacheMap-&gt;Vacbs;
02575 
02576     <span class="comment">//</span>
02577     <span class="comment">//  Caller must have verified that we have a hierarchy, otherwise this routine</span>
02578     <span class="comment">//  would fail.</span>
02579     <span class="comment">//</span>
02580 
02581     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SharedCacheMap-&gt;SectionSize.QuadPart &gt; VACB_SIZE_OF_FIRST_LEVEL);
02582 
02583     <span class="comment">//</span>
02584     <span class="comment">//  Loop to calculate how many levels we have and how much we have to</span>
02585     <span class="comment">//  shift to index into the first level.</span>
02586     <span class="comment">//</span>
02587 
02588     <span class="keywordflow">do</span> {
02589 
02590         Level += 1;
02591         Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02592 
02593     } <span class="keywordflow">while</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift));
02594 
02595     <span class="comment">//</span>
02596     <span class="comment">//  Now descend the tree to the bottom level to get the caller's Vacb.</span>
02597     <span class="comment">//</span>
02598 
02599     Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02600     <span class="keywordflow">while</span> (((Vacb = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)VacbArray[FileOffset &gt;&gt; Shift]) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (Level != 0)) {
02601 
02602         Level -= 1;
02603 
02604         VacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)Vacb;
02605         FileOffset &amp;= ((LONGLONG)1 &lt;&lt; Shift) - 1;
02606 
02607         Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02608     }
02609 
02610     <span class="comment">//</span>
02611     <span class="comment">//  If the Vacb we exited with is not NULL, we want to make sure it looks OK.</span>
02612     <span class="comment">//</span>
02613 
02614     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Vacb == NULL || ((Vacb &gt;= CcVacbs) &amp;&amp; (Vacb &lt; CcBeyondVacbs)));
02615 
02616     <span class="keywordflow">return</span> Vacb;
02617 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="vacbsup.c::CcGetVacbMiss" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> CcGetVacbMiss           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PKIRQL&nbsp;</td>
          <td class="mdname" nowrap> <em>OldIrql</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00401">401</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00802">_SHARED_CACHE_MAP::ActiveVacb</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00583">_VACB::BaseAddress</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00070">CcAcquireMasterLockAtDpcLevel</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00076">CcAcquireVacbLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01010">CcDecrementOpenCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00031">CcDirtySharedCacheMapList</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02044">CcDrainVacbLevelZone()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01003">CcIncrementOpenCount</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00085">CcMaxVacbLevelsSeen</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00163">CcMoveVacbToReuseHead</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01931">CcPrefillVacbLevelZone()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00073">CcReleaseMasterLockFromDpcLevel</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01156">CcUnmapVacb()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01784">CcUnmapVacbArray()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00084">CcVacbLru</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00181">CheckedDec</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02292">DebugTrace2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00796">_SHARED_CACHE_MAP::FileObject</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00832">_SHARED_CACHE_MAP::Flags</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01588">GetActiveVacbAtDpcLevel</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00078">GetVacb</a>, <a class="el" href="../../d3/d7/eventobj_8c-source.html#l00343">KeSetEvent()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00619">_VACB::LruList</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00462">mm</a>, <a class="el" href="../../d2/d4/mapcache_8c-source.html#l00063">MmMapViewInSystemCache()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00740">_SHARED_CACHE_MAP::OpenCount</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01471">_LAZY_WRITER::OtherWork</a>, <a class="el" href="../../d2/d5/struct__VACB.html#o4">_VACB::Overlay</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01098">RANDOM_ACCESS_SEEN</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01521">_FILE_OBJECT::SectionObjectPointer</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00200">SEQUENTIAL_MAP_LIMIT</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00086">SetVacb()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01472">_SECTION_OBJECT_POINTERS::SharedCacheMap</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00589">_VACB::SharedCacheMap</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01113">_SHARED_CACHE_MAP_LIST_CURSOR::SharedCacheMapLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00826">_SHARED_CACHE_MAP::SharedCacheMapLinks</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00327">VACB_SIZE_OF_FIRST_LEVEL</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01051">WRITE_QUEUED</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">CcGetVirtualAddress()</a>.
<p>
<pre class="fragment"><div>00409                    :
00410 
00411     This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d3/d9/arcinst_8c.html#a19">main</a> routine <span class="keywordflow">for</span> Vacb management.  It may be called to acquire
00412     a <span class="keyword">virtual</span> address <span class="keywordflow">for</span> a given <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> offset.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> offset <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00413     already mapped, <span class="keyword">this</span> routine does very little work before returning with
00414     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired <span class="keyword">virtual</span> address and Vacb pointer (which must be supplied to
00415     free the mapping).
00416 
00417     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired <span class="keyword">virtual</span> address <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not currently mapped, then <span class="keyword">this</span> routine
00418     claims a Vacb from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tail of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb LRU to reuse its mapping.  This Vacb
00419     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> then unmapped <span class="keywordflow">if</span> necessary (normally not required), and mapped to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00420     desired address.
00421 
00422 Arguments:
00423 
00424     SharedCacheMap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Shared Cache Map <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00425 
00426     FileOffset - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired FileOffset within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00427 
00428     OldIrql - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> OldIrql variable in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller
00429 
00430 Return Value:
00431 
00432     The Vacb.
00433 
00434 --*/
00435 
00436 {
00437     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> OldSharedCacheMap;
00438     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb, TempVacb;
00439     LARGE_INTEGER MappedLength;
00440     LARGE_INTEGER NormalOffset;
00441     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00442     ULONG ActivePage;
00443     ULONG PageIsDirty;
00444     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00445     ULONG VacbOffset = FileOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1);
00446 
00447     NormalOffset = FileOffset;
00448     NormalOffset.LowPart -= VacbOffset;
00449 
00450     <span class="comment">//</span>
00451     <span class="comment">//  For files that are not open for random access, we assume sequential</span>
00452     <span class="comment">//  access and periodically unmap unused views behind us as we go, to</span>
00453     <span class="comment">//  keep from hogging memory.</span>
00454     <span class="comment">//</span>
00455     <span class="comment">//  We used to only do this for pure FO_SEQUENTIAL_ONLY access.  The</span>
00456     <span class="comment">//  sequential flags still has an effect (to put the pages at the front</span>
00457     <span class="comment">//  of the standby lists) but we intend for the majority of the file</span>
00458     <span class="comment">//  cache to live on the standby and are willing to take transition</span>
00459     <span class="comment">//  faults to bring it back.  Granted, this exacerbates the problem that</span>
00460     <span class="comment">//  it is hard to figure out how big the filecache really is since even</span>
00461     <span class="comment">//  less of it is going to be mapped at any given time.  It may also</span>
00462     <span class="comment">//  promote the synchronization bottlenecks in view mapping (MmPfnLock)</span>
00463     <span class="comment">//  to the forefront when significant view thrashing occurs.</span>
00464     <span class="comment">//</span>
00465     <span class="comment">//  This isn't as bad as it seems.  When we see access take a view miss,</span>
00466     <span class="comment">//  it is really likely that it is a result of sequential access.  As long</span>
00467     <span class="comment">//  as the pages go onto the back of the standby, they'll live for a while.</span>
00468     <span class="comment">//  The problem we're dealing with here is that the cache can be filled at</span>
00469     <span class="comment">//  high speed, but the working set manager can't possibly trim it as fast,</span>
00470     <span class="comment">//  intelligently, while we have a pretty good guess where the candidate</span>
00471     <span class="comment">//  pages should come from.  We can't let the filecache size make large</span>
00472     <span class="comment">//  excursions, or we'll kick out a lot of valuable pages in the process.</span>
00473     <span class="comment">//</span>
00474 
00475     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, RANDOM_ACCESS_SEEN) &amp;&amp;
00476         ((NormalOffset.LowPart &amp; (<a class="code" href="../../d5/d5/cc_8h.html#a31">SEQUENTIAL_MAP_LIMIT</a> - 1)) == 0) &amp;&amp;
00477         (NormalOffset.QuadPart &gt;= (<a class="code" href="../../d5/d5/cc_8h.html#a31">SEQUENTIAL_MAP_LIMIT</a> * 2))) {
00478 
00479         <span class="comment">//</span>
00480         <span class="comment">//  Use MappedLength as a scratch variable to form the offset</span>
00481         <span class="comment">//  to start unmapping.  We are not synchronized with these past</span>
00482         <span class="comment">//  views, so it is possible that CcUnmapVacbArray will kick out</span>
00483         <span class="comment">//  early when it sees an active view.  That is why we go back</span>
00484         <span class="comment">//  twice the distance, and effectively try to unmap everything</span>
00485         <span class="comment">//  twice.  The second time should normally do it.  If the file</span>
00486         <span class="comment">//  is truly sequential only, then the only collision expected</span>
00487         <span class="comment">//  might be the previous view if we are being called from readahead,</span>
00488         <span class="comment">//  or there is a small chance that we can collide with the</span>
00489         <span class="comment">//  Lazy Writer during the small window where he briefly maps</span>
00490         <span class="comment">//  the file to push out the dirty bits.</span>
00491         <span class="comment">//</span>
00492 
00493         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
00494         MappedLength.QuadPart = NormalOffset.QuadPart - (<a class="code" href="../../d5/d5/cc_8h.html#a31">SEQUENTIAL_MAP_LIMIT</a> * 2);
00495         <a class="code" href="../../d5/d3/vacbsup_8c.html#a22">CcUnmapVacbArray</a>( SharedCacheMap, &amp;MappedLength, (SEQUENTIAL_MAP_LIMIT * 2), TRUE );
00496         <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
00497     }
00498 
00499     <span class="comment">//</span>
00500     <span class="comment">//  Scan from the front of the lru for the next victim Vacb</span>
00501     <span class="comment">//</span>
00502 
00503     Vacb = CONTAINING_RECORD( <a class="code" href="../../d5/d2/cachedat_8c.html#a22">CcVacbLru</a>.Flink, <a class="code" href="../../d2/d5/struct__VACB.html">VACB</a>, LruList );
00504 
00505     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00506 
00507         <span class="comment">//</span>
00508         <span class="comment">//  If this guy is not active, break out and use him.  Also, if</span>
00509         <span class="comment">//  it is an Active Vacb, nuke it now, because the reader may be idle and we</span>
00510         <span class="comment">//  want to clean up.</span>
00511         <span class="comment">//</span>
00512 
00513         OldSharedCacheMap = Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>;
00514         <span class="keywordflow">if</span> ((Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount == 0) ||
00515             ((ActiveVacb == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00516              (OldSharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00517              (OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o11">ActiveVacb</a> == Vacb))) {
00518 
00519             <span class="comment">//</span>
00520             <span class="comment">//  The normal case is that the Vacb is no longer mapped</span>
00521             <span class="comment">//  and we can just get out and use it, however, here we</span>
00522             <span class="comment">//  handle the case where it is mapped.</span>
00523             <span class="comment">//</span>
00524 
00525             <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00526 
00527 
00528                 <span class="comment">//</span>
00529                 <span class="comment">//  If this Vacb is active, it must be the ActiveVacb.</span>
00530                 <span class="comment">//</span>
00531 
00532                 <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount != 0) {
00533 
00534                     <span class="comment">//</span>
00535                     <span class="comment">//  Get the active Vacb.</span>
00536                     <span class="comment">//</span>
00537 
00538                     <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>, ActiveVacb, ActivePage, PageIsDirty );
00539 
00540                 <span class="comment">//</span>
00541                 <span class="comment">//  Otherwise we will break out and use this Vacb.  If it</span>
00542                 <span class="comment">//  is still mapped we can now safely increment the open</span>
00543                 <span class="comment">//  count.</span>
00544                 <span class="comment">//</span>
00545 
00546                 } <span class="keywordflow">else</span> {
00547 
00548                     <span class="comment">//</span>
00549                     <span class="comment">//  Note that if the SharedCacheMap is currently</span>
00550                     <span class="comment">//  being deleted, we need to skip over</span>
00551                     <span class="comment">//  it, otherwise we will become the second</span>
00552                     <span class="comment">//  deleter.  CcDeleteSharedCacheMap clears the</span>
00553                     <span class="comment">//  pointer in the SectionObjectPointer.</span>
00554                     <span class="comment">//</span>
00555 
00556                     <a class="code" href="../../d5/d5/cc_8h.html#a2">CcAcquireMasterLockAtDpcLevel</a>();
00557                     <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o6">SectionObjectPointer</a>-&gt;<a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html#o1">SharedCacheMap</a> ==
00558                         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>) {
00559 
00560                         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>, 'mvGS' );
00561                         <a class="code" href="../../d5/d5/cc_8h.html#a3">CcReleaseMasterLockFromDpcLevel</a>();
00562                         <span class="keywordflow">break</span>;
00563                     }
00564                     <a class="code" href="../../d5/d5/cc_8h.html#a3">CcReleaseMasterLockFromDpcLevel</a>();
00565                 }
00566             } <span class="keywordflow">else</span> {
00567                 <span class="keywordflow">break</span>;
00568             }
00569         }
00570 
00571         <span class="comment">//</span>
00572         <span class="comment">//  Advance to the next guy if we haven't scanned</span>
00573         <span class="comment">//  the entire list.</span>
00574         <span class="comment">//</span>
00575 
00576         <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o5">LruList</a>.Flink != &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a22">CcVacbLru</a>) {
00577 
00578             Vacb = CONTAINING_RECORD( Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o5">LruList</a>.Flink, <a class="code" href="../../d2/d5/struct__VACB.html">VACB</a>, LruList );
00579 
00580         } <span class="keywordflow">else</span> {
00581 
00582             <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
00583 
00584             <span class="comment">//</span>
00585             <span class="comment">//  If we found an active vacb, then free it and go back and</span>
00586             <span class="comment">//  try again.  Else it's time to bail.</span>
00587             <span class="comment">//</span>
00588 
00589             <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00590                 <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>, ActiveVacb, ActivePage, PageIsDirty );
00591                 ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00592 
00593                 <span class="comment">//</span>
00594                 <span class="comment">//  Reacquire spinlocks to loop back and position ourselves at the head</span>
00595                 <span class="comment">//  of the LRU for the next pass.</span>
00596                 <span class="comment">//</span>
00597 
00598                 <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
00599 
00600                 Vacb = CONTAINING_RECORD( <a class="code" href="../../d5/d2/cachedat_8c.html#a22">CcVacbLru</a>.Flink, <a class="code" href="../../d2/d5/struct__VACB.html">VACB</a>, LruList );
00601 
00602             } <span class="keywordflow">else</span> {
00603                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00604             }
00605         }
00606     }
00607 
00608     <span class="comment">//</span>
00609     <span class="comment">//  Unlink it from the other SharedCacheMap, so the other</span>
00610     <span class="comment">//  guy will not try to use it when we free the spin lock.</span>
00611     <span class="comment">//</span>
00612 
00613     <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00614 
00615         OldSharedCacheMap = Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>;
00616         <a class="code" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a>( OldSharedCacheMap, Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.FileOffset, NULL );
00617         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00618     }
00619 
00620     <span class="comment">//</span>
00621     <span class="comment">//  Mark it in use so no one else will muck with it after</span>
00622     <span class="comment">//  we release the spin lock.</span>
00623     <span class="comment">//</span>
00624 
00625     Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount = 1;
00626     SharedCacheMap-&gt;VacbActiveCount += 1;
00627 
00628     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
00629 
00630     <span class="comment">//</span>
00631     <span class="comment">//  If the Vacb is already mapped, then unmap it.</span>
00632     <span class="comment">//</span>
00633 
00634     <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00635 
00636         <span class="comment">//</span>
00637         <span class="comment">//  Check to see if we need to drain the zone.</span>
00638         <span class="comment">//</span>
00639 
00640         <a class="code" href="../../d5/d5/cc_8h.html#a205">CcDrainVacbLevelZone</a>();
00641 
00642         <a class="code" href="../../d5/d3/vacbsup_8c.html#a6">CcUnmapVacb</a>( Vacb, OldSharedCacheMap, FALSE );
00643 
00644         <span class="comment">//</span>
00645         <span class="comment">//  Now we can decrement the open count as we normally</span>
00646         <span class="comment">//  do, possibly deleting the guy.</span>
00647         <span class="comment">//</span>
00648 
00649         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( OldIrql );
00650 
00651         <span class="comment">//</span>
00652         <span class="comment">//  Now release our open count.</span>
00653         <span class="comment">//</span>
00654 
00655         <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( OldSharedCacheMap, 'mvGF' );
00656 
00657         <span class="keywordflow">if</span> ((OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
00658             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, WRITE_QUEUED) &amp;&amp;
00659             (OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
00660 
00661             <span class="comment">//</span>
00662             <span class="comment">//  Move to the dirty list.</span>
00663             <span class="comment">//</span>
00664 
00665             RemoveEntryList( &amp;OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
00666             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
00667                             &amp;OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
00668 
00669             <span class="comment">//</span>
00670             <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
00671             <span class="comment">//  want him to delete this SharedCacheMap.</span>
00672             <span class="comment">//</span>
00673 
00674             <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00675             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
00676                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
00677             }
00678         }
00679 
00680         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( *OldIrql );
00681     }
00682 
00683     <span class="comment">//</span>
00684     <span class="comment">//  Use try-finally to return this guy to the list if we get an</span>
00685     <span class="comment">//  exception.</span>
00686     <span class="comment">//</span>
00687 
00688     <span class="keywordflow">try</span> {
00689 
00690         <span class="comment">//</span>
00691         <span class="comment">//  Assume we are mapping to the end of the section, but</span>
00692         <span class="comment">//  reduce to our normal mapping granularity if the section</span>
00693         <span class="comment">//  is too large.</span>
00694         <span class="comment">//</span>
00695 
00696         MappedLength.QuadPart = SharedCacheMap-&gt;SectionSize.QuadPart - NormalOffset.QuadPart;
00697 
00698         <span class="keywordflow">if</span> ((MappedLength.HighPart != 0) ||
00699             (MappedLength.LowPart &gt; <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a>)) {
00700 
00701             MappedLength.LowPart = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a>;
00702         }
00703 
00704         <span class="comment">//</span>
00705         <span class="comment">//  Now map this one in the system cache.</span>
00706         <span class="comment">//</span>
00707 
00708         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmMapViewInSystemCache:\n"</span>, 0 );
00709         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    Section = %08lx\n"</span>, SharedCacheMap-&gt;Section );
00710         <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, mm, <span class="stringliteral">"    Offset = %08lx, %08lx\n"</span>,
00711                                 NormalOffset.LowPart,
00712                                 NormalOffset.HighPart );
00713         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    ViewSize = %08lx\n"</span>, MappedLength.LowPart );
00714 
00715         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> =
00716           <a class="code" href="../../d1/d5/mapcache_8c.html#a9">MmMapViewInSystemCache</a>( SharedCacheMap-&gt;Section,
00717                                   &amp;Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a>,
00718                                   &amp;NormalOffset,
00719                                   &amp;MappedLength.LowPart );
00720 
00721         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    &lt;BaseAddress = %08lx\n"</span>, Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> );
00722         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    &lt;ViewSize = %08lx\n"</span>, MappedLength.LowPart );
00723 
00724         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00725 
00726             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Error from Map, Status = %08lx\n"</span>, Status );
00727 
00728             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
00729                                                    STATUS_UNEXPECTED_MM_MAP_ERROR ));
00730         }
00731 
00732     } finally {
00733 
00734         <span class="comment">//</span>
00735         <span class="comment">//  Take this opportunity to free the active vacb.</span>
00736         <span class="comment">//</span>
00737 
00738         <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00739 
00740             <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>, ActiveVacb, ActivePage, PageIsDirty );
00741         }
00742 
00743         <span class="comment">//</span>
00744         <span class="comment">//  On abnormal termination, get this guy back in the list.</span>
00745         <span class="comment">//</span>
00746 
00747         <span class="keywordflow">if</span> (AbnormalTermination()) {
00748 
00749             <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
00750 
00751             <span class="comment">//</span>
00752             <span class="comment">//  This is like the unlucky case below.  Just back out the stuff</span>
00753             <span class="comment">//  we did and put the guy at the tail of the list.  Basically</span>
00754             <span class="comment">//  only the Map should fail, and we clear BaseAddress accordingly.</span>
00755             <span class="comment">//</span>
00756 
00757             Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00758 
00759             <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount);
00760             <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(SharedCacheMap-&gt;VacbActiveCount);
00761 
00762             <span class="comment">//</span>
00763             <span class="comment">//  If there is someone waiting for this count to go to zero,</span>
00764             <span class="comment">//  wake them here.</span>
00765             <span class="comment">//</span>
00766 
00767             <span class="keywordflow">if</span> (SharedCacheMap-&gt;WaitOnActiveCount != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00768                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( SharedCacheMap-&gt;WaitOnActiveCount, 0, FALSE );
00769             }
00770 
00771             <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
00772         }
00773     }
00774 
00775     <span class="comment">//</span>
00776     <span class="comment">//  Make sure the zone contains the worst case number of entries.</span>
00777     <span class="comment">//</span>
00778 
00779     <span class="keywordflow">if</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
00780 
00781         <span class="comment">//</span>
00782         <span class="comment">//  Raise if we cannot preallocate enough buffers.</span>
00783         <span class="comment">//</span>
00784 
00785         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d3/vacbsup_8c.html#a23">CcPrefillVacbLevelZone</a>( CcMaxVacbLevelsSeen - 1,
00786                                      OldIrql,
00787                                      <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, MODIFIED_WRITE_DISABLED) )) {
00788 
00789             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00790         }
00791 
00792     } <span class="keywordflow">else</span> {
00793 
00794         <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
00795     }
00796 
00797     <span class="comment">//</span>
00798     <span class="comment">//  Finish filling in the Vacb, and store its address in the array in</span>
00799     <span class="comment">//  the Shared Cache Map.  (We have to rewrite the ActiveCount</span>
00800     <span class="comment">//  since it is overlaid.)  To do this we must reacquire the</span>
00801     <span class="comment">//  spin lock one more time.  Note we have to check for the unusual</span>
00802     <span class="comment">//  case that someone beat us to mapping this view, since we had to</span>
00803     <span class="comment">//  drop the spin lock.</span>
00804     <span class="comment">//</span>
00805 
00806     <span class="keywordflow">if</span> ((TempVacb = <a class="code" href="../../d5/d3/vacbsup_8c.html#a1">GetVacb</a>( SharedCacheMap, NormalOffset )) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00807 
00808         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a> = SharedCacheMap;
00809         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.FileOffset = NormalOffset;
00810         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount = 1;
00811 
00812         <a class="code" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a>( SharedCacheMap, NormalOffset, Vacb );
00813 
00814     <span class="comment">//</span>
00815     <span class="comment">//  This is the unlucky case where we collided with someone else</span>
00816     <span class="comment">//  trying to map the same view.  He can get in because we dropped</span>
00817     <span class="comment">//  the spin lock above.  Rather than allocating events and making</span>
00818     <span class="comment">//  someone wait, considering this case is fairly unlikely, we just</span>
00819     <span class="comment">//  dump this one at the head of the LRU and use the one from the</span>
00820     <span class="comment">//  guy who beat us.</span>
00821     <span class="comment">//</span>
00822 
00823     } <span class="keywordflow">else</span> {
00824 
00825         <span class="comment">//</span>
00826         <span class="comment">//  Now we have to increment all of the counts for the one that</span>
00827         <span class="comment">//  was already there, then ditch the one we had.</span>
00828         <span class="comment">//</span>
00829 
00830         <span class="keywordflow">if</span> (TempVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount == 0) {
00831             SharedCacheMap-&gt;VacbActiveCount += 1;
00832         }
00833 
00834         TempVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount += 1;
00835 
00836         <span class="comment">//</span>
00837         <span class="comment">//  Now unmap the one we mapped and proceed with the other Vacb.</span>
00838         <span class="comment">//  On this path we have to release the spinlock to do the unmap,</span>
00839         <span class="comment">//  and then reacquire the spinlock before cleaning up.</span>
00840         <span class="comment">//</span>
00841 
00842         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
00843 
00844         <a class="code" href="../../d5/d3/vacbsup_8c.html#a6">CcUnmapVacb</a>( Vacb, SharedCacheMap, FALSE );
00845 
00846         <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
00847         <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount);
00848         <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(SharedCacheMap-&gt;VacbActiveCount);
00849         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00850 
00851         <a class="code" href="../../d5/d3/vacbsup_8c.html#a2">CcMoveVacbToReuseHead</a>( Vacb );
00852 
00853         Vacb = TempVacb;
00854     }
00855 
00856     <span class="keywordflow">return</span> Vacb;
00857 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="vacbsup.c::CcGetVirtualAddress" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID CcGetVirtualAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Vacb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ReceivedLength</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">310</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00076">CcAcquireVacbLock</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00401">CcGetVacbMiss()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00166">CcMoveVacbToReuseTail</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00087">DISPATCH_LEVEL</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00078">GetVacb</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d2/d5/struct__VACB.html#o4">_VACB::Overlay</a>, and <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">CcFastCopyRead()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l06024">CcMapAndCopy()</a>, <a class="el" href="../../d3/d8/pinsup_8c-source.html#l00052">CcMapData()</a>, <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00030">CcMdlRead()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01633">CcPerformReadAhead()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d8/d4/mdlsup_8c-source.html#l00466">CcPrepareMdlWrite()</a>, and <a class="el" href="../../d6/d7/fssup_8c-source.html#l02194">CcPurgeAndClearCacheSection()</a>.
<p>
<pre class="fragment"><div>00319                    :
00320 
00321     This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d3/d9/arcinst_8c.html#a19">main</a> routine <span class="keywordflow">for</span> Vacb management.  It may be called to acquire
00322     a <span class="keyword">virtual</span> address <span class="keywordflow">for</span> a given <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> offset.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> offset <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00323     already mapped, <span class="keyword">this</span> routine does very little work before returning with
00324     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired <span class="keyword">virtual</span> address and Vacb pointer (which must be supplied to
00325     free the mapping).
00326 
00327     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired <span class="keyword">virtual</span> address <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not currently mapped, then <span class="keyword">this</span> routine
00328     claims a Vacb from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tail of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb LRU to reuse its mapping.  This Vacb
00329     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> then unmapped <span class="keywordflow">if</span> necessary (normally not required), and mapped to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00330     desired address.
00331 
00332 Arguments:
00333 
00334     SharedCacheMap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Shared Cache Map <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00335 
00336     FileOffset - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired FileOffset within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00337 
00338     Vacb - Returns a Vacb pointer which must be supplied later to free
00339            <span class="keyword">this</span> <span class="keyword">virtual</span> address.
00340 
00341     ReceivedLength - Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of bytes which are contiguously
00342                      mapped starting at <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">virtual</span> address returned.
00343 
00344 Return Value:
00345 
00346     The <span class="keyword">virtual</span> address at which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> mapped.
00347 
00348 --*/
00349 
00350 {
00351     KIRQL OldIrql;
00352     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> TempVacb;
00353     ULONG VacbOffset = FileOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1);
00354 
00355     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; DISPATCH_LEVEL);
00356 
00357     <span class="comment">//</span>
00358     <span class="comment">//  Acquire the Vacb lock to see if the desired offset is already mapped.</span>
00359     <span class="comment">//</span>
00360 
00361     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
00362 
00363     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileOffset.QuadPart &lt;= SharedCacheMap-&gt;SectionSize.QuadPart );
00364 
00365     <span class="keywordflow">if</span> ((TempVacb = <a class="code" href="../../d5/d3/vacbsup_8c.html#a1">GetVacb</a>( SharedCacheMap, FileOffset )) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00366 
00367         TempVacb = <a class="code" href="../../d5/d3/vacbsup_8c.html#a7">CcGetVacbMiss</a>( SharedCacheMap, FileOffset, &amp;OldIrql );
00368 
00369     } <span class="keywordflow">else</span> {
00370 
00371         <span class="keywordflow">if</span> (TempVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount == 0) {
00372             SharedCacheMap-&gt;VacbActiveCount += 1;
00373         }
00374 
00375         TempVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount += 1;
00376     }
00377 
00378     <span class="comment">//</span>
00379     <span class="comment">//  Move this range away from the front to avoid wasting cycles</span>
00380     <span class="comment">//  looking at it for reuse.</span>
00381     <span class="comment">//</span>
00382 
00383     <a class="code" href="../../d5/d3/vacbsup_8c.html#a3">CcMoveVacbToReuseTail</a>( TempVacb );
00384 
00385     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
00386 
00387     <span class="comment">//</span>
00388     <span class="comment">//  Now form all outputs.</span>
00389     <span class="comment">//</span>
00390 
00391     *Vacb = TempVacb;
00392     *ReceivedLength = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - VacbOffset;
00393 
00394     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; DISPATCH_LEVEL);
00395 
00396     <span class="keywordflow">return</span> (PVOID)((PCHAR)TempVacb-&gt;BaseAddress + VacbOffset);
00397 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="vacbsup.c::CcGetVirtualAddressIfMapped" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID CcGetVirtualAddressIfMapped           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LONGLONG&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Vacb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ReceivedLength</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00230">230</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00076">CcAcquireVacbLock</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00166">CcMoveVacbToReuseTail</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00087">DISPATCH_LEVEL</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00078">GetVacb</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l04411">CcFlushCache()</a>.
<p>
<pre class="fragment"><div>00239                    :
00240 
00241     This routine returns a <span class="keyword">virtual</span> address <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified FileOffset,
00242     iff <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> mapped.  Otherwise, <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> informs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
00243     <span class="keyword">virtual</span> address was not mapped.  In <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> latter <span class="keywordflow">case</span>, <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> still returns
00244     a ReceivedLength, which may be used to advance to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> next view boundary.
00245 
00246 Arguments:
00247 
00248     SharedCacheMap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Shared Cache Map <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00249 
00250     FileOffset - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired FileOffset within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00251 
00252     Vach - Returns a Vacb pointer which must be supplied later to free
00253            <span class="keyword">this</span> <span class="keyword">virtual</span> address, or <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <span class="keywordflow">if</span> not mapped.
00254 
00255     ReceivedLength - Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of bytes to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> next view boundary,
00256                      whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> offset <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> mapped or not.
00257 
00258 Return Value:
00259 
00260     The <span class="keyword">virtual</span> address at which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> mapped, or <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <span class="keywordflow">if</span> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
00261     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not mapped.
00262 
00263 --*/
00264 
00265 {
00266     KIRQL OldIrql;
00267     ULONG VacbOffset = (ULONG)FileOffset &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1);
00268     PVOID Value = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00269 
00270     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; DISPATCH_LEVEL);
00271 
00272     <span class="comment">//</span>
00273     <span class="comment">//  Generate ReceivedLength return right away.</span>
00274     <span class="comment">//</span>
00275 
00276     *ReceivedLength = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - VacbOffset;
00277 
00278     <span class="comment">//</span>
00279     <span class="comment">//  Acquire the Vacb lock to see if the desired offset is already mapped.</span>
00280     <span class="comment">//</span>
00281 
00282     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
00283 
00284     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileOffset &lt;= SharedCacheMap-&gt;SectionSize.QuadPart );
00285 
00286     <span class="keywordflow">if</span> ((*Vacb = <a class="code" href="../../d5/d3/vacbsup_8c.html#a1">GetVacb</a>( SharedCacheMap, *(PLARGE_INTEGER)&amp;FileOffset )) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00287 
00288         <span class="keywordflow">if</span> ((*Vacb)-&gt;Overlay.ActiveCount == 0) {
00289             SharedCacheMap-&gt;VacbActiveCount += 1;
00290         }
00291 
00292         (*Vacb)-&gt;Overlay.ActiveCount += 1;
00293 
00294         <span class="comment">//</span>
00295         <span class="comment">//  Move this range away from the front to avoid wasting cycles</span>
00296         <span class="comment">//  looking at it for reuse.</span>
00297         <span class="comment">//</span>
00298 
00299         <a class="code" href="../../d5/d3/vacbsup_8c.html#a3">CcMoveVacbToReuseTail</a>( *Vacb );
00300 
00301         Value = (PVOID)((PCHAR)(*Vacb)-&gt;BaseAddress + VacbOffset);
00302     }
00303 
00304     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
00305     <span class="keywordflow">return</span> Value;
00306 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="vacbsup.c::CcInitializeVacbs" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcInitializeVacbs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00188">188</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00083">CcBeyondVacbs</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00076">CcNumberVacbs</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00084">CcVacbLru</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00082">CcVacbs</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00075">CcVacbSpinLock</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l01101">FsRtlAllocatePoolWithTag</a>, <a class="el" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00619">_VACB::LruList</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00406">MmSizeOfSystemCacheInPages</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d5/d5/cc_8h.html#a97">VACB</a>, and <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>.
<p>
Referenced by <a class="el" href="../../d6/d7/fssup_8c-source.html#l00069">CcInitializeCacheManager()</a>.
<p>
<pre class="fragment"><div>00193                    :
00194 
00195     This routine must be called during Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a> initialization to
00196     initialize <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a> Address Control Block structures.
00197 
00198 Arguments:
00199 
00200     None.
00201 
00202 Return Value:
00203 
00204     None.
00205 
00206 --*/
00207 
00208 {
00209     ULONG VacbBytes;
00210     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> NextVacb;
00211 
00212     <a class="code" href="../../d5/d2/cachedat_8c.html#a19">CcNumberVacbs</a> = (<a class="code" href="../../d2/d1/mm_8h.html#a137">MmSizeOfSystemCacheInPages</a> &gt;&gt; (<a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)) - 2;
00213     VacbBytes = <a class="code" href="../../d5/d2/cachedat_8c.html#a19">CcNumberVacbs</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d5/struct__VACB.html">VACB</a>);
00214 
00215     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;CcVacbSpinLock );
00216     <a class="code" href="../../d5/d2/cachedat_8c.html#a20">CcVacbs</a> = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)<a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( NonPagedPool, VacbBytes, 'aVcC' );
00217     <a class="code" href="../../d5/d2/cachedat_8c.html#a21">CcBeyondVacbs</a> = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)((PCHAR)<a class="code" href="../../d5/d2/cachedat_8c.html#a20">CcVacbs</a> + VacbBytes);
00218     RtlZeroMemory( CcVacbs, VacbBytes );
00219 
00220     InitializeListHead( &amp;CcVacbLru );
00221 
00222     <span class="keywordflow">for</span> (NextVacb = <a class="code" href="../../d5/d2/cachedat_8c.html#a20">CcVacbs</a>; NextVacb &lt; <a class="code" href="../../d5/d2/cachedat_8c.html#a21">CcBeyondVacbs</a>; NextVacb++) {
00223 
00224         InsertTailList( &amp;CcVacbLru, &amp;NextVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o5">LruList</a> );
00225     }
00226 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="vacbsup.c::CcPrefillVacbLevelZone" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG CcPrefillVacbLevelZone           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberNeeded</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PKIRQL&nbsp;</td>
          <td class="mdname" nowrap> <em>OldIrql</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NeedBcbListHeads</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01931">1931</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00076">CcAcquireVacbLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00086">CcVacbLevelEntries</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00087">CcVacbLevelFreeList</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00088">CcVacbLevelWithBcbsEntries</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00089">CcVacbLevelWithBcbsFreeList</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00315">VACB_LEVEL_BLOCK_SIZE</a>, and <a class="el" href="../../d5/d5/cc_8h.html#a95">VACB_LEVEL_REFERENCE</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01377">CcExtendVacbArray()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00401">CcGetVacbMiss()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00947">CcReferenceFileOffset()</a>, and <a class="el" href="../../d7/d1/cachesub_8c-source.html#l02242">CcSetDirtyInMask()</a>.
<p>
<pre class="fragment"><div>01939                    :
01940 
01941     This routine may be called to prefill <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> VacbLevelZone with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of
01942     entries required, and <span class="keywordflow">return</span> with <a class="code" href="../../d5/d2/cachedat_8c.html#a18">CcVacbSpinLock</a> acquired.  This approach <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01943     taken so that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> allocations and RtlZeroMemory calls can occur without
01944     holding any spinlock, yet <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller may proceed to peform a single indivisible
01945     operation without error handling, since there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a guaranteed <a class="code" href="../../d0/d4/mrcf_8c.html#a3">minimum</a> number of
01946     entries in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> zone.
01947 
01948 Arguments:
01949 
01950     NumberNeeded - Number of VacbLevel entries needed, not counting <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> possible
01951                    one with Bcb listheads.
01952 
01953     OldIrql = supplies a pointer to where OldIrql should be returned upon acquiring
01954               <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> spinlock.
01955 
01956     NeedBcbListHeads - Supplies <span class="keyword">true</span> <span class="keywordflow">if</span> a level <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> also needed which contains listheads.
01957 
01958 Return Value:
01959 
01960     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffers could not be preallocated, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> otherwise.
01961 
01962 Environment:
01963 
01964     No spinlocks should be held upon entry.
01965 
01966 --*/
01967 
01968 {
01969     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *NextVacbArray;
01970 
01971     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
01972 
01973     <span class="comment">//</span>
01974     <span class="comment">//  Loop until there is enough entries, else raise...</span>
01975     <span class="comment">//</span>
01976 
01977     <span class="keywordflow">while</span> ((NumberNeeded &gt; <a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a>) ||
01978            (NeedBcbListHeads &amp;&amp; (<a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>))) {
01979 
01980 
01981         <span class="comment">//</span>
01982         <span class="comment">//  Else release the spinlock so we can do the allocate/zero.</span>
01983         <span class="comment">//</span>
01984 
01985         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
01986 
01987         <span class="comment">//</span>
01988         <span class="comment">//  First handle the case where we need a VacbListHead with Bcb Listheads.</span>
01989         <span class="comment">//  The pointer test is unsafe but see below.</span>
01990         <span class="comment">//</span>
01991 
01992         <span class="keywordflow">if</span> (NeedBcbListHeads &amp;&amp; (<a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01993 
01994             <span class="comment">//</span>
01995             <span class="comment">//  Allocate and initialize the Vacb block for this level, and store its pointer</span>
01996             <span class="comment">//  back into our parent.  We do not zero the listhead area.</span>
01997             <span class="comment">//</span>
01998 
01999             NextVacbArray =
02000             (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, (VACB_LEVEL_BLOCK_SIZE * 2) + <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>), 'lVcC' );
02001 
02002             <span class="keywordflow">if</span> (NextVacbArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02003                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02004             }
02005 
02006             RtlZeroMemory( (PCHAR)NextVacbArray, VACB_LEVEL_BLOCK_SIZE );
02007             RtlZeroMemory( (PCHAR)NextVacbArray + (VACB_LEVEL_BLOCK_SIZE * 2), <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>) );
02008 
02009             <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
02010 
02011             NextVacbArray[0] = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)<a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a>;
02012             <a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a> = NextVacbArray;
02013             <a class="code" href="../../d5/d2/cachedat_8c.html#a26">CcVacbLevelWithBcbsEntries</a> += 1;
02014 
02015         } <span class="keywordflow">else</span> {
02016 
02017             <span class="comment">//</span>
02018             <span class="comment">//  Allocate and initialize the Vacb block for this level, and store its pointer</span>
02019             <span class="comment">//  back into our parent.</span>
02020             <span class="comment">//</span>
02021 
02022             NextVacbArray =
02023             (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, VACB_LEVEL_BLOCK_SIZE + <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>), 'lVcC' );
02024 
02025             <span class="keywordflow">if</span> (NextVacbArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02026                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02027             }
02028 
02029             RtlZeroMemory( (PCHAR)NextVacbArray, VACB_LEVEL_BLOCK_SIZE + <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>) );
02030 
02031             <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
02032 
02033             NextVacbArray[0] = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)<a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a>;
02034             <a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a> = NextVacbArray;
02035             <a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a> += 1;
02036         }
02037     }
02038 
02039     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02040 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="vacbsup.c::CcReferenceFileOffset" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcReferenceFileOffset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00947">947</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00085">CcMaxVacbLevelsSeen</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01931">CcPrefillVacbLevelZone()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00087">DISPATCH_LEVEL</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00086">SetVacb()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00327">VACB_SIZE_OF_FIRST_LEVEL</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00628">VACB_SPECIAL_REFERENCE</a>.
<p>
Referenced by <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>.
<p>
<pre class="fragment"><div>00954                    :
00955 
00956     This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a special form of reference that insures that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> multi-level
00957     Vacb structures are expanded to cover a given <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> offset.
00958 
00959 Arguments:
00960 
00961     SharedCacheMap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Shared Cache Map <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00962 
00963     FileOffset - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired FileOffset within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00964 
00965 Return Value:
00966 
00967     None
00968 
00969 --*/
00970 
00971 {
00972     KIRQL OldIrql;
00973 
00974     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; DISPATCH_LEVEL);
00975 
00976     <span class="comment">//</span>
00977     <span class="comment">//  This operation only has meaning if the Vacbs are in the multilevel form.</span>
00978     <span class="comment">//</span>
00979 
00980     <span class="keywordflow">if</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
00981 
00982         <span class="comment">//</span>
00983         <span class="comment">//  Prefill the level zone so that we can expand the tree if required.</span>
00984         <span class="comment">//</span>
00985 
00986         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d3/vacbsup_8c.html#a23">CcPrefillVacbLevelZone</a>( CcMaxVacbLevelsSeen - 1,
00987                                      &amp;OldIrql,
00988                                      <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, MODIFIED_WRITE_DISABLED) )) {
00989 
00990             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00991         }
00992 
00993         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileOffset.QuadPart &lt;= SharedCacheMap-&gt;SectionSize.QuadPart );
00994 
00995         <a class="code" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a>( SharedCacheMap, FileOffset, VACB_SPECIAL_REFERENCE );
00996 
00997         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
00998     }
00999 
01000     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; DISPATCH_LEVEL);
01001 
01002     <span class="keywordflow">return</span>;
01003 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="vacbsup.c::CcSetVacbLargeOffset" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcSetVacbLargeOffset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LONGLONG&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Vacb</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02621">2621</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00155">CACHE_NTC_BCB</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02048">CcAllocateVacbLevel()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02070">CcDeallocateVacbLevel()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02107">CcGetBcbListHeadLargeOffset()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d2/d9/cmchek_8c-source.html#l00095">Index</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02110">IsVacbLevelReferenced()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01077">MODIFIED_WRITE_DISABLED</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00125">ReferenceVacbLevel()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00321">VACB_LAST_INDEX_FOR_LEVEL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00315">VACB_LEVEL_BLOCK_SIZE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00307">VACB_LEVEL_SHIFT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00334">VACB_NUMBER_OF_LEVELS</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00327">VACB_SIZE_OF_FIRST_LEVEL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00629">VACB_SPECIAL_DEREFERENCE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00631">VACB_SPECIAL_FIRST_VALID</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02335">CcAdjustVacbLevelLockCount()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00086">SetVacb()</a>.
<p>
<pre class="fragment"><div>02629                    :
02630 
02631     This routine may be called to set <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified Vacb pointer <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified FileOffset.
02632     It should <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> be called <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> SectionSize <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> greater than <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>.
02633 
02634     For non-null Vacb, intermediate Vacb levels will be added as necessary, and <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lowest
02635     level has Bcb listheads, these will also be added.  For <span class="keyword">this</span> <span class="keywordflow">case</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller must acquire
02636     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> spinlock by calling <a class="code" href="../../d5/d5/cc_8h.html#a204">CcPrefillVacbLevelZone</a> specifying <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> worst-<span class="keywordflow">case</span> number of levels
02637     required.
02638 
02639     For a null Vacb pointer, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tree <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> pruned of all Vacb levels that go empty.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lowest
02640     level has Bcb listheads, then they are removed.  The caller should subsequently call
02641     <a class="code" href="../../d5/d5/cc_8h.html#a205">CcDrainVacbLevelZone</a> once <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> spinlock <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> release to actually free some of <span class="keyword">this</span> zone to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02642     <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a>.
02643 
02644 Arguments:
02645 
02646     SharedCacheMap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> SharedCacheMap <span class="keywordflow">for</span> which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb
02647                      <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> desired.
02648 
02649     FileOffset - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fileOffset corresponding to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired Vacb.
02650 
02651 Return Value:
02652 
02653     Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> desired Vacb pointer or <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <span class="keywordflow">if</span> there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> none.
02654 
02655 Environment:
02656 
02657     <a class="code" href="../../d5/d2/cachedat_8c.html#a18">CcVacbSpinLock</a> should be held on entry.
02658 
02659 --*/
02660 
02661 {
02662     ULONG Level, Shift;
02663     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray, *NextVacbArray;
02664     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02665     ULONG SavedIndexes[<a class="code" href="../../d5/d5/cc_8h.html#a42">VACB_NUMBER_OF_LEVELS</a>];
02666     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *SavedVacbArrays[<a class="code" href="../../d5/d5/cc_8h.html#a42">VACB_NUMBER_OF_LEVELS</a>];
02667     PLIST_ENTRY PredecessorListHead, SuccessorListHead, CurrentListHead;
02668     BOOLEAN AllocatingBcbListHeads, Special = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02669     LONGLONG OriginalFileOffset = FileOffset;
02670     ULONG SavedLevels = 0;
02671 
02672     <span class="comment">//</span>
02673     <span class="comment">//  Initialize variables controlling our descent into the hierarchy.</span>
02674     <span class="comment">//</span>
02675 
02676     Level = 0;
02677     Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02678     VacbArray = SharedCacheMap-&gt;Vacbs;
02679 
02680     <span class="comment">//</span>
02681     <span class="comment">//  Caller must have verified that we have a hierarchy, otherwise this routine</span>
02682     <span class="comment">//  would fail.</span>
02683     <span class="comment">//</span>
02684 
02685     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SharedCacheMap-&gt;SectionSize.QuadPart &gt; VACB_SIZE_OF_FIRST_LEVEL);
02686 
02687     <span class="comment">//</span>
02688     <span class="comment">//  Loop to calculate how many levels we have and how much we have to</span>
02689     <span class="comment">//  shift to index into the first level.</span>
02690     <span class="comment">//</span>
02691 
02692     <span class="keywordflow">do</span> {
02693 
02694         Level += 1;
02695         Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02696 
02697     } <span class="keywordflow">while</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift));
02698 
02699     <span class="comment">//</span>
02700     <span class="comment">//  Now descend the tree to the bottom level to set the caller's Vacb.</span>
02701     <span class="comment">//</span>
02702 
02703     Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02704     <span class="keywordflow">do</span> {
02705 
02706         <span class="comment">//</span>
02707         <span class="comment">//  Decrement back to the level that describes the size we are within.</span>
02708         <span class="comment">//</span>
02709 
02710         Level -= 1;
02711 
02712         <span class="comment">//</span>
02713         <span class="comment">//  Calculate the index into the Vacb block for this level.</span>
02714         <span class="comment">//</span>
02715 
02716         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(FileOffset &gt;&gt; Shift);
02717         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Index &lt;= VACB_LAST_INDEX_FOR_LEVEL);
02718 
02719         <span class="comment">//</span>
02720         <span class="comment">//  We save Index and VacbArray at each level, for the case that we</span>
02721         <span class="comment">//  are collapsing and deallocating blocks below.</span>
02722         <span class="comment">//</span>
02723 
02724         SavedIndexes[SavedLevels] = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02725         SavedVacbArrays[SavedLevels] = VacbArray;
02726         SavedLevels += 1;
02727 
02728         <span class="comment">//</span>
02729         <span class="comment">//  Get block address for next level.</span>
02730         <span class="comment">//</span>
02731 
02732         NextVacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
02733 
02734         <span class="comment">//</span>
02735         <span class="comment">//  If it is NULL then we have to allocate the next level to fill it in.</span>
02736         <span class="comment">//</span>
02737 
02738         <span class="keywordflow">if</span> (NextVacbArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02739 
02740             <span class="comment">//</span>
02741             <span class="comment">//  We better not be thinking we're dereferencing a level if the level</span>
02742             <span class="comment">//  doesn't currently exist.</span>
02743             <span class="comment">//</span>
02744 
02745             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Vacb != VACB_SPECIAL_DEREFERENCE );
02746 
02747             AllocatingBcbListHeads = <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, MODIFIED_WRITE_DISABLED) &amp;&amp; (Level == 0);
02748 
02749             <span class="comment">//</span>
02750             <span class="comment">//  This is only valid if we are setting a nonzero pointer!</span>
02751             <span class="comment">//</span>
02752 
02753             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Vacb != NULL);
02754 
02755             NextVacbArray = <a class="code" href="../../d5/d5/cc_8h.html#a206">CcAllocateVacbLevel</a>(AllocatingBcbListHeads);
02756 
02757             <span class="comment">//</span>
02758             <span class="comment">//  If we allocated Bcb Listheads, we must link them in.</span>
02759             <span class="comment">//</span>
02760 
02761             <span class="keywordflow">if</span> (AllocatingBcbListHeads) {
02762 
02763                 ULONG i;
02764 
02765                 <span class="comment">//</span>
02766                 <span class="comment">//  Find our predecessor.</span>
02767                 <span class="comment">//</span>
02768 
02769                 PredecessorListHead = <a class="code" href="../../d5/d3/vacbsup_8c.html#a25">CcGetBcbListHeadLargeOffset</a>( SharedCacheMap, OriginalFileOffset, FALSE );
02770 
02771                 <span class="comment">//</span>
02772                 <span class="comment">//  If he is followed by any Bcbs, they "belong" to him, and we have to</span>
02773                 <span class="comment">//  skip over them.</span>
02774                 <span class="comment">//</span>
02775 
02776                 <span class="keywordflow">while</span> (((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)CONTAINING_RECORD(PredecessorListHead-&gt;Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks))-&gt;NodeTypeCode ==
02777                        <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
02778                     PredecessorListHead = (PLIST_ENTRY)PredecessorListHead-&gt;Blink;
02779                 }
02780 
02781                 <span class="comment">//</span>
02782                 <span class="comment">//  Point to the first newly allocated listhead.</span>
02783                 <span class="comment">//</span>
02784 
02785                 CurrentListHead = (PLIST_ENTRY)((PCHAR)NextVacbArray + <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>);
02786 
02787                 <span class="comment">//</span>
02788                 <span class="comment">//  Link first new listhead to predecessor.</span>
02789                 <span class="comment">//</span>
02790 
02791                 SuccessorListHead = PredecessorListHead-&gt;Blink;
02792                 PredecessorListHead-&gt;Blink = CurrentListHead;
02793                 CurrentListHead-&gt;Flink = PredecessorListHead;
02794 
02795                 <span class="comment">//</span>
02796                 <span class="comment">//  Now loop to link all of the new listheads together.</span>
02797                 <span class="comment">//</span>
02798 
02799                 <span class="keywordflow">for</span> (i = 0; i &lt; ((<a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> / <span class="keyword">sizeof</span>(LIST_ENTRY) - 1)); i++) {
02800 
02801                     CurrentListHead-&gt;Blink = CurrentListHead + 1;
02802                     CurrentListHead += 1;
02803                     CurrentListHead-&gt;Flink = CurrentListHead - 1;
02804                 }
02805 
02806                 <span class="comment">//</span>
02807                 <span class="comment">//  Finally link the last new listhead to the successor.</span>
02808                 <span class="comment">//</span>
02809 
02810                 CurrentListHead-&gt;Blink = SuccessorListHead;
02811                 SuccessorListHead-&gt;Flink = CurrentListHead;
02812             }
02813 
02814             VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)NextVacbArray;
02815 
02816             <span class="comment">//</span>
02817             <span class="comment">//  Increment the reference count.  Note that Level right now properly indicates</span>
02818             <span class="comment">//  what level NextVacbArray is at, not VacbArray.</span>
02819             <span class="comment">//</span>
02820 
02821             <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, VacbArray, Level + 1, 1, FALSE );
02822         }
02823 
02824         <span class="comment">//</span>
02825         <span class="comment">//  Now make this one our current pointer, and mask away the extraneous high-order</span>
02826         <span class="comment">//  FileOffset bits for this level and reduce the shift count.</span>
02827         <span class="comment">//</span>
02828 
02829         VacbArray = NextVacbArray;
02830         FileOffset &amp;= ((LONGLONG)1 &lt;&lt; Shift) - 1;
02831         Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02832 
02833     <span class="comment">//</span>
02834     <span class="comment">//  Loop until we hit the bottom level.</span>
02835     <span class="comment">//</span>
02836 
02837     } <span class="keywordflow">while</span> (Level != 0);
02838 
02839     <span class="keywordflow">if</span> (Vacb &lt; <a class="code" href="../../d5/d5/cc_8h.html#a67">VACB_SPECIAL_FIRST_VALID</a>) {
02840 
02841         <span class="comment">//</span>
02842         <span class="comment">//  Now calculate the index for the bottom level and store the caller's Vacb pointer.</span>
02843         <span class="comment">//</span>
02844 
02845         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(FileOffset &gt;&gt; Shift);
02846         VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = Vacb;
02847 
02848     <span class="comment">//</span>
02849     <span class="comment">//  Handle the special actions.</span>
02850     <span class="comment">//</span>
02851 
02852     } <span class="keywordflow">else</span> {
02853 
02854         Special = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02855 
02856         <span class="comment">//</span>
02857         <span class="comment">//  Induce the dereference.</span>
02858         <span class="comment">//</span>
02859 
02860         <span class="keywordflow">if</span> (Vacb == <a class="code" href="../../d5/d5/cc_8h.html#a66">VACB_SPECIAL_DEREFERENCE</a>) {
02861 
02862             Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02863         }
02864     }
02865 
02866     <span class="comment">//</span>
02867     <span class="comment">//  If he is storing a nonzero pointer, just reference the level.</span>
02868     <span class="comment">//</span>
02869 
02870     <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02871 
02872         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !(Special &amp;&amp; Level != 0) );
02873 
02874         <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, VacbArray, Level, 1, Special );
02875 
02876     <span class="comment">//</span>
02877     <span class="comment">//  Otherwise we are storing a NULL pointer, and we have to see if we can collapse</span>
02878     <span class="comment">//  the tree by deallocating empty blocks of pointers.</span>
02879     <span class="comment">//</span>
02880 
02881     } <span class="keywordflow">else</span> {
02882 
02883         <span class="comment">//</span>
02884         <span class="comment">//  Loop until doing all possible collapse except for the top level.</span>
02885         <span class="comment">//</span>
02886 
02887         <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02888 
02889             <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, VacbArray, Level, -1, Special );
02890 
02891             <span class="comment">//</span>
02892             <span class="comment">//  If this was a special dereference, then recognize that this was</span>
02893             <span class="comment">//  the only one.  The rest, as we tear up the tree, are regular</span>
02894             <span class="comment">//  (calculable) references.</span>
02895             <span class="comment">//</span>
02896 
02897             Special = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02898 
02899             <span class="comment">//</span>
02900             <span class="comment">//  Now, if we have an empty block (other than the top one), then we should free the</span>
02901             <span class="comment">//  block and keep looping.</span>
02902             <span class="comment">//</span>
02903 
02904             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a209">IsVacbLevelReferenced</a>( SharedCacheMap, VacbArray, Level ) &amp;&amp; (SavedLevels != 0)) {
02905 
02906                 SavedLevels -= 1;
02907 
02908                 <span class="comment">//</span>
02909                 <span class="comment">//  First see if we have Bcb Listheads to delete and if so, we have to unlink</span>
02910                 <span class="comment">//  the whole block first.</span>
02911                 <span class="comment">//</span>
02912 
02913                 AllocatingBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02914                 <span class="keywordflow">if</span> ((Level++ == 0) &amp;&amp; <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, MODIFIED_WRITE_DISABLED)) {
02915 
02916                     AllocatingBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02917                     PredecessorListHead = ((PLIST_ENTRY)((PCHAR)VacbArray + <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>))-&gt;Flink;
02918                     SuccessorListHead = ((PLIST_ENTRY)((PCHAR)VacbArray + (<a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> * 2) - <span class="keyword">sizeof</span>(LIST_ENTRY)))-&gt;Blink;
02919                     PredecessorListHead-&gt;Blink = SuccessorListHead;
02920                     SuccessorListHead-&gt;Flink = PredecessorListHead;
02921                 }
02922 
02923                 <span class="comment">//</span>
02924                 <span class="comment">//  Free the unused block and then pick up the saved parent pointer array and</span>
02925                 <span class="comment">//  index and erase the pointer to this block.</span>
02926                 <span class="comment">//</span>
02927 
02928                 <a class="code" href="../../d5/d5/cc_8h.html#a207">CcDeallocateVacbLevel</a>( VacbArray, AllocatingBcbListHeads );
02929                 <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = SavedIndexes[SavedLevels];
02930                 VacbArray = SavedVacbArrays[SavedLevels];
02931                 VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02932 
02933             <span class="comment">//</span>
02934             <span class="comment">//  No more collapsing if we hit a block that still has pointers, or we hit the root.</span>
02935             <span class="comment">//</span>
02936 
02937             } <span class="keywordflow">else</span> {
02938                 <span class="keywordflow">break</span>;
02939             }
02940         }
02941     }
02942 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="vacbsup.c::CcUnmapVacb" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcUnmapVacb           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Vacb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>UnmapBehind</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01156">1156</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00462">mm</a>, <a class="el" href="../../d2/d4/mapcache_8c-source.html#l00381">MmUnmapViewInSystemCache()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01059">ONLY_SEQUENTIAL_ONLY_SEEN</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00401">CcGetVacbMiss()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01784">CcUnmapVacbArray()</a>.
<p>
<pre class="fragment"><div>01164                    :
01165 
01166     This routine may be called to unmap a previously mapped Vacb, and
01167     clear its BaseAddress field.
01168 
01169 Arguments:
01170 
01171     Vacb - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Vacb which was returned from <a class="code" href="../../d5/d5/cc_8h.html#a194">CcGetVirtualAddress</a>.
01172 
01173     UnmapBehind - If <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a result of our unmap behind logic (the
01174         only <span class="keywordflow">case</span> in which we pay attention to sequential hints)
01175 
01176 Return Value:
01177 
01178     None.
01179 
01180 --*/
01181 
01182 {
01183     <span class="comment">//</span>
01184     <span class="comment">//  Make sure it is mapped.</span>
01185     <span class="comment">//</span>
01186 
01187     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SharedCacheMap != NULL);
01188     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Vacb-&gt;BaseAddress != NULL);
01189 
01190     <span class="comment">//</span>
01191     <span class="comment">//  Call MM to unmap it.</span>
01192     <span class="comment">//</span>
01193 
01194     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"MmUnmapViewInSystemCache:\n"</span>, 0 );
01195     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, mm, <span class="stringliteral">"    BaseAddress = %08lx\n"</span>, Vacb-&gt;BaseAddress );
01196 
01197     <a class="code" href="../../d1/d5/mapcache_8c.html#a11">MmUnmapViewInSystemCache</a>( Vacb-&gt;BaseAddress,
01198                               SharedCacheMap-&gt;Section,
01199                               UnmapBehind &amp;&amp;
01200                               <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, ONLY_SEQUENTIAL_ONLY_SEEN) );
01201 
01202     Vacb-&gt;BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01203 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="vacbsup.c::CcUnmapVacbArray" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN FASTCALL CcUnmapVacbArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER FileOffset&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>UnmapBehind</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01784">1784</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00076">CcAcquireVacbLock</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02044">CcDrainVacbLevelZone()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00163">CcMoveVacbToReuseHead</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01156">CcUnmapVacb()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00078">GetVacb</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d2/d5/struct__VACB.html#o4">_VACB::Overlay</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00086">SetVacb()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00589">_VACB::SharedCacheMap</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00401">CcGetVacbMiss()</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l02331">CcPurgeCacheSection()</a>, and <a class="el" href="../../d6/d7/fssup_8c-source.html#l02563">CcUnmapAndPurge()</a>.
<p>
<pre class="fragment"><div>01793                    :
01794 
01795     This routine must be called to <span class="keywordflow">do</span> any unmapping and associated
01796     cleanup <span class="keywordflow">for</span> a shared cache map, just before <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> deleted.
01797 
01798 Arguments:
01799 
01800     SharedCacheMap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> shared cache map
01801                      which <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> about to be deleted.
01802 
01803     FileOffset - If supplied, <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> unmap <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified offset and length
01804 
01805     Length - Completes range to unmap <span class="keywordflow">if</span> FileOffset specified.  If FileOffset
01806              <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified, Length of 0 means unmap to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> section.
01807 
01808     UnmapBehind - If <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a result of our unmap behind logic
01809 
01810 Return Value:
01811 
01812     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> -- <span class="keywordflow">if</span> an <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unmap was not done due to an active vacb
01813     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> -- <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unmap was done
01814 
01815 --*/
01816 
01817 {
01818     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
01819     KIRQL OldIrql;
01820     LARGE_INTEGER StartingFileOffset = {0,0};
01821     LARGE_INTEGER EndingFileOffset = SharedCacheMap-&gt;SectionSize;
01822 
01823     <span class="comment">//</span>
01824     <span class="comment">//  We could be just cleaning up for error recovery.</span>
01825     <span class="comment">//</span>
01826 
01827     <span class="keywordflow">if</span> (SharedCacheMap-&gt;Vacbs == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01828         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01829     }
01830 
01831     <span class="comment">//</span>
01832     <span class="comment">//  See if a range was specified. Align it to the VACB boundaries so it</span>
01833     <span class="comment">//  works in the loop below  </span>
01834     <span class="comment">//</span>
01835 
01836     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(FileOffset)) {
01837         StartingFileOffset.QuadPart = ((FileOffset-&gt;QuadPart) &amp; (~((LONGLONG)<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
01838         <span class="keywordflow">if</span> (Length != 0) {
01839 
01840             EndingFileOffset.QuadPart = FileOffset-&gt;QuadPart + Length;
01841                 
01842         }
01843     }
01844 
01845     <span class="comment">//</span>
01846     <span class="comment">//  Acquire the spin lock to</span>
01847     <span class="comment">//</span>
01848 
01849     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
01850 
01851     <span class="keywordflow">while</span> (StartingFileOffset.QuadPart &lt; EndingFileOffset.QuadPart) {
01852 
01853         <span class="comment">//</span>
01854         <span class="comment">//  Note that the caller with an explicit range may be off the</span>
01855         <span class="comment">//  end of the section (example CcPurgeCacheSection for cache</span>
01856         <span class="comment">//  coherency).  That is the reason for the first part of the</span>
01857         <span class="comment">//  test below.</span>
01858         <span class="comment">//</span>
01859         <span class="comment">//  Check the next cell once without the spin lock, it probably will</span>
01860         <span class="comment">//  not change, but we will handle it if it does not.</span>
01861         <span class="comment">//</span>
01862 
01863         <span class="keywordflow">if</span> ((StartingFileOffset.QuadPart &lt; SharedCacheMap-&gt;SectionSize.QuadPart) &amp;&amp;
01864             ((Vacb = <a class="code" href="../../d5/d3/vacbsup_8c.html#a1">GetVacb</a>( SharedCacheMap, StartingFileOffset )) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01865 
01866             <span class="comment">//</span>
01867             <span class="comment">//  Return here if we are unlucky and see an active</span>
01868             <span class="comment">//  Vacb.  It could be Purge calling, and the Lazy Writer</span>
01869             <span class="comment">//  may have done a CcGetVirtualAddressIfMapped!</span>
01870             <span class="comment">//</span>
01871 
01872             <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount != 0) {
01873 
01874                 <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01875                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01876             }
01877 
01878             <span class="comment">//</span>
01879             <span class="comment">//  Unlink it from the other SharedCacheMap, so the other</span>
01880             <span class="comment">//  guy will not try to use it when we free the spin lock.</span>
01881             <span class="comment">//</span>
01882 
01883             <a class="code" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a>( SharedCacheMap, StartingFileOffset, NULL );
01884             Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01885 
01886             <span class="comment">//</span>
01887             <span class="comment">//  Increment the open count so that no one else will</span>
01888             <span class="comment">//  try to unmap or reuse until we are done.</span>
01889             <span class="comment">//</span>
01890 
01891             Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount += 1;
01892 
01893             <span class="comment">//</span>
01894             <span class="comment">//  Release the spin lock.</span>
01895             <span class="comment">//</span>
01896 
01897             <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01898 
01899             <span class="comment">//</span>
01900             <span class="comment">//  Unmap and free it if we really got it above.</span>
01901             <span class="comment">//</span>
01902 
01903             <a class="code" href="../../d5/d3/vacbsup_8c.html#a6">CcUnmapVacb</a>( Vacb, SharedCacheMap, UnmapBehind );
01904 
01905             <span class="comment">//</span>
01906             <span class="comment">//  Reacquire the spin lock so that we can decrment the count.</span>
01907             <span class="comment">//</span>
01908 
01909             <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
01910             Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount -= 1;
01911 
01912             <span class="comment">//</span>
01913             <span class="comment">//  Place this VACB at the head of the LRU</span>
01914             <span class="comment">//</span>
01915 
01916             <a class="code" href="../../d5/d3/vacbsup_8c.html#a2">CcMoveVacbToReuseHead</a>( Vacb );
01917         }
01918 
01919         StartingFileOffset.QuadPart = StartingFileOffset.QuadPart + <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a>;
01920     }
01921 
01922     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01923 
01924     <a class="code" href="../../d5/d5/cc_8h.html#a205">CcDrainVacbLevelZone</a>();
01925 
01926     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01927 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="vacbsup.c::CcWaitOnActiveCount" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcWaitOnActiveCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>SharedCacheMap</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01062">1062</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00076">CcAcquireVacbLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00079">CcReleaseVacbLock</a>, <a class="el" href="../../d9/d8/client_2ntstubs_8c-source.html#l00086">Event()</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>, and <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>.
<p>
Referenced by <a class="el" href="../../d6/d7/fssup_8c-source.html#l01517">CcDeleteSharedCacheMap()</a>, and <a class="el" href="../../d6/d7/fssup_8c-source.html#l02331">CcPurgeCacheSection()</a>.
<p>
<pre class="fragment"><div>01068                    :
01069 
01070     This routine may be called to wait <span class="keywordflow">for</span> outstanding mappings <span class="keywordflow">for</span>
01071     a given SharedCacheMap to go inactive.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> intended to be called
01072     from <a class="code" href="../../d5/d8/fssup_8c.html#a10">CcUninitializeCacheMap</a>, which <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> systems
01073     during cleanup processing.  In that <span class="keywordflow">case</span> <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> has to
01074     wait <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user closed a handle without waiting <span class="keywordflow">for</span> all I/Os on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01075     handle to complete.
01076 
01077     This routine returns each time <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> active count <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> decremented.  The
01078     caller must recheck his wait conditions on <span class="keywordflow">return</span>, either waiting <span class="keywordflow">for</span>
01079     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> ActiveCount to go to 0, or <span class="keywordflow">for</span> specific views to go inactive
01080     (<a class="code" href="../../d5/d8/fssup_8c.html#a13">CcPurgeCacheSection</a> <span class="keywordflow">case</span>).
01081 
01082 Arguments:
01083 
01084     SharedCacheMap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Shared Cache Map on whose VacbActiveCount
01085                      we wish to wait.
01086 
01087 Return Value:
01088 
01089     None.
01090 
01091 --*/
01092 
01093 {
01094     KIRQL OldIrql;
01095     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
01096 
01097     <span class="comment">//</span>
01098     <span class="comment">//  In the unusual case that we get a cleanup while I/O is still going</span>
01099     <span class="comment">//  on, we can wait here.  The caller must test the count for nonzero</span>
01100     <span class="comment">//  before calling this routine.</span>
01101     <span class="comment">//</span>
01102     <span class="comment">//  Since we are being called from cleanup, we cannot afford to</span>
01103     <span class="comment">//  fail here.</span>
01104     <span class="comment">//</span>
01105 
01106     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
01107 
01108     <span class="comment">//</span>
01109     <span class="comment">//  It is possible that the count went to zero before we acquired the</span>
01110     <span class="comment">//  spinlock, so we must handle two cases here.</span>
01111     <span class="comment">//</span>
01112 
01113     <span class="keywordflow">if</span> (SharedCacheMap-&gt;VacbActiveCount != 0) {
01114 
01115         <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> = SharedCacheMap-&gt;WaitOnActiveCount) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01116 
01117             <span class="comment">//</span>
01118             <span class="comment">//  If the local event is not being used then we take it.</span>
01119             <span class="comment">//</span>
01120 
01121             <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> = InterlockedExchangePointer( &amp;SharedCacheMap-&gt;LocalEvent, NULL );
01122 
01123             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01124 
01125                 <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolMustSucceed,
01126                                                         <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>),
01127                                                         'vEcC' );
01128             }
01129         }
01130 
01131         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( Event,
01132                            NotificationEvent,
01133                            FALSE );
01134 
01135         SharedCacheMap-&gt;WaitOnActiveCount = <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
01136 
01137         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01138 
01139         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( Event,
01140                                Executive,
01141                                KernelMode,
01142                                FALSE,
01143                                (PLARGE_INTEGER)NULL);
01144     } <span class="keywordflow">else</span> {
01145 
01146         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01147     }
01148 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="vacbsup.c::ReferenceVacbLevel" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> _inline VOID ReferenceVacbLevel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>VacbArray</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Level</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Amount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Special</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00125">125</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02439">CcCalculateVacbLevelLockCount()</a>, <a class="el" href="../../d5/d5/cc_8h.html#a96">PVACB_LEVEL_REFERENCE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00342">_VACB_LEVEL_REFERENCE::Reference</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00343">_VACB_LEVEL_REFERENCE::SpecialReference</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l02094">VacbLevelReference()</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02335">CcAdjustVacbLevelLockCount()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01377">CcExtendVacbArray()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02621">CcSetVacbLargeOffset()</a>.
<p>
<pre class="fragment"><div>00132 {
00133     <a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">PVACB_LEVEL_REFERENCE</a> VacbReference = <a class="code" href="../../d5/d5/cc_8h.html#a208">VacbLevelReference</a>( SharedCacheMap, VacbArray, Level );
00134 
00135     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Amount &gt; 0 ||
00136             (!Special &amp;&amp; VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a> &gt;= (0 - Amount)) ||
00137             ( Special &amp;&amp; VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o1">SpecialReference</a> &gt;= (0 - Amount)));
00138 
00139     <span class="keywordflow">if</span> (Special) {
00140         VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o1">SpecialReference</a> += Amount;
00141     } <span class="keywordflow">else</span> {
00142         VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a> += Amount;
00143     }
00144 
00145 <span class="preprocessor">#ifdef VACB_DBG</span>
00146 <span class="preprocessor"></span>    <span class="comment">//</span>
00147     <span class="comment">//  For debugging purposes, we can assert that the regular reference count</span>
00148     <span class="comment">//  corresponds to the population of the level.</span>
00149     <span class="comment">//</span>
00150 
00151     {
00152         LONG Current = VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a>;
00153         <a class="code" href="../../d5/d3/vacbsup_8c.html#a8">CcCalculateVacbLevelLockCount</a>( SharedCacheMap, VacbArray, Level );
00154         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Current == VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a> );
00155     }
00156 <span class="preprocessor">#endif // VACB_DBG</span>
00157 <span class="preprocessor"></span>}
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="vacbsup.c::SetVacb" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> _inline VOID SetVacb           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>SharedCacheMap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN LARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d2/d5/struct__VACB.html">PVACB</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Vacb</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00086">86</a> of file <a class="el" href="../../d6/d2/vacbsup_8c-source.html">vacbsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02534">CcGetVacbLargeOffset()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l02621">CcSetVacbLargeOffset()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02110">IsVacbLevelReferenced()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00033">Offset</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00327">VACB_SIZE_OF_FIRST_LEVEL</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00631">VACB_SPECIAL_FIRST_VALID</a>.
<p>
Referenced by <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01007">CcDereferenceFileOffset()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00401">CcGetVacbMiss()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00947">CcReferenceFileOffset()</a>, and <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l01784">CcUnmapVacbArray()</a>.
<p>
<pre class="fragment"><div>00091 {
00092     <span class="keywordflow">if</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
00093         <a class="code" href="../../d5/d3/vacbsup_8c.html#a10">CcSetVacbLargeOffset</a>(SharedCacheMap, <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart, Vacb);
00094 <span class="preprocessor">#ifdef VACB_DBG</span>
00095 <span class="preprocessor"></span>        <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Vacb &gt;= VACB_SPECIAL_FIRST_VALID || <a class="code" href="../../d5/d3/vacbsup_8c.html#a9">CcGetVacbLargeOffset</a>(SharedCacheMap, <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart) == Vacb);
00096 <span class="preprocessor">#endif // VACB_DBG</span>
00097 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Vacb &lt; <a class="code" href="../../d5/d5/cc_8h.html#a67">VACB_SPECIAL_FIRST_VALID</a>) {
00098         SharedCacheMap-&gt;Vacbs[<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.LowPart &gt;&gt; <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a>] = Vacb;
00099     }
00100 <span class="preprocessor">#ifdef VACB_DBG</span>
00101 <span class="preprocessor"></span>    <span class="comment">//</span>
00102     <span class="comment">//  Note, we need a new field if we turn this check on again - ReservedForAlignment</span>
00103     <span class="comment">//  has been stolen for other purposes.</span>
00104     <span class="comment">//</span>
00105 
00106     <span class="keywordflow">if</span> (Vacb &lt; <a class="code" href="../../d5/d5/cc_8h.html#a67">VACB_SPECIAL_FIRST_VALID</a>) {
00107         <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00108             SharedCacheMap-&gt;ReservedForAlignment++;
00109         } <span class="keywordflow">else</span> {
00110             SharedCacheMap-&gt;ReservedForAlignment--;
00111         }
00112     }
00113     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((SharedCacheMap-&gt;SectionSize.QuadPart &lt;= VACB_SIZE_OF_FIRST_LEVEL) ||
00114            (SharedCacheMap-&gt;ReservedForAlignment == 0) ||
00115            <a class="code" href="../../d5/d5/cc_8h.html#a209">IsVacbLevelReferenced</a>( SharedCacheMap, SharedCacheMap-&gt;Vacbs, 1 ));
00116 <span class="preprocessor">#endif // VACB_DBG</span>
00117 <span class="preprocessor"></span>}
</div></pre>    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:46:06 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
