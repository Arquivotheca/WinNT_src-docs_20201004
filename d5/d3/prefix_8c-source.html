<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: prefix.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>prefix.c</h1><a href="../../d4/d4/prefix_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    Prefix.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the prefix table utility.  The two structures</span>
00012 <span class="comment">    used in a prefix table are the PREFIX_TABLE and PREFIX_TABLE_ENTRY.</span>
00013 <span class="comment">    Each table has one prefix table and multiple prefix table entries</span>
00014 <span class="comment">    corresponding to each prefix stored in the table.</span>
00015 <span class="comment"></span>
00016 <span class="comment">    A prefix table is a list of prefix trees, where each tree contains</span>
00017 <span class="comment">    the prefixes corresponding to a particular name length (i.e., all</span>
00018 <span class="comment">    prefixes of length 1 are stored in one tree, prefixes of length 2</span>
00019 <span class="comment">    are stored in another tree, and so forth).  A prefixes name length</span>
00020 <span class="comment">    is the number of separate names that appear in the string, and not</span>
00021 <span class="comment">    the number of characters in the string (e.g., Length("\alpha\beta") = 2).</span>
00022 <span class="comment"></span>
00023 <span class="comment">    The elements of each tree are ordered lexicalgraphically (case blind)</span>
00024 <span class="comment">    using a splay tree data structure.  If two or more prefixes are identical</span>
00025 <span class="comment">    except for case then one of the corresponding table entries is actually</span>
00026 <span class="comment">    in the tree, while the other entries are in a circular linked list joined</span>
00027 <span class="comment">    with the tree member.</span>
00028 <span class="comment"></span>
00029 <span class="comment">Author:</span>
00030 <span class="comment"></span>
00031 <span class="comment">    Gary Kimura     [GaryKi]    3-Aug-1989</span>
00032 <span class="comment"></span>
00033 <span class="comment">Environment:</span>
00034 <span class="comment"></span>
00035 <span class="comment">    Pure utility routine</span>
00036 <span class="comment"></span>
00037 <span class="comment">Revision History:</span>
00038 <span class="comment"></span>
00039 <span class="comment">    08-Mar-1993    JulieB    Moved Upcase Macro to ntrtlp.h.</span>
00040 <span class="comment"></span>
00041 <span class="comment">--*/</span>
00042 
00043 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00044 
00045 <span class="comment">//</span>
00046 <span class="comment">//  Local procedures and types used only in this package</span>
00047 <span class="comment">//</span>
00048 
<a name="l00049"></a><a class="code" href="../../d4/d4/prefix_8c.html#a25">00049</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25">_COMPARISON</a> {
00050     <a class="code" href="../../d4/d4/prefix_8c.html#a25a8">IsLessThan</a>,
00051     <a class="code" href="../../d4/d4/prefix_8c.html#a25a9">IsPrefix</a>,
00052     <a class="code" href="../../d4/d4/prefix_8c.html#a25a10">IsEqual</a>,
00053     <a class="code" href="../../d4/d4/prefix_8c.html#a25a11">IsGreaterThan</a>
00054 } <a class="code" href="../../d4/d4/prefix_8c.html#a7">COMPARISON</a>;
00055 
00056 CLONG
00057 <a class="code" href="../../d4/d4/prefix_8c.html#a12">ComputeNameLength</a>(
00058     IN PSTRING Name
00059     );
00060 
00061 <a class="code" href="../../d4/d4/prefix_8c.html#a7">COMPARISON</a>
00062 <a class="code" href="../../d4/d4/prefix_8c.html#a13">CompareNamesCaseSensitive</a> (
00063     IN PSTRING Prefix,
00064     IN PSTRING Name
00065     );
00066 
00067 CLONG
00068 <a class="code" href="../../d4/d4/prefix_8c.html#a14">ComputeUnicodeNameLength</a>(
00069     IN PUNICODE_STRING Name
00070     );
00071 
00072 <a class="code" href="../../d4/d4/prefix_8c.html#a7">COMPARISON</a>
00073 <a class="code" href="../../d4/d4/prefix_8c.html#a15">CompareUnicodeStrings</a> (
00074     IN PUNICODE_STRING Prefix,
00075     IN PUNICODE_STRING Name,
00076     IN ULONG CaseInsensitiveIndex
00077     );
00078 
00079 <span class="preprocessor">#if defined(ALLOC_PRAGMA) &amp;&amp; defined(NTOS_KERNEL_RUNTIME)</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,ComputeNameLength)</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CompareNamesCaseSensitive)</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,PfxInitialize)</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,PfxInsertPrefix)</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,PfxRemovePrefix)</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,PfxFindPrefix)</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,ComputeUnicodeNameLength)</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CompareUnicodeStrings)</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlInitializeUnicodePrefix)</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlInsertUnicodePrefix)</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlRemoveUnicodePrefix)</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlFindUnicodePrefix)</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlNextUnicodePrefix)</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00094 <span class="preprocessor"></span>
00095 
00096 <span class="comment">//</span>
00097 <span class="comment">//  The node type codes for the prefix data structures</span>
00098 <span class="comment">//</span>
00099 
<a name="l00100"></a><a class="code" href="../../d4/d4/prefix_8c.html#a0">00100</a> <span class="preprocessor">#define RTL_NTC_PREFIX_TABLE             ((CSHORT)0x0200)</span>
<a name="l00101"></a><a class="code" href="../../d4/d4/prefix_8c.html#a1">00101</a> <span class="preprocessor"></span><span class="preprocessor">#define RTL_NTC_ROOT                     ((CSHORT)0x0201)</span>
<a name="l00102"></a><a class="code" href="../../d4/d4/prefix_8c.html#a2">00102</a> <span class="preprocessor"></span><span class="preprocessor">#define RTL_NTC_INTERNAL                 ((CSHORT)0x0202)</span>
00103 <span class="preprocessor"></span>
00104 
00105 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00106"></a><a class="code" href="../../d4/d4/prefix_8c.html#a16">00106</a> <a class="code" href="../../d4/d4/prefix_8c.html#a16">PfxInitialize</a> (
00107     IN PPREFIX_TABLE PrefixTable
00108     )
00109 
00110 <span class="comment">/*++</span>
00111 <span class="comment"></span>
00112 <span class="comment">Routine Description:</span>
00113 <span class="comment"></span>
00114 <span class="comment">    This routine initializes a prefix table record to the empty state.</span>
00115 <span class="comment"></span>
00116 <span class="comment">Arguments:</span>
00117 <span class="comment"></span>
00118 <span class="comment">    PrefixTable - Supplies the prefix table being initialized</span>
00119 <span class="comment"></span>
00120 <span class="comment">Return Value:</span>
00121 <span class="comment"></span>
00122 <span class="comment">    None.</span>
00123 <span class="comment"></span>
00124 <span class="comment">--*/</span>
00125 
00126 {
00127     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00128 
00129     <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a0">RTL_NTC_PREFIX_TABLE</a>;
00130 
00131     <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;NameLength = 0;
00132 
00133     <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;NextPrefixTree = (PPREFIX_TABLE_ENTRY)<a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>;
00134 
00135     <span class="comment">//</span>
00136     <span class="comment">//  return to our caller</span>
00137     <span class="comment">//</span>
00138 
00139     <span class="keywordflow">return</span>;
00140 }
00141 
00142 
00143 BOOLEAN
<a name="l00144"></a><a class="code" href="../../d4/d4/prefix_8c.html#a17">00144</a> <a class="code" href="../../d4/d4/prefix_8c.html#a17">PfxInsertPrefix</a> (
00145     IN PPREFIX_TABLE PrefixTable,
00146     IN PSTRING Prefix,
00147     IN PPREFIX_TABLE_ENTRY PrefixTableEntry
00148     )
00149 
00150 <span class="comment">/*++</span>
00151 <span class="comment"></span>
00152 <span class="comment">Routine Description:</span>
00153 <span class="comment"></span>
00154 <span class="comment">    This routine inserts a new prefix into the specified prefix table</span>
00155 <span class="comment"></span>
00156 <span class="comment">Arguments:</span>
00157 <span class="comment"></span>
00158 <span class="comment">    PrefixTable - Supplies the target prefix table</span>
00159 <span class="comment"></span>
00160 <span class="comment">    Prefix - Supplies the string to be inserted in the prefix table</span>
00161 <span class="comment"></span>
00162 <span class="comment">    PrefixTableEntry - Supplies the entry to use to insert the prefix</span>
00163 <span class="comment"></span>
00164 <span class="comment">Return Value:</span>
00165 <span class="comment"></span>
00166 <span class="comment">    BOOLEAN - TRUE if the Prefix is not already in the table, and FALSE</span>
00167 <span class="comment">        otherwise</span>
00168 <span class="comment"></span>
00169 <span class="comment">--*/</span>
00170 
00171 {
00172     ULONG PrefixNameLength;
00173 
00174     PPREFIX_TABLE_ENTRY PreviousTree;
00175     PPREFIX_TABLE_ENTRY CurrentTree;
00176     PPREFIX_TABLE_ENTRY NextTree;
00177 
00178     PPREFIX_TABLE_ENTRY Node;
00179 
00180     <a class="code" href="../../d4/d4/prefix_8c.html#a7">COMPARISON</a> Comparison;
00181 
00182     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00183 
00184     <span class="comment">//</span>
00185     <span class="comment">//  Determine the name length of the input string</span>
00186     <span class="comment">//</span>
00187 
00188     PrefixNameLength = <a class="code" href="../../d4/d4/prefix_8c.html#a12">ComputeNameLength</a>(Prefix);
00189 
00190     <span class="comment">//</span>
00191     <span class="comment">//  Setup parts of the prefix table entry that we will always need</span>
00192     <span class="comment">//</span>
00193 
00194     PrefixTableEntry-&gt;NameLength = (CSHORT)PrefixNameLength;
00195     PrefixTableEntry-&gt;Prefix = Prefix;
00196 
00197     RtlInitializeSplayLinks(&amp;PrefixTableEntry-&gt;Links);
00198 
00199     <span class="comment">//</span>
00200     <span class="comment">//  find the corresponding tree, or find where the tree should go</span>
00201     <span class="comment">//</span>
00202 
00203     PreviousTree = (PPREFIX_TABLE_ENTRY)<a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>;
00204     CurrentTree = PreviousTree-&gt;NextPrefixTree;
00205 
00206     <span class="keywordflow">while</span> (CurrentTree-&gt;NameLength &gt; (CSHORT)PrefixNameLength) {
00207 
00208         PreviousTree = CurrentTree;
00209         CurrentTree = CurrentTree-&gt;NextPrefixTree;
00210 
00211     }
00212 
00213     <span class="comment">//</span>
00214     <span class="comment">//  If the name length of the current tree is not equal to the</span>
00215     <span class="comment">//  prefix name length then the tree does not exist and we need</span>
00216     <span class="comment">//  to make a new tree node.</span>
00217     <span class="comment">//</span>
00218 
00219     <span class="keywordflow">if</span> (CurrentTree-&gt;NameLength != (CSHORT)PrefixNameLength) {
00220 
00221         <span class="comment">//</span>
00222         <span class="comment">//  Insert the new prefix entry to the list between</span>
00223         <span class="comment">//  previous and current tree</span>
00224         <span class="comment">//</span>
00225 
00226         PreviousTree-&gt;NextPrefixTree = PrefixTableEntry;
00227         PrefixTableEntry-&gt;NextPrefixTree = CurrentTree;
00228 
00229         <span class="comment">//</span>
00230         <span class="comment">//  And set the node type code</span>
00231         <span class="comment">//</span>
00232 
00233         PrefixTableEntry-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a1">RTL_NTC_ROOT</a>;
00234 
00235         <span class="comment">//</span>
00236         <span class="comment">//  And tell our caller everything worked fine</span>
00237         <span class="comment">//</span>
00238 
00239         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00240 
00241     }
00242 
00243     <span class="comment">//</span>
00244     <span class="comment">//  The tree does exist so now search the tree for our</span>
00245     <span class="comment">//  position in it.  We only exit the loop if we've inserted</span>
00246     <span class="comment">//  a new node, and node is left is left pointing to the</span>
00247     <span class="comment">//  tree position</span>
00248     <span class="comment">//</span>
00249 
00250     Node = CurrentTree;
00251 
00252     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00253 
00254         <span class="comment">//</span>
00255         <span class="comment">//  Compare the prefix in the tree with the prefix we want</span>
00256         <span class="comment">//  to insert</span>
00257         <span class="comment">//</span>
00258 
00259         Comparison = <a class="code" href="../../d4/d4/prefix_8c.html#a13">CompareNamesCaseSensitive</a>(Node-&gt;Prefix, Prefix);
00260 
00261         <span class="comment">//</span>
00262         <span class="comment">//  If we do match case sensitive then we cannot add</span>
00263         <span class="comment">//  this prefix so we return false.  Note this is the</span>
00264         <span class="comment">//  only condition where we return false</span>
00265         <span class="comment">//</span>
00266 
00267         <span class="keywordflow">if</span> (Comparison == <a class="code" href="../../d4/d4/prefix_8c.html#a25a10">IsEqual</a>) {
00268 
00269             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00270         }
00271 
00272         <span class="comment">//</span>
00273         <span class="comment">//  If the tree prefix is greater than the new prefix then</span>
00274         <span class="comment">//  we go down the left subtree</span>
00275         <span class="comment">//</span>
00276 
00277         <span class="keywordflow">if</span> (Comparison == <a class="code" href="../../d4/d4/prefix_8c.html#a25a11">IsGreaterThan</a>) {
00278 
00279             <span class="comment">//</span>
00280             <span class="comment">//  We want to go down the left subtree, first check to see</span>
00281             <span class="comment">//  if we have a left subtree</span>
00282             <span class="comment">//</span>
00283 
00284             <span class="keywordflow">if</span> (RtlLeftChild(&amp;Node-&gt;Links) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00285 
00286                 <span class="comment">//</span>
00287                 <span class="comment">//  there isn't a left child so we insert ourselves as the</span>
00288                 <span class="comment">//  new left child</span>
00289                 <span class="comment">//</span>
00290 
00291                 PrefixTableEntry-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a2">RTL_NTC_INTERNAL</a>;
00292                 PrefixTableEntry-&gt;NextPrefixTree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00293 
00294                 RtlInsertAsLeftChild(&amp;Node-&gt;Links, &amp;PrefixTableEntry-&gt;Links);
00295 
00296                 <span class="comment">//</span>
00297                 <span class="comment">//  and exit the while loop</span>
00298                 <span class="comment">//</span>
00299 
00300                 <span class="keywordflow">break</span>;
00301 
00302             } <span class="keywordflow">else</span> {
00303 
00304                 <span class="comment">//</span>
00305                 <span class="comment">//  there is a left child so simply go down that path, and</span>
00306                 <span class="comment">//  go back to the top of the loop</span>
00307                 <span class="comment">//</span>
00308 
00309                 Node = CONTAINING_RECORD( RtlLeftChild(&amp;Node-&gt;Links),
00310                                           PREFIX_TABLE_ENTRY,
00311                                           Links );
00312 
00313             }
00314 
00315         } <span class="keywordflow">else</span> {
00316 
00317             <span class="comment">//</span>
00318             <span class="comment">//  The tree prefix is either less than or a proper prefix</span>
00319             <span class="comment">//  of the new string.  We treat both cases a less than when</span>
00320             <span class="comment">//  we do insert.  So we want to go down the right subtree,</span>
00321             <span class="comment">//  first check to see if we have a right subtree</span>
00322             <span class="comment">//</span>
00323 
00324             <span class="keywordflow">if</span> (RtlRightChild(&amp;Node-&gt;Links) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00325 
00326                 <span class="comment">//</span>
00327                 <span class="comment">//  These isn't a right child so we insert ourselves as the</span>
00328                 <span class="comment">//  new right child</span>
00329                 <span class="comment">//</span>
00330 
00331                 PrefixTableEntry-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a2">RTL_NTC_INTERNAL</a>;
00332                 PrefixTableEntry-&gt;NextPrefixTree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00333 
00334                 RtlInsertAsRightChild(&amp;Node-&gt;Links, &amp;PrefixTableEntry-&gt;Links);
00335 
00336                 <span class="comment">//</span>
00337                 <span class="comment">//  and exit the while loop</span>
00338                 <span class="comment">//</span>
00339 
00340                 <span class="keywordflow">break</span>;
00341 
00342             } <span class="keywordflow">else</span> {
00343 
00344                 <span class="comment">//</span>
00345                 <span class="comment">//  there is a right child so simply go down that path, and</span>
00346                 <span class="comment">//  go back to the top of the loop</span>
00347                 <span class="comment">//</span>
00348 
00349                 Node = CONTAINING_RECORD( RtlRightChild(&amp;Node-&gt;Links),
00350                                           PREFIX_TABLE_ENTRY,
00351                                           Links );
00352             }
00353 
00354         }
00355 
00356     }
00357 
00358     <span class="comment">//</span>
00359     <span class="comment">//  Now that we've inserted the new node we can splay the tree.</span>
00360     <span class="comment">//  To do this we need to remember how we find this tree in the root</span>
00361     <span class="comment">//  tree list, set the root to be an internal, splay, the tree, and</span>
00362     <span class="comment">//  then setup the new root node.  Note: we cannot splay the prefix table</span>
00363     <span class="comment">//  entry because it might be a case match node so we only splay</span>
00364     <span class="comment">//  the Node variable, which for case match insertions is the</span>
00365     <span class="comment">//  internal node for the case match and for non-case match insertions</span>
00366     <span class="comment">//  the Node variable is the parent node.</span>
00367     <span class="comment">//</span>
00368 
00369     <span class="comment">//</span>
00370     <span class="comment">//  Save a pointer to the next tree, we already have the previous tree</span>
00371     <span class="comment">//</span>
00372 
00373     NextTree = CurrentTree-&gt;NextPrefixTree;
00374 
00375     <span class="comment">//</span>
00376     <span class="comment">//  Reset the current root to be an internal node</span>
00377     <span class="comment">//</span>
00378 
00379     CurrentTree-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a2">RTL_NTC_INTERNAL</a>;
00380     CurrentTree-&gt;NextPrefixTree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00381 
00382     <span class="comment">//</span>
00383     <span class="comment">//  Splay the tree and get the root</span>
00384     <span class="comment">//</span>
00385 
00386     Node = CONTAINING_RECORD(<a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(&amp;Node-&gt;Links), PREFIX_TABLE_ENTRY, Links);
00387 
00388     <span class="comment">//</span>
00389     <span class="comment">//  Set the new root's node type code and make it part of the</span>
00390     <span class="comment">//  root tree list</span>
00391     <span class="comment">//</span>
00392 
00393     Node-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a1">RTL_NTC_ROOT</a>;
00394     PreviousTree-&gt;NextPrefixTree = Node;
00395     Node-&gt;NextPrefixTree = NextTree;
00396 
00397     <span class="comment">//</span>
00398     <span class="comment">//  tell our caller everything worked fine</span>
00399     <span class="comment">//</span>
00400 
00401     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00402 }
00403 
00404 
00405 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00406"></a><a class="code" href="../../d4/d4/prefix_8c.html#a18">00406</a> <a class="code" href="../../d4/d4/prefix_8c.html#a18">PfxRemovePrefix</a> (
00407     IN PPREFIX_TABLE PrefixTable,
00408     IN PPREFIX_TABLE_ENTRY PrefixTableEntry
00409     )
00410 
00411 <span class="comment">/*++</span>
00412 <span class="comment"></span>
00413 <span class="comment">Routine Description:</span>
00414 <span class="comment"></span>
00415 <span class="comment">    This routine removes the indicated prefix table entry from</span>
00416 <span class="comment">    the prefix table</span>
00417 <span class="comment"></span>
00418 <span class="comment">Arguments:</span>
00419 <span class="comment"></span>
00420 <span class="comment">    PrefixTable - Supplies the prefix table affected</span>
00421 <span class="comment"></span>
00422 <span class="comment">    PrefixTableEntry - Supplies the prefix entry to remove</span>
00423 <span class="comment"></span>
00424 <span class="comment">Return Value:</span>
00425 <span class="comment"></span>
00426 <span class="comment">    None.</span>
00427 <span class="comment"></span>
00428 <span class="comment">--*/</span>
00429 
00430 {
00431     PRTL_SPLAY_LINKS Links;
00432 
00433     PPREFIX_TABLE_ENTRY Root;
00434     PPREFIX_TABLE_ENTRY NewRoot;
00435 
00436     PPREFIX_TABLE_ENTRY PreviousTree;
00437 
00438     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00439 
00440     <span class="comment">//</span>
00441     <span class="comment">//  case on the type of node that we are trying to delete</span>
00442     <span class="comment">//</span>
00443 
00444     <span class="keywordflow">switch</span> (PrefixTableEntry-&gt;NodeTypeCode) {
00445 
00446     <span class="keywordflow">case</span> <a class="code" href="../../d4/d4/prefix_8c.html#a2">RTL_NTC_INTERNAL</a>:
00447     <span class="keywordflow">case</span> <a class="code" href="../../d4/d4/prefix_8c.html#a1">RTL_NTC_ROOT</a>:
00448 
00449         <span class="comment">//</span>
00450         <span class="comment">//  The node is internal or root node so we need to delete it from</span>
00451         <span class="comment">//  the tree, but first find the root of the tree</span>
00452         <span class="comment">//</span>
00453 
00454         Links = &amp;PrefixTableEntry-&gt;Links;
00455 
00456         <span class="keywordflow">while</span> (!RtlIsRoot(Links)) {
00457 
00458             Links = RtlParent(Links);
00459         }
00460 
00461         Root = CONTAINING_RECORD( Links, PREFIX_TABLE_ENTRY, Links );
00462 
00463         <span class="comment">//</span>
00464         <span class="comment">//  Now delete the node</span>
00465         <span class="comment">//</span>
00466 
00467         Links = <a class="code" href="../../d3/d4/splay_8c.html#a4">RtlDelete</a>(&amp;PrefixTableEntry-&gt;Links);
00468 
00469         <span class="comment">//</span>
00470         <span class="comment">//  Now see if the tree is deleted</span>
00471         <span class="comment">//</span>
00472 
00473         <span class="keywordflow">if</span> (Links == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00474 
00475             <span class="comment">//</span>
00476             <span class="comment">//  The tree is now empty so remove this tree from</span>
00477             <span class="comment">//  the tree list, by first finding the previous tree that</span>
00478             <span class="comment">//  references us</span>
00479             <span class="comment">//</span>
00480 
00481             PreviousTree = Root-&gt;NextPrefixTree;
00482 
00483             <span class="keywordflow">while</span> ( PreviousTree-&gt;NextPrefixTree != Root ) {
00484 
00485                 PreviousTree = PreviousTree-&gt;NextPrefixTree;
00486             }
00487 
00488             <span class="comment">//</span>
00489             <span class="comment">//  We've located the previous tree so now just have it</span>
00490             <span class="comment">//  point around the deleted node</span>
00491             <span class="comment">//</span>
00492 
00493             PreviousTree-&gt;NextPrefixTree = Root-&gt;NextPrefixTree;
00494 
00495             <span class="comment">//</span>
00496             <span class="comment">//  and return the our caller</span>
00497             <span class="comment">//</span>
00498 
00499             <span class="keywordflow">return</span>;
00500         }
00501 
00502         <span class="comment">//</span>
00503         <span class="comment">//  The tree is not deleted but see if we changed roots</span>
00504         <span class="comment">//</span>
00505 
00506         <span class="keywordflow">if</span> (&amp;Root-&gt;Links != Links) {
00507 
00508             <span class="comment">//</span>
00509             <span class="comment">//  Get a pointer to the new root</span>
00510             <span class="comment">//</span>
00511 
00512             NewRoot = CONTAINING_RECORD(Links, PREFIX_TABLE_ENTRY, Links);
00513 
00514             <span class="comment">//</span>
00515             <span class="comment">//  We changed root so we better need to make the new</span>
00516             <span class="comment">//  root part of the prefix data structure, by</span>
00517             <span class="comment">//  first finding the previous tree that</span>
00518             <span class="comment">//  references us</span>
00519             <span class="comment">//</span>
00520 
00521             PreviousTree = Root-&gt;NextPrefixTree;
00522 
00523             <span class="keywordflow">while</span> ( PreviousTree-&gt;NextPrefixTree != Root ) {
00524 
00525                 PreviousTree = PreviousTree-&gt;NextPrefixTree;
00526             }
00527 
00528             <span class="comment">//</span>
00529             <span class="comment">//  Set the new root</span>
00530             <span class="comment">//</span>
00531 
00532             NewRoot-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a1">RTL_NTC_ROOT</a>;
00533 
00534             PreviousTree-&gt;NextPrefixTree = NewRoot;
00535             NewRoot-&gt;NextPrefixTree = Root-&gt;NextPrefixTree;
00536 
00537             <span class="comment">//</span>
00538             <span class="comment">//  Set the old root to be an internal node</span>
00539             <span class="comment">//</span>
00540 
00541             Root-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a2">RTL_NTC_INTERNAL</a>;
00542 
00543             Root-&gt;NextPrefixTree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00544 
00545             <span class="comment">//</span>
00546             <span class="comment">//  And return to our caller</span>
00547             <span class="comment">//</span>
00548 
00549             <span class="keywordflow">return</span>;
00550         }
00551 
00552         <span class="comment">//</span>
00553         <span class="comment">//  We didn't change roots so everything is fine and we can</span>
00554         <span class="comment">//  simply return to our caller</span>
00555         <span class="comment">//</span>
00556 
00557         <span class="keywordflow">return</span>;
00558 
00559     <span class="keywordflow">default</span>:
00560 
00561         <span class="comment">//</span>
00562         <span class="comment">//  If we get here then there was an error and the node type</span>
00563         <span class="comment">//  code is unknown</span>
00564         <span class="comment">//</span>
00565 
00566         <span class="keywordflow">return</span>;
00567     }
00568 }
00569 
00570 
00571 PPREFIX_TABLE_ENTRY
<a name="l00572"></a><a class="code" href="../../d4/d4/prefix_8c.html#a19">00572</a> <a class="code" href="../../d4/d4/prefix_8c.html#a19">PfxFindPrefix</a> (
00573     IN PPREFIX_TABLE PrefixTable,
00574     IN PSTRING FullName
00575     )
00576 
00577 <span class="comment">/*++</span>
00578 <span class="comment"></span>
00579 <span class="comment">Routine Description:</span>
00580 <span class="comment"></span>
00581 <span class="comment">    This routine finds if a full name has a prefix in a prefix table.</span>
00582 <span class="comment">    It returns a pointer to the largest proper prefix found if one exists.</span>
00583 <span class="comment"></span>
00584 <span class="comment">Arguments:</span>
00585 <span class="comment"></span>
00586 <span class="comment">    PrefixTable - Supplies the prefix table to search</span>
00587 <span class="comment"></span>
00588 <span class="comment">    FullString - Supplies the name to search for</span>
00589 <span class="comment"></span>
00590 <span class="comment">Return Value:</span>
00591 <span class="comment"></span>
00592 <span class="comment">    PPREFIX_TABLE_ENTRY - a pointer to the longest prefix found if one</span>
00593 <span class="comment">        exists, and NULL otherwise</span>
00594 <span class="comment"></span>
00595 <span class="comment">--*/</span>
00596 
00597 {
00598     CLONG NameLength;
00599 
00600     PPREFIX_TABLE_ENTRY PreviousTree;
00601     PPREFIX_TABLE_ENTRY CurrentTree;
00602     PPREFIX_TABLE_ENTRY NextTree;
00603 
00604     PRTL_SPLAY_LINKS Links;
00605 
00606     PPREFIX_TABLE_ENTRY Node;
00607 
00608     <a class="code" href="../../d4/d4/prefix_8c.html#a7">COMPARISON</a> Comparison;
00609 
00610     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00611 
00612     <span class="comment">//</span>
00613     <span class="comment">//  Determine the name length of the input string</span>
00614     <span class="comment">//</span>
00615 
00616     NameLength = <a class="code" href="../../d4/d4/prefix_8c.html#a12">ComputeNameLength</a>(FullName);
00617 
00618     <span class="comment">//</span>
00619     <span class="comment">//  Locate the first tree that can contain a prefix</span>
00620     <span class="comment">//</span>
00621 
00622     PreviousTree = (PPREFIX_TABLE_ENTRY)<a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>;
00623     CurrentTree = PreviousTree-&gt;NextPrefixTree;
00624 
00625     <span class="keywordflow">while</span> (CurrentTree-&gt;NameLength &gt; (CSHORT)NameLength) {
00626 
00627         PreviousTree = CurrentTree;
00628         CurrentTree = CurrentTree-&gt;NextPrefixTree;
00629     }
00630 
00631     <span class="comment">//</span>
00632     <span class="comment">//  Now search for a prefix until we find one or until we exhaust</span>
00633     <span class="comment">//  the prefix trees</span>
00634     <span class="comment">//</span>
00635 
00636     <span class="keywordflow">while</span> (CurrentTree-&gt;NameLength &gt; 0) {
00637 
00638         Links = &amp;CurrentTree-&gt;Links;
00639 
00640         <span class="keywordflow">while</span> (Links != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00641 
00642             Node = CONTAINING_RECORD(Links, PREFIX_TABLE_ENTRY, Links);
00643 
00644             <span class="comment">//</span>
00645             <span class="comment">//  Compare the prefix in the tree with the full name</span>
00646             <span class="comment">//</span>
00647 
00648             Comparison = <a class="code" href="../../d4/d4/prefix_8c.html#a13">CompareNamesCaseSensitive</a>(Node-&gt;Prefix, FullName);
00649 
00650             <span class="comment">//</span>
00651             <span class="comment">//  See if they don't match</span>
00652             <span class="comment">//</span>
00653 
00654             <span class="keywordflow">if</span> (Comparison == <a class="code" href="../../d4/d4/prefix_8c.html#a25a11">IsGreaterThan</a>) {
00655 
00656                 <span class="comment">//</span>
00657                 <span class="comment">//  The prefix is greater than the full name</span>
00658                 <span class="comment">//  so we go down the left child</span>
00659                 <span class="comment">//</span>
00660 
00661                 Links = RtlLeftChild(Links);
00662 
00663                 <span class="comment">//</span>
00664                 <span class="comment">//  And continue searching down this tree</span>
00665                 <span class="comment">//</span>
00666 
00667             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Comparison == <a class="code" href="../../d4/d4/prefix_8c.html#a25a8">IsLessThan</a>) {
00668 
00669                 <span class="comment">//</span>
00670                 <span class="comment">//  The prefix is less than the full name</span>
00671                 <span class="comment">//  so we go down the right child</span>
00672                 <span class="comment">//</span>
00673 
00674                 Links = RtlRightChild(Links);
00675 
00676                 <span class="comment">//</span>
00677                 <span class="comment">//  And continue searching down this tree</span>
00678                 <span class="comment">//</span>
00679 
00680             } <span class="keywordflow">else</span> {
00681 
00682                 <span class="comment">//</span>
00683                 <span class="comment">//  We found it.</span>
00684                 <span class="comment">//</span>
00685                 <span class="comment">//  Now that we've located the node we can splay the tree.</span>
00686                 <span class="comment">//  To do this we need to remember how we find this tree in the root</span>
00687                 <span class="comment">//  tree list, set the root to be an internal, splay, the tree, and</span>
00688                 <span class="comment">//  then setup the new root node.</span>
00689                 <span class="comment">//</span>
00690 
00691                 <span class="keywordflow">if</span> (Node-&gt;NodeTypeCode == <a class="code" href="../../d4/d4/prefix_8c.html#a2">RTL_NTC_INTERNAL</a>) {
00692 
00693                     <span class="comment">//DbgPrint("PrefixTable  = %08lx\n", PrefixTable);</span>
00694                     <span class="comment">//DbgPrint("Node         = %08lx\n", Node);</span>
00695                     <span class="comment">//DbgPrint("CurrentTree  = %08lx\n", CurrentTree);</span>
00696                     <span class="comment">//DbgPrint("PreviousTree = %08lx\n", PreviousTree);</span>
00697                     <span class="comment">//DbgBreakPoint();</span>
00698 
00699                     <span class="comment">//</span>
00700                     <span class="comment">//  Save a pointer to the next tree, we already have the previous tree</span>
00701                     <span class="comment">//</span>
00702 
00703                     NextTree = CurrentTree-&gt;NextPrefixTree;
00704 
00705                     <span class="comment">//</span>
00706                     <span class="comment">//  Reset the current root to be an internal node</span>
00707                     <span class="comment">//</span>
00708 
00709                     CurrentTree-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a2">RTL_NTC_INTERNAL</a>;
00710                     CurrentTree-&gt;NextPrefixTree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00711 
00712                     <span class="comment">//</span>
00713                     <span class="comment">//  Splay the tree and get the root</span>
00714                     <span class="comment">//</span>
00715 
00716                     Node = CONTAINING_RECORD(<a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(&amp;Node-&gt;Links), PREFIX_TABLE_ENTRY, Links);
00717 
00718                     <span class="comment">//</span>
00719                     <span class="comment">//  Set the new root's node type code and make it part of the</span>
00720                     <span class="comment">//  root tree list</span>
00721                     <span class="comment">//</span>
00722 
00723                     Node-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a1">RTL_NTC_ROOT</a>;
00724                     PreviousTree-&gt;NextPrefixTree = Node;
00725                     Node-&gt;NextPrefixTree = NextTree;
00726                 }
00727 
00728                 <span class="keywordflow">return</span> Node;
00729             }
00730         }
00731 
00732         <span class="comment">//</span>
00733         <span class="comment">//  This tree is done so now find the next tree</span>
00734         <span class="comment">//</span>
00735 
00736         PreviousTree = CurrentTree;
00737         CurrentTree = CurrentTree-&gt;NextPrefixTree;
00738     }
00739 
00740     <span class="comment">//</span>
00741     <span class="comment">//  We sesarched everywhere and didn't find a prefix so tell the</span>
00742     <span class="comment">//  caller none was found</span>
00743     <span class="comment">//</span>
00744 
00745     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00746 }
00747 
00748 
00749 CLONG
<a name="l00750"></a><a class="code" href="../../d4/d4/prefix_8c.html#a12">00750</a> <a class="code" href="../../d4/d4/prefix_8c.html#a12">ComputeNameLength</a>(
00751     IN PSTRING Name
00752     )
00753 
00754 <span class="comment">/*++</span>
00755 <span class="comment"></span>
00756 <span class="comment">Routine Description:</span>
00757 <span class="comment"></span>
00758 <span class="comment">    This routine counts the number of names appearing in the input string.</span>
00759 <span class="comment">    It does this by simply counting the number of backslashes in the string.</span>
00760 <span class="comment">    To handle ill-formed names (i.e., names that do not contain a backslash)</span>
00761 <span class="comment">    this routine really returns the number of backslashes plus 1.</span>
00762 <span class="comment"></span>
00763 <span class="comment">Arguments:</span>
00764 <span class="comment"></span>
00765 <span class="comment">    Name - Supplies the input name to examine</span>
00766 <span class="comment"></span>
00767 <span class="comment">Returns Value:</span>
00768 <span class="comment"></span>
00769 <span class="comment">    CLONG - the number of names in the input string</span>
00770 <span class="comment"></span>
00771 <span class="comment">--*/</span>
00772 
00773 {
00774     ULONG NameLength;
00775     ULONG i;
00776     ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00777 
00778     <span class="keyword">extern</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>;  <span class="comment">// Lead byte info. for ACP ( nlsxlat.c )</span>
00779     <span class="keyword">extern</span> BOOLEAN <a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a>;
00780 
00781     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00782 
00783     <span class="comment">//</span>
00784     <span class="comment">//  Save the name length, this should make the compiler be able to</span>
00785     <span class="comment">//  optimize not having to reload the length each time</span>
00786     <span class="comment">//</span>
00787 
00788     NameLength = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length - 1;
00789 
00790     <span class="comment">//</span>
00791     <span class="comment">//  Now loop through the input string counting back slashes</span>
00792     <span class="comment">//</span>
00793 
00794     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a>) {
00795 
00796         <span class="comment">//</span>
00797         <span class="comment">// ComputeNameLength() skip DBCS character when counting '\'</span>
00798         <span class="comment">//</span>
00799 
00800         <span class="keywordflow">for</span> (i = 0, <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 1; i &lt; NameLength; ) {
00801 
00802             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[(UCHAR)<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i]]) {
00803 
00804                 i += 2;
00805 
00806             } <span class="keywordflow">else</span> {
00807 
00808                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i] == <span class="charliteral">'\\'</span>) {
00809 
00810                     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1;
00811                 }
00812 
00813                 i += 1;
00814             }
00815         }
00816 
00817     } <span class="keywordflow">else</span> {
00818 
00819         <span class="keywordflow">for</span> (i = 0, <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 1; i &lt; NameLength; i += 1) {
00820 
00821             <span class="comment">//</span>
00822             <span class="comment">//  check for a back slash</span>
00823             <span class="comment">//</span>
00824 
00825             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i] == <span class="charliteral">'\\'</span>) {
00826 
00827                 <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1;
00828             }
00829         }
00830     }
00831 
00832     <span class="comment">//</span>
00833     <span class="comment">//  return the number of back slashes we found</span>
00834     <span class="comment">//</span>
00835 
00836     <span class="comment">//DbgPrint("ComputeNameLength(%s) = %x\n", Name-&gt;Buffer, Count);</span>
00837 
00838     <span class="keywordflow">return</span> <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00839 }
00840 
00841 
00842 <a class="code" href="../../d4/d4/prefix_8c.html#a7">COMPARISON</a>
<a name="l00843"></a><a class="code" href="../../d4/d4/prefix_8c.html#a13">00843</a> <a class="code" href="../../d4/d4/prefix_8c.html#a13">CompareNamesCaseSensitive</a> (
00844     IN PSTRING Prefix,
00845     IN PSTRING Name
00846     )
00847 
00848 <span class="comment">/*++</span>
00849 <span class="comment"></span>
00850 <span class="comment">Routine Description:</span>
00851 <span class="comment"></span>
00852 <span class="comment">    This routine takes a prefix string and a full name string and determines</span>
00853 <span class="comment">    if the prefix string is a proper prefix of the name string (case sensitive)</span>
00854 <span class="comment"></span>
00855 <span class="comment">Arguments:</span>
00856 <span class="comment"></span>
00857 <span class="comment">    Prefix - Supplies the input prefix string</span>
00858 <span class="comment"></span>
00859 <span class="comment">    Name - Supplies the full name input string</span>
00860 <span class="comment"></span>
00861 <span class="comment">Return Value:</span>
00862 <span class="comment"></span>
00863 <span class="comment">    COMPARISON - returns</span>
00864 <span class="comment"></span>
00865 <span class="comment">        IsLessThan    if Prefix &lt; Name lexicalgraphically,</span>
00866 <span class="comment">        IsPrefix      if Prefix is a proper prefix of Name</span>
00867 <span class="comment">        IsEqual       if Prefix is equal to Name, and</span>
00868 <span class="comment">        IsGreaterThan if Prefix &gt; Name lexicalgraphically</span>
00869 <span class="comment"></span>
00870 <span class="comment">--*/</span>
00871 
00872 {
00873     ULONG PrefixLength;
00874     ULONG NameLength;
00875     ULONG MinLength;
00876     ULONG i;
00877 
00878     UCHAR PrefixChar;
00879     UCHAR NameChar;
00880 
00881     <span class="keyword">extern</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>;  <span class="comment">// Lead byte info. for ACP ( nlsxlat.c )</span>
00882     <span class="keyword">extern</span> BOOLEAN <a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a>;
00883 
00884     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00885 
00886     <span class="comment">//DbgPrint("CompareNamesCaseSensitive(\"%s\", \"%s\") = ", Prefix-&gt;Buffer, Name-&gt;Buffer);</span>
00887 
00888     <span class="comment">//</span>
00889     <span class="comment">//  Save the length of the prefix and name string, this should allow</span>
00890     <span class="comment">//  the compiler to not need to reload the length through a pointer every</span>
00891     <span class="comment">//  time we need their values</span>
00892     <span class="comment">//</span>
00893 
00894     PrefixLength = Prefix-&gt;Length;
00895     NameLength = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length;
00896 
00897     <span class="comment">//</span>
00898     <span class="comment">//  Special case the situation where the prefix string is simply "\" and</span>
00899     <span class="comment">//  the name starts with an "\"</span>
00900     <span class="comment">//</span>
00901 
00902     <span class="keywordflow">if</span> ((Prefix-&gt;Length == 1) &amp;&amp; (Prefix-&gt;Buffer[0] == <span class="charliteral">'\\'</span>) &amp;&amp;
00903         (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length &gt; 1) &amp;&amp; (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[0] == <span class="charliteral">'\\'</span>)) {
00904         <span class="comment">//DbgPrint("IsPrefix\n");</span>
00905         <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a9">IsPrefix</a>;
00906     }
00907 
00908     <span class="comment">//</span>
00909     <span class="comment">//  Figure out the minimum of the two lengths</span>
00910     <span class="comment">//</span>
00911 
00912     MinLength = (PrefixLength &lt; NameLength ? PrefixLength : NameLength);
00913 
00914     <span class="comment">//</span>
00915     <span class="comment">//  Loop through looking at all of the characters in both strings</span>
00916     <span class="comment">//  testing for equalilty, less than, and greater than</span>
00917     <span class="comment">//</span>
00918 
00919     i = (ULONG) RtlCompareMemory( &amp;Prefix-&gt;Buffer[0], &amp;<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[0], MinLength );
00920 
00921     <span class="keywordflow">if</span> (i &lt; MinLength) {
00922 
00923         UCHAR <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>;
00924 
00925         <span class="comment">//</span>
00926         <span class="comment">//  Get both characters to examine and keep their case</span>
00927         <span class="comment">//</span>
00928 
00929         PrefixChar = ((<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a> = Prefix-&gt;Buffer[i]) == <span class="charliteral">'\\'</span> ? (<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>)0 : <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>);
00930         NameChar   = ((<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a> = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i])   == <span class="charliteral">'\\'</span> ? (<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>)0 : <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>);
00931 
00932         <span class="comment">//</span>
00933         <span class="comment">//  Unfortunately life is not so easy in DBCS land.</span>
00934         <span class="comment">//</span>
00935 
00936         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a>) {
00937 
00938             <span class="comment">//</span>
00939             <span class="comment">// CompareNamesCaseSensitive(): check backslash in trailing bytes</span>
00940             <span class="comment">//</span>
00941 
00942             <span class="keywordflow">if</span> (Prefix-&gt;Buffer[i] == <span class="charliteral">'\\'</span>) {
00943 
00944                 ULONG j;
00945                 <span class="keyword">extern</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>   <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>;  <span class="comment">// Lead byte info. for ACP ( nlsxlat.c )</span>
00946 
00947                 <span class="keywordflow">for</span> (j = 0; j &lt; i;) {
00948 
00949                     j += <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[(UCHAR)Prefix-&gt;Buffer[j]] ? 2 : 1;
00950                 }
00951 
00952                 <span class="keywordflow">if</span> (j != i) {
00953 
00954                     PrefixChar = <span class="charliteral">'\\'</span>;
00955                     <span class="comment">//DbgPrint("RTL:CompareNamesCaseSensitive encountered a fake backslash!\n");</span>
00956                 }
00957             }
00958 
00959             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i] == <span class="charliteral">'\\'</span>) {
00960 
00961                 ULONG j;
00962                 <span class="keyword">extern</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>   <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>;  <span class="comment">// Lead byte info. for ACP ( nlsxlat.c )</span>
00963 
00964                 <span class="keywordflow">for</span> (j = 0; j &lt; i;) {
00965 
00966                     j += <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[(UCHAR)<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[j]] ? 2 : 1;
00967                 }
00968 
00969                 <span class="keywordflow">if</span> (j != i) {
00970 
00971                     NameChar = <span class="charliteral">'\\'</span>;
00972                     <span class="comment">//DbgPrint("RTL:CompareNamesCaseSensitive encountered a fake backslash!\n");</span>
00973                 }
00974             }
00975         }
00976 
00977         <span class="comment">//</span>
00978         <span class="comment">//  Now compare the characters</span>
00979         <span class="comment">//</span>
00980 
00981         <span class="keywordflow">if</span> (PrefixChar &lt; NameChar) {
00982 
00983             <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a8">IsLessThan</a>;
00984 
00985         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PrefixChar &gt; NameChar) {
00986 
00987             <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a11">IsGreaterThan</a>;
00988         }
00989     }
00990 
00991     <span class="comment">//</span>
00992     <span class="comment">//  They match upto the minimum length so now figure out the largest string</span>
00993     <span class="comment">//  and see if one is a proper prefix of the other</span>
00994     <span class="comment">//</span>
00995 
00996     <span class="keywordflow">if</span> (PrefixLength &lt; NameLength) {
00997 
00998         <span class="comment">//</span>
00999         <span class="comment">//  The prefix string is shorter so if it is a proper prefix we</span>
01000         <span class="comment">//  return prefix otherwise we return less than (e.g., "\a" &lt; "\ab")</span>
01001         <span class="comment">//</span>
01002 
01003         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[PrefixLength] == <span class="charliteral">'\\'</span>) {
01004 
01005             <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a9">IsPrefix</a>;
01006 
01007         } <span class="keywordflow">else</span> {
01008 
01009             <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a8">IsLessThan</a>;
01010         }
01011 
01012     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PrefixLength &gt; NameLength) {
01013 
01014         <span class="comment">//</span>
01015         <span class="comment">//  The Prefix string is longer so we say that the prefix is</span>
01016         <span class="comment">//  greater than the name (e.g., "\ab" &gt; "\a")</span>
01017         <span class="comment">//</span>
01018 
01019         <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a11">IsGreaterThan</a>;
01020 
01021     } <span class="keywordflow">else</span> {
01022 
01023         <span class="comment">//</span>
01024         <span class="comment">//  They lengths are equal so the strings are equal</span>
01025         <span class="comment">//</span>
01026 
01027         <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a10">IsEqual</a>;
01028     }
01029 }
01030 
01031 
01032 <span class="comment">//</span>
01033 <span class="comment">//  The node type codes for the prefix data structures</span>
01034 <span class="comment">//</span>
01035 
<a name="l01036"></a><a class="code" href="../../d4/d4/prefix_8c.html#a3">01036</a> <span class="preprocessor">#define RTL_NTC_UNICODE_PREFIX_TABLE     ((CSHORT)0x0800)</span>
<a name="l01037"></a><a class="code" href="../../d4/d4/prefix_8c.html#a4">01037</a> <span class="preprocessor"></span><span class="preprocessor">#define RTL_NTC_UNICODE_ROOT             ((CSHORT)0x0801)</span>
<a name="l01038"></a><a class="code" href="../../d4/d4/prefix_8c.html#a5">01038</a> <span class="preprocessor"></span><span class="preprocessor">#define RTL_NTC_UNICODE_INTERNAL         ((CSHORT)0x0802)</span>
<a name="l01039"></a><a class="code" href="../../d4/d4/prefix_8c.html#a6">01039</a> <span class="preprocessor"></span><span class="preprocessor">#define RTL_NTC_UNICODE_CASE_MATCH       ((CSHORT)0x0803)</span>
01040 <span class="preprocessor"></span>
01041 
01042 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01043"></a><a class="code" href="../../d4/d4/prefix_8c.html#a20">01043</a> <a class="code" href="../../d4/d4/prefix_8c.html#a20">RtlInitializeUnicodePrefix</a> (
01044     IN PUNICODE_PREFIX_TABLE PrefixTable
01045     )
01046 
01047 <span class="comment">/*++</span>
01048 <span class="comment"></span>
01049 <span class="comment">Routine Description:</span>
01050 <span class="comment"></span>
01051 <span class="comment">    This routine initializes a unicode prefix table record to the empty state.</span>
01052 <span class="comment"></span>
01053 <span class="comment">Arguments:</span>
01054 <span class="comment"></span>
01055 <span class="comment">    PrefixTable - Supplies the prefix table being initialized</span>
01056 <span class="comment"></span>
01057 <span class="comment">Return Value:</span>
01058 <span class="comment"></span>
01059 <span class="comment">    None.</span>
01060 <span class="comment"></span>
01061 <span class="comment">--*/</span>
01062 
01063 {
01064     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01065 
01066     <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a3">RTL_NTC_UNICODE_PREFIX_TABLE</a>;
01067     <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;NameLength = 0;
01068     <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;NextPrefixTree = (PUNICODE_PREFIX_TABLE_ENTRY)<a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>;
01069     <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;LastNextEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01070 
01071     <span class="comment">//</span>
01072     <span class="comment">//  return to our caller</span>
01073     <span class="comment">//</span>
01074 
01075     <span class="keywordflow">return</span>;
01076 }
01077 
01078 
01079 BOOLEAN
<a name="l01080"></a><a class="code" href="../../d4/d4/prefix_8c.html#a21">01080</a> <a class="code" href="../../d4/d4/prefix_8c.html#a21">RtlInsertUnicodePrefix</a> (
01081     IN PUNICODE_PREFIX_TABLE PrefixTable,
01082     IN PUNICODE_STRING Prefix,
01083     IN PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
01084     )
01085 
01086 <span class="comment">/*++</span>
01087 <span class="comment"></span>
01088 <span class="comment">Routine Description:</span>
01089 <span class="comment"></span>
01090 <span class="comment">    This routine inserts a new unicode prefix into the specified prefix table</span>
01091 <span class="comment"></span>
01092 <span class="comment">Arguments:</span>
01093 <span class="comment"></span>
01094 <span class="comment">    PrefixTable - Supplies the target prefix table</span>
01095 <span class="comment"></span>
01096 <span class="comment">    Prefix - Supplies the string to be inserted in the prefix table</span>
01097 <span class="comment"></span>
01098 <span class="comment">    PrefixTableEntry - Supplies the entry to use to insert the prefix</span>
01099 <span class="comment"></span>
01100 <span class="comment">Return Value:</span>
01101 <span class="comment"></span>
01102 <span class="comment">    BOOLEAN - TRUE if the Prefix is not already in the table, and FALSE</span>
01103 <span class="comment">        otherwise</span>
01104 <span class="comment"></span>
01105 <span class="comment">--*/</span>
01106 
01107 {
01108     ULONG PrefixNameLength;
01109 
01110     PUNICODE_PREFIX_TABLE_ENTRY PreviousTree;
01111     PUNICODE_PREFIX_TABLE_ENTRY CurrentTree;
01112     PUNICODE_PREFIX_TABLE_ENTRY NextTree;
01113 
01114     PUNICODE_PREFIX_TABLE_ENTRY Node;
01115 
01116     <a class="code" href="../../d4/d4/prefix_8c.html#a7">COMPARISON</a> Comparison;
01117 
01118     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01119 
01120     <span class="comment">//</span>
01121     <span class="comment">//  Determine the name length of the input string</span>
01122     <span class="comment">//</span>
01123 
01124     PrefixNameLength = <a class="code" href="../../d4/d4/prefix_8c.html#a14">ComputeUnicodeNameLength</a>(Prefix);
01125 
01126     <span class="comment">//</span>
01127     <span class="comment">//  Setup parts of the prefix table entry that we will always need</span>
01128     <span class="comment">//</span>
01129 
01130     PrefixTableEntry-&gt;NameLength = (CSHORT)PrefixNameLength;
01131     PrefixTableEntry-&gt;Prefix = Prefix;
01132 
01133     RtlInitializeSplayLinks(&amp;PrefixTableEntry-&gt;Links);
01134 
01135     <span class="comment">//</span>
01136     <span class="comment">//  find the corresponding tree, or find where the tree should go</span>
01137     <span class="comment">//</span>
01138 
01139     PreviousTree = (PUNICODE_PREFIX_TABLE_ENTRY)<a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>;
01140     CurrentTree = PreviousTree-&gt;NextPrefixTree;
01141 
01142     <span class="keywordflow">while</span> (CurrentTree-&gt;NameLength &gt; (CSHORT)PrefixNameLength) {
01143 
01144         PreviousTree = CurrentTree;
01145         CurrentTree = CurrentTree-&gt;NextPrefixTree;
01146     }
01147 
01148     <span class="comment">//</span>
01149     <span class="comment">//  If the name length of the current tree is not equal to the</span>
01150     <span class="comment">//  prefix name length then the tree does not exist and we need</span>
01151     <span class="comment">//  to make a new tree node.</span>
01152     <span class="comment">//</span>
01153 
01154     <span class="keywordflow">if</span> (CurrentTree-&gt;NameLength != (CSHORT)PrefixNameLength) {
01155 
01156         <span class="comment">//</span>
01157         <span class="comment">//  Insert the new prefix entry to the list between</span>
01158         <span class="comment">//  previous and current tree</span>
01159         <span class="comment">//</span>
01160 
01161         PreviousTree-&gt;NextPrefixTree = PrefixTableEntry;
01162         PrefixTableEntry-&gt;NextPrefixTree = CurrentTree;
01163 
01164         <span class="comment">//</span>
01165         <span class="comment">//  And set the node type code, case match for the root tree node</span>
01166         <span class="comment">//</span>
01167 
01168         PrefixTableEntry-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a4">RTL_NTC_UNICODE_ROOT</a>;
01169         PrefixTableEntry-&gt;CaseMatch = PrefixTableEntry;
01170 
01171         <span class="comment">//</span>
01172         <span class="comment">//  And tell our caller everything worked fine</span>
01173         <span class="comment">//</span>
01174 
01175         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01176     }
01177 
01178     <span class="comment">//</span>
01179     <span class="comment">//  The tree does exist so now search the tree for our</span>
01180     <span class="comment">//  position in it.  We only exit the loop if we've inserted</span>
01181     <span class="comment">//  a new node, and node is left is left pointing to the</span>
01182     <span class="comment">//  tree position</span>
01183     <span class="comment">//</span>
01184 
01185     Node = CurrentTree;
01186 
01187     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01188 
01189         <span class="comment">//</span>
01190         <span class="comment">//  Compare the prefix in the tree with the prefix we want</span>
01191         <span class="comment">//  to insert.  Do the compare case blind</span>
01192         <span class="comment">//</span>
01193 
01194         Comparison = <a class="code" href="../../d4/d4/prefix_8c.html#a15">CompareUnicodeStrings</a>(Node-&gt;Prefix, Prefix, 0);
01195 
01196         <span class="comment">//</span>
01197         <span class="comment">//  If they are equal then this node gets added as a case</span>
01198         <span class="comment">//  match, provided it doesn't case sensitive match anyone</span>
01199         <span class="comment">//</span>
01200 
01201         <span class="keywordflow">if</span> (Comparison == <a class="code" href="../../d4/d4/prefix_8c.html#a25a10">IsEqual</a>) {
01202 
01203             PUNICODE_PREFIX_TABLE_ENTRY Next;
01204 
01205             <span class="comment">//</span>
01206             <span class="comment">//  Loop through the case match list checking to see if we</span>
01207             <span class="comment">//  match case sensitive with anyone.  Get the first node</span>
01208             <span class="comment">//</span>
01209 
01210             Next = Node;
01211 
01212             <span class="comment">//</span>
01213             <span class="comment">//  And loop checking each node until we're back to where</span>
01214             <span class="comment">//  we started</span>
01215             <span class="comment">//</span>
01216 
01217             <span class="keywordflow">do</span> {
01218 
01219                 <span class="comment">//</span>
01220                 <span class="comment">//  If we do match case sensitive then we cannot add</span>
01221                 <span class="comment">//  this prefix so we return false.  Note this is the</span>
01222                 <span class="comment">//  only condition where we return false</span>
01223                 <span class="comment">//</span>
01224 
01225                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d4/prefix_8c.html#a15">CompareUnicodeStrings</a>(Next-&gt;Prefix, Prefix, MAXULONG) == <a class="code" href="../../d4/d4/prefix_8c.html#a25a10">IsEqual</a>) {
01226 
01227                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01228                 }
01229 
01230                 <span class="comment">//</span>
01231                 <span class="comment">//  Get the next node in the case match list</span>
01232                 <span class="comment">//</span>
01233 
01234                 Next = Next-&gt;CaseMatch;
01235 
01236                 <span class="comment">//</span>
01237                 <span class="comment">//  And continue looping until we're back where we started</span>
01238                 <span class="comment">//</span>
01239 
01240             } <span class="keywordflow">while</span> ( Next != Node );
01241 
01242             <span class="comment">//</span>
01243             <span class="comment">//  We've searched the case match and didn't find an exact match</span>
01244             <span class="comment">//  so we can insert this node in the case match list</span>
01245             <span class="comment">//</span>
01246 
01247             PrefixTableEntry-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a6">RTL_NTC_UNICODE_CASE_MATCH</a>;
01248             PrefixTableEntry-&gt;NextPrefixTree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01249 
01250             PrefixTableEntry-&gt;CaseMatch = Node-&gt;CaseMatch;
01251             Node-&gt;CaseMatch = PrefixTableEntry;
01252 
01253             <span class="comment">//</span>
01254             <span class="comment">//  And exit out of the while loop</span>
01255             <span class="comment">//</span>
01256 
01257             <span class="keywordflow">break</span>;
01258         }
01259 
01260         <span class="comment">//</span>
01261         <span class="comment">//  If the tree prefix is greater than the new prefix then</span>
01262         <span class="comment">//  we go down the left subtree</span>
01263         <span class="comment">//</span>
01264 
01265         <span class="keywordflow">if</span> (Comparison == <a class="code" href="../../d4/d4/prefix_8c.html#a25a11">IsGreaterThan</a>) {
01266 
01267             <span class="comment">//</span>
01268             <span class="comment">//  We want to go down the left subtree, first check to see</span>
01269             <span class="comment">//  if we have a left subtree</span>
01270             <span class="comment">//</span>
01271 
01272             <span class="keywordflow">if</span> (RtlLeftChild(&amp;Node-&gt;Links) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01273 
01274                 <span class="comment">//</span>
01275                 <span class="comment">//  there isn't a left child so we insert ourselves as the</span>
01276                 <span class="comment">//  new left child</span>
01277                 <span class="comment">//</span>
01278 
01279                 PrefixTableEntry-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a5">RTL_NTC_UNICODE_INTERNAL</a>;
01280                 PrefixTableEntry-&gt;NextPrefixTree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01281                 PrefixTableEntry-&gt;CaseMatch = PrefixTableEntry;
01282 
01283                 RtlInsertAsLeftChild(&amp;Node-&gt;Links, &amp;PrefixTableEntry-&gt;Links);
01284 
01285                 <span class="comment">//</span>
01286                 <span class="comment">//  and exit the while loop</span>
01287                 <span class="comment">//</span>
01288 
01289                 <span class="keywordflow">break</span>;
01290 
01291             } <span class="keywordflow">else</span> {
01292 
01293                 <span class="comment">//</span>
01294                 <span class="comment">//  there is a left child so simply go down that path, and</span>
01295                 <span class="comment">//  go back to the top of the loop</span>
01296                 <span class="comment">//</span>
01297 
01298                 Node = CONTAINING_RECORD( RtlLeftChild(&amp;Node-&gt;Links),
01299                                           UNICODE_PREFIX_TABLE_ENTRY,
01300                                           Links );
01301             }
01302 
01303         } <span class="keywordflow">else</span> {
01304 
01305             <span class="comment">//</span>
01306             <span class="comment">//  The tree prefix is either less than or a proper prefix</span>
01307             <span class="comment">//  of the new string.  We treat both cases a less than when</span>
01308             <span class="comment">//  we do insert.  So we want to go down the right subtree,</span>
01309             <span class="comment">//  first check to see if we have a right subtree</span>
01310             <span class="comment">//</span>
01311 
01312             <span class="keywordflow">if</span> (RtlRightChild(&amp;Node-&gt;Links) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01313 
01314                 <span class="comment">//</span>
01315                 <span class="comment">//  These isn't a right child so we insert ourselves as the</span>
01316                 <span class="comment">//  new right child</span>
01317                 <span class="comment">//</span>
01318 
01319                 PrefixTableEntry-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a5">RTL_NTC_UNICODE_INTERNAL</a>;
01320                 PrefixTableEntry-&gt;NextPrefixTree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01321                 PrefixTableEntry-&gt;CaseMatch = PrefixTableEntry;
01322 
01323                 RtlInsertAsRightChild(&amp;Node-&gt;Links, &amp;PrefixTableEntry-&gt;Links);
01324 
01325                 <span class="comment">//</span>
01326                 <span class="comment">//  and exit the while loop</span>
01327                 <span class="comment">//</span>
01328 
01329                 <span class="keywordflow">break</span>;
01330 
01331             } <span class="keywordflow">else</span> {
01332 
01333                 <span class="comment">//</span>
01334                 <span class="comment">//  there is a right child so simply go down that path, and</span>
01335                 <span class="comment">//  go back to the top of the loop</span>
01336                 <span class="comment">//</span>
01337 
01338                 Node = CONTAINING_RECORD( RtlRightChild(&amp;Node-&gt;Links),
01339                                           UNICODE_PREFIX_TABLE_ENTRY,
01340                                           Links );
01341             }
01342         }
01343     }
01344 
01345     <span class="comment">//</span>
01346     <span class="comment">//  Now that we've inserted the new node we can splay the tree.</span>
01347     <span class="comment">//  To do this we need to remember how we find this tree in the root</span>
01348     <span class="comment">//  tree list, set the root to be an internal, splay, the tree, and</span>
01349     <span class="comment">//  then setup the new root node.  Note: we cannot splay the prefix table</span>
01350     <span class="comment">//  entry because it might be a case match node so we only splay</span>
01351     <span class="comment">//  the Node variable, which for case match insertions is the</span>
01352     <span class="comment">//  internal node for the case match and for non-case match insertions</span>
01353     <span class="comment">//  the Node variable is the parent node.</span>
01354     <span class="comment">//</span>
01355 
01356     <span class="comment">//</span>
01357     <span class="comment">//  Save a pointer to the next tree, we already have the previous tree</span>
01358     <span class="comment">//</span>
01359 
01360     NextTree = CurrentTree-&gt;NextPrefixTree;
01361 
01362     <span class="comment">//</span>
01363     <span class="comment">//  Reset the current root to be an internal node</span>
01364     <span class="comment">//</span>
01365 
01366     CurrentTree-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a5">RTL_NTC_UNICODE_INTERNAL</a>;
01367     CurrentTree-&gt;NextPrefixTree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01368 
01369     <span class="comment">//</span>
01370     <span class="comment">//  Splay the tree and get the root</span>
01371     <span class="comment">//</span>
01372 
01373     Node = CONTAINING_RECORD(<a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(&amp;Node-&gt;Links), UNICODE_PREFIX_TABLE_ENTRY, Links);
01374 
01375     <span class="comment">//</span>
01376     <span class="comment">//  Set the new root's node type code and make it part of the</span>
01377     <span class="comment">//  root tree list</span>
01378     <span class="comment">//</span>
01379 
01380     Node-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a4">RTL_NTC_UNICODE_ROOT</a>;
01381     PreviousTree-&gt;NextPrefixTree = Node;
01382     Node-&gt;NextPrefixTree = NextTree;
01383 
01384     <span class="comment">//</span>
01385     <span class="comment">//  tell our caller everything worked fine</span>
01386     <span class="comment">//</span>
01387 
01388     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01389 }
01390 
01391 
01392 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01393"></a><a class="code" href="../../d4/d4/prefix_8c.html#a22">01393</a> <a class="code" href="../../d4/d4/prefix_8c.html#a22">RtlRemoveUnicodePrefix</a> (
01394     IN PUNICODE_PREFIX_TABLE PrefixTable,
01395     IN PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
01396     )
01397 
01398 <span class="comment">/*++</span>
01399 <span class="comment"></span>
01400 <span class="comment">Routine Description:</span>
01401 <span class="comment"></span>
01402 <span class="comment">    This routine removes the indicated prefix table entry from</span>
01403 <span class="comment">    the prefix table</span>
01404 <span class="comment"></span>
01405 <span class="comment">Arguments:</span>
01406 <span class="comment"></span>
01407 <span class="comment">    PrefixTable - Supplies the prefix table affected</span>
01408 <span class="comment"></span>
01409 <span class="comment">    PrefixTableEntry - Supplies the prefix entry to remove</span>
01410 <span class="comment"></span>
01411 <span class="comment">Return Value:</span>
01412 <span class="comment"></span>
01413 <span class="comment">    None.</span>
01414 <span class="comment"></span>
01415 <span class="comment">--*/</span>
01416 
01417 {
01418     PUNICODE_PREFIX_TABLE_ENTRY PreviousCaseMatch;
01419 
01420     PRTL_SPLAY_LINKS Links;
01421 
01422     PUNICODE_PREFIX_TABLE_ENTRY Root;
01423     PUNICODE_PREFIX_TABLE_ENTRY NewRoot;
01424 
01425     PUNICODE_PREFIX_TABLE_ENTRY PreviousTree;
01426 
01427     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01428 
01429     <span class="comment">//</span>
01430     <span class="comment">//  Wipe out the next last entry field of the prefix table</span>
01431     <span class="comment">//</span>
01432 
01433     <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;LastNextEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01434 
01435     <span class="comment">//</span>
01436     <span class="comment">//  case on the type of node that we are trying to delete</span>
01437     <span class="comment">//</span>
01438 
01439     <span class="keywordflow">switch</span> (PrefixTableEntry-&gt;NodeTypeCode) {
01440 
01441     <span class="keywordflow">case</span> <a class="code" href="../../d4/d4/prefix_8c.html#a6">RTL_NTC_UNICODE_CASE_MATCH</a>:
01442 
01443         <span class="comment">//</span>
01444         <span class="comment">//  The prefix entry is a case match record so</span>
01445         <span class="comment">//  we only need to remove it from the case match list.</span>
01446         <span class="comment">//  Locate the previous PrefixTableEntry that reference this</span>
01447         <span class="comment">//  case match record</span>
01448         <span class="comment">//</span>
01449 
01450         PreviousCaseMatch = PrefixTableEntry-&gt;CaseMatch;
01451 
01452         <span class="keywordflow">while</span> ( PreviousCaseMatch-&gt;CaseMatch != PrefixTableEntry ) {
01453 
01454              PreviousCaseMatch = PreviousCaseMatch-&gt;CaseMatch;
01455         }
01456 
01457         <span class="comment">//</span>
01458         <span class="comment">//  Now that we have the previous record just have it point</span>
01459         <span class="comment">//  around the case match that is being deleted</span>
01460         <span class="comment">//</span>
01461 
01462         PreviousCaseMatch-&gt;CaseMatch = PrefixTableEntry-&gt;CaseMatch;
01463 
01464         <span class="comment">//</span>
01465         <span class="comment">//  And return to our caller</span>
01466         <span class="comment">//</span>
01467 
01468         <span class="keywordflow">return</span>;
01469 
01470     <span class="keywordflow">case</span> <a class="code" href="../../d4/d4/prefix_8c.html#a5">RTL_NTC_UNICODE_INTERNAL</a>:
01471     <span class="keywordflow">case</span> <a class="code" href="../../d4/d4/prefix_8c.html#a4">RTL_NTC_UNICODE_ROOT</a>:
01472 
01473         <span class="comment">//</span>
01474         <span class="comment">//  The prefix entry is an internal/root node so check to see if it</span>
01475         <span class="comment">//  has any case match nodes with it</span>
01476         <span class="comment">//</span>
01477 
01478         <span class="keywordflow">if</span> (PrefixTableEntry-&gt;CaseMatch != PrefixTableEntry) {
01479 
01480             <span class="comment">//</span>
01481             <span class="comment">//  There is at least one case match that goes with this</span>
01482             <span class="comment">//  node, so we need to make the next case match the</span>
01483             <span class="comment">//  new node and remove this node.</span>
01484             <span class="comment">//  Locate the previous prefix table entry that references this</span>
01485             <span class="comment">//  case match record</span>
01486             <span class="comment">//</span>
01487 
01488             PreviousCaseMatch = PrefixTableEntry-&gt;CaseMatch;
01489 
01490             <span class="keywordflow">while</span> ( PreviousCaseMatch-&gt;CaseMatch != PrefixTableEntry ) {
01491 
01492                 PreviousCaseMatch = PreviousCaseMatch-&gt;CaseMatch;
01493             }
01494 
01495             <span class="comment">//</span>
01496             <span class="comment">//  Now that we have the previous record just have it point</span>
01497             <span class="comment">//  around the node being deleted</span>
01498             <span class="comment">//</span>
01499 
01500             PreviousCaseMatch-&gt;CaseMatch = PrefixTableEntry-&gt;CaseMatch;
01501 
01502             <span class="comment">//</span>
01503             <span class="comment">//  Now make the previous case match in the new node</span>
01504             <span class="comment">//</span>
01505 
01506             PreviousCaseMatch-&gt;NodeTypeCode = PrefixTableEntry-&gt;NodeTypeCode;
01507             PreviousCaseMatch-&gt;NextPrefixTree = PrefixTableEntry-&gt;NextPrefixTree;
01508             PreviousCaseMatch-&gt;Links = PrefixTableEntry-&gt;Links;
01509 
01510             <span class="comment">//</span>
01511             <span class="comment">//  Now take care of the back pointers to this new internal</span>
01512             <span class="comment">//  node in the splay tree, first do the parent's pointer to us.</span>
01513             <span class="comment">//</span>
01514 
01515             <span class="keywordflow">if</span> (RtlIsRoot(&amp;PrefixTableEntry-&gt;Links)) {
01516 
01517                 <span class="comment">//</span>
01518                 <span class="comment">//  This is the root so make this new node the root</span>
01519                 <span class="comment">//</span>
01520 
01521                 PreviousCaseMatch-&gt;Links.Parent = &amp;PreviousCaseMatch-&gt;Links;
01522 
01523                 <span class="comment">//</span>
01524                 <span class="comment">//  Fix up the root tree list, by first finding the previous</span>
01525                 <span class="comment">//  pointer to us</span>
01526 
01527                 PreviousTree = PrefixTableEntry-&gt;NextPrefixTree;
01528 
01529                 <span class="keywordflow">while</span> ( PreviousTree-&gt;NextPrefixTree != PrefixTableEntry ) {
01530 
01531                     PreviousTree = PreviousTree-&gt;NextPrefixTree;
01532                 }
01533 
01534                 <span class="comment">//</span>
01535                 <span class="comment">//  We've located the previous tree so now have the previous</span>
01536                 <span class="comment">//  tree point to our new root</span>
01537                 <span class="comment">//</span>
01538 
01539                 PreviousTree-&gt;NextPrefixTree = PreviousCaseMatch;
01540 
01541             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (RtlIsLeftChild(&amp;PrefixTableEntry-&gt;Links)) {
01542 
01543                 <span class="comment">//</span>
01544                 <span class="comment">//  The node was the left child so make the new node the</span>
01545                 <span class="comment">//  left child</span>
01546                 <span class="comment">//</span>
01547 
01548                 RtlParent(&amp;PrefixTableEntry-&gt;Links)-&gt;LeftChild = &amp;PreviousCaseMatch-&gt;Links;
01549 
01550             } <span class="keywordflow">else</span> {
01551 
01552                 <span class="comment">//</span>
01553                 <span class="comment">//  The node was the right child so make the new node the</span>
01554                 <span class="comment">//  right child</span>
01555                 <span class="comment">//</span>
01556 
01557                 RtlParent(&amp;PrefixTableEntry-&gt;Links)-&gt;RightChild = &amp;PreviousCaseMatch-&gt;Links;
01558             }
01559 
01560             <span class="comment">//</span>
01561             <span class="comment">//  Now update the parent pointer for our new children</span>
01562             <span class="comment">//</span>
01563 
01564             <span class="keywordflow">if</span> (RtlLeftChild(&amp;PreviousCaseMatch-&gt;Links) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01565 
01566                 RtlLeftChild(&amp;PreviousCaseMatch-&gt;Links)-&gt;Parent = &amp;PreviousCaseMatch-&gt;Links;
01567             }
01568 
01569             <span class="keywordflow">if</span> (RtlRightChild(&amp;PreviousCaseMatch-&gt;Links) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01570 
01571                 RtlRightChild(&amp;PreviousCaseMatch-&gt;Links)-&gt;Parent = &amp;PreviousCaseMatch-&gt;Links;
01572             }
01573 
01574             <span class="comment">//</span>
01575             <span class="comment">//  And return to our caller</span>
01576             <span class="comment">//</span>
01577 
01578             <span class="keywordflow">return</span>;
01579         }
01580 
01581         <span class="comment">//</span>
01582         <span class="comment">//  The node is internal or root node and does not have any case match</span>
01583         <span class="comment">//  nodes so we need to delete it from the tree, but first find</span>
01584         <span class="comment">//  the root of the tree</span>
01585         <span class="comment">//</span>
01586 
01587         Links = &amp;PrefixTableEntry-&gt;Links;
01588 
01589         <span class="keywordflow">while</span> (!RtlIsRoot(Links)) {
01590 
01591             Links = RtlParent(Links);
01592         }
01593 
01594         Root = CONTAINING_RECORD( Links, UNICODE_PREFIX_TABLE_ENTRY, Links );
01595 
01596         <span class="comment">//</span>
01597         <span class="comment">//  Now delete the node</span>
01598         <span class="comment">//</span>
01599 
01600         Links = <a class="code" href="../../d3/d4/splay_8c.html#a4">RtlDelete</a>(&amp;PrefixTableEntry-&gt;Links);
01601 
01602         <span class="comment">//</span>
01603         <span class="comment">//  Now see if the tree is deleted</span>
01604         <span class="comment">//</span>
01605 
01606         <span class="keywordflow">if</span> (Links == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01607 
01608             <span class="comment">//</span>
01609             <span class="comment">//  The tree is now empty so remove this tree from</span>
01610             <span class="comment">//  the tree list, by first finding the previous tree that</span>
01611             <span class="comment">//  references us</span>
01612             <span class="comment">//</span>
01613 
01614             PreviousTree = Root-&gt;NextPrefixTree;
01615 
01616             <span class="keywordflow">while</span> ( PreviousTree-&gt;NextPrefixTree != Root ) {
01617 
01618                 PreviousTree = PreviousTree-&gt;NextPrefixTree;
01619             }
01620 
01621             <span class="comment">//</span>
01622             <span class="comment">//  We've located the previous tree so now just have it</span>
01623             <span class="comment">//  point around the deleted node</span>
01624             <span class="comment">//</span>
01625 
01626             PreviousTree-&gt;NextPrefixTree = Root-&gt;NextPrefixTree;
01627 
01628             <span class="comment">//</span>
01629             <span class="comment">//  and return the our caller</span>
01630             <span class="comment">//</span>
01631 
01632             <span class="keywordflow">return</span>;
01633         }
01634 
01635         <span class="comment">//</span>
01636         <span class="comment">//  The tree is not deleted but see if we changed roots</span>
01637         <span class="comment">//</span>
01638 
01639         <span class="keywordflow">if</span> (&amp;Root-&gt;Links != Links) {
01640 
01641             <span class="comment">//</span>
01642             <span class="comment">//  Get a pointer to the new root</span>
01643             <span class="comment">//</span>
01644 
01645             NewRoot = CONTAINING_RECORD(Links, UNICODE_PREFIX_TABLE_ENTRY, Links);
01646 
01647             <span class="comment">//</span>
01648             <span class="comment">//  We changed root so we better need to make the new</span>
01649             <span class="comment">//  root part of the prefix data structure, by</span>
01650             <span class="comment">//  first finding the previous tree that</span>
01651             <span class="comment">//  references us</span>
01652             <span class="comment">//</span>
01653 
01654             PreviousTree = Root-&gt;NextPrefixTree;
01655 
01656             <span class="keywordflow">while</span> ( PreviousTree-&gt;NextPrefixTree != Root ) {
01657 
01658                 PreviousTree = PreviousTree-&gt;NextPrefixTree;
01659             }
01660 
01661             <span class="comment">//</span>
01662             <span class="comment">//  Set the new root</span>
01663             <span class="comment">//</span>
01664 
01665             NewRoot-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a4">RTL_NTC_UNICODE_ROOT</a>;
01666 
01667             PreviousTree-&gt;NextPrefixTree = NewRoot;
01668             NewRoot-&gt;NextPrefixTree = Root-&gt;NextPrefixTree;
01669 
01670             <span class="comment">//</span>
01671             <span class="comment">//  Set the old root to be an internal node</span>
01672             <span class="comment">//</span>
01673 
01674             Root-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a5">RTL_NTC_UNICODE_INTERNAL</a>;
01675 
01676             Root-&gt;NextPrefixTree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01677 
01678             <span class="comment">//</span>
01679             <span class="comment">//  And return to our caller</span>
01680             <span class="comment">//</span>
01681 
01682             <span class="keywordflow">return</span>;
01683         }
01684 
01685         <span class="comment">//</span>
01686         <span class="comment">//  We didn't change roots so everything is fine and we can</span>
01687         <span class="comment">//  simply return to our caller</span>
01688         <span class="comment">//</span>
01689 
01690         <span class="keywordflow">return</span>;
01691 
01692     <span class="keywordflow">default</span>:
01693 
01694         <span class="comment">//</span>
01695         <span class="comment">//  If we get here then there was an error and the node type</span>
01696         <span class="comment">//  code is unknown</span>
01697         <span class="comment">//</span>
01698 
01699         <span class="keywordflow">return</span>;
01700     }
01701 }
01702 
01703 
01704 PUNICODE_PREFIX_TABLE_ENTRY
<a name="l01705"></a><a class="code" href="../../d4/d4/prefix_8c.html#a23">01705</a> <a class="code" href="../../d4/d4/prefix_8c.html#a23">RtlFindUnicodePrefix</a> (
01706     IN PUNICODE_PREFIX_TABLE PrefixTable,
01707     IN PUNICODE_STRING FullName,
01708     IN ULONG CaseInsensitiveIndex
01709     )
01710 
01711 <span class="comment">/*++</span>
01712 <span class="comment"></span>
01713 <span class="comment">Routine Description:</span>
01714 <span class="comment"></span>
01715 <span class="comment">    This routine finds if a full name has a prefix in a prefix table.</span>
01716 <span class="comment">    It returns a pointer to the largest proper prefix found if one exists.</span>
01717 <span class="comment"></span>
01718 <span class="comment">Arguments:</span>
01719 <span class="comment"></span>
01720 <span class="comment">    PrefixTable - Supplies the prefix table to search</span>
01721 <span class="comment"></span>
01722 <span class="comment">    FullString - Supplies the name to search for</span>
01723 <span class="comment"></span>
01724 <span class="comment">    CaseInsensitiveIndex - Indicates the wchar index at which to do a case</span>
01725 <span class="comment">        insensitive search.  All characters before the index are searched</span>
01726 <span class="comment">        case sensitive and all characters at and after the index are searched</span>
01727 <span class="comment">        insensitive.</span>
01728 <span class="comment"></span>
01729 <span class="comment">Return Value:</span>
01730 <span class="comment"></span>
01731 <span class="comment">    PPREFIX_TABLE_ENTRY - a pointer to the longest prefix found if one</span>
01732 <span class="comment">        exists, and NULL otherwise</span>
01733 <span class="comment"></span>
01734 <span class="comment">--*/</span>
01735 
01736 {
01737     CLONG NameLength;
01738 
01739     PUNICODE_PREFIX_TABLE_ENTRY PreviousTree;
01740     PUNICODE_PREFIX_TABLE_ENTRY CurrentTree;
01741     PUNICODE_PREFIX_TABLE_ENTRY NextTree;
01742 
01743     PRTL_SPLAY_LINKS Links;
01744 
01745     PUNICODE_PREFIX_TABLE_ENTRY Node;
01746     PUNICODE_PREFIX_TABLE_ENTRY Next;
01747 
01748     <a class="code" href="../../d4/d4/prefix_8c.html#a7">COMPARISON</a> Comparison;
01749 
01750     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01751 
01752     <span class="comment">//</span>
01753     <span class="comment">//  Determine the name length of the input string</span>
01754     <span class="comment">//</span>
01755 
01756     NameLength = <a class="code" href="../../d4/d4/prefix_8c.html#a14">ComputeUnicodeNameLength</a>(FullName);
01757 
01758     <span class="comment">//</span>
01759     <span class="comment">//  Locate the first tree that can contain a prefix</span>
01760     <span class="comment">//</span>
01761 
01762     PreviousTree = (PUNICODE_PREFIX_TABLE_ENTRY)<a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>;
01763     CurrentTree = PreviousTree-&gt;NextPrefixTree;
01764 
01765     <span class="keywordflow">while</span> (CurrentTree-&gt;NameLength &gt; (CSHORT)NameLength) {
01766 
01767         PreviousTree = CurrentTree;
01768         CurrentTree = CurrentTree-&gt;NextPrefixTree;
01769     }
01770 
01771     <span class="comment">//</span>
01772     <span class="comment">//  Now search for a prefix until we find one or until we exhaust</span>
01773     <span class="comment">//  the prefix trees</span>
01774     <span class="comment">//</span>
01775 
01776     <span class="keywordflow">while</span> (CurrentTree-&gt;NameLength &gt; 0) {
01777 
01778         Links = &amp;CurrentTree-&gt;Links;
01779 
01780         <span class="keywordflow">while</span> (Links != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01781 
01782             Node = CONTAINING_RECORD(Links, UNICODE_PREFIX_TABLE_ENTRY, Links);
01783 
01784             <span class="comment">//</span>
01785             <span class="comment">//  Compare the prefix in the tree with the full name, do the</span>
01786             <span class="comment">//  compare case blind</span>
01787             <span class="comment">//</span>
01788 
01789             Comparison = <a class="code" href="../../d4/d4/prefix_8c.html#a15">CompareUnicodeStrings</a>(Node-&gt;Prefix, FullName, 0);
01790 
01791             <span class="comment">//</span>
01792             <span class="comment">//  See if they don't match</span>
01793             <span class="comment">//</span>
01794 
01795             <span class="keywordflow">if</span> (Comparison == <a class="code" href="../../d4/d4/prefix_8c.html#a25a11">IsGreaterThan</a>) {
01796 
01797                 <span class="comment">//</span>
01798                 <span class="comment">//  The prefix is greater than the full name</span>
01799                 <span class="comment">//  so we go down the left child</span>
01800                 <span class="comment">//</span>
01801 
01802                 Links = RtlLeftChild(Links);
01803 
01804                 <span class="comment">//</span>
01805                 <span class="comment">//  And continue searching down this tree</span>
01806                 <span class="comment">//</span>
01807 
01808             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Comparison == <a class="code" href="../../d4/d4/prefix_8c.html#a25a8">IsLessThan</a>) {
01809 
01810                 <span class="comment">//</span>
01811                 <span class="comment">//  The prefix is less than the full name</span>
01812                 <span class="comment">//  so we go down the right child</span>
01813                 <span class="comment">//</span>
01814 
01815                 Links = RtlRightChild(Links);
01816 
01817                 <span class="comment">//</span>
01818                 <span class="comment">//  And continue searching down this tree</span>
01819                 <span class="comment">//</span>
01820 
01821             } <span class="keywordflow">else</span> {
01822 
01823                 <span class="comment">//</span>
01824                 <span class="comment">//  We have either a prefix or a match either way</span>
01825                 <span class="comment">//  we need to check if we should do case sensitive</span>
01826                 <span class="comment">//  seearches</span>
01827                 <span class="comment">//</span>
01828 
01829                 <span class="keywordflow">if</span> (CaseInsensitiveIndex == 0) {
01830 
01831                     <span class="comment">//</span>
01832                     <span class="comment">//  The caller wants case insensitive so we'll</span>
01833                     <span class="comment">//  return the first one we found</span>
01834                     <span class="comment">//</span>
01835                     <span class="comment">//  Now that we've located the node we can splay the tree.</span>
01836                     <span class="comment">//  To do this we need to remember how we find this tree in the root</span>
01837                     <span class="comment">//  tree list, set the root to be an internal, splay, the tree, and</span>
01838                     <span class="comment">//  then setup the new root node.</span>
01839                     <span class="comment">//</span>
01840 
01841                     <span class="keywordflow">if</span> (Node-&gt;NodeTypeCode == <a class="code" href="../../d4/d4/prefix_8c.html#a5">RTL_NTC_UNICODE_INTERNAL</a>) {
01842 
01843                         <span class="comment">//DbgPrint("PrefixTable  = %08lx\n", PrefixTable);</span>
01844                         <span class="comment">//DbgPrint("Node         = %08lx\n", Node);</span>
01845                         <span class="comment">//DbgPrint("CurrentTree  = %08lx\n", CurrentTree);</span>
01846                         <span class="comment">//DbgPrint("PreviousTree = %08lx\n", PreviousTree);</span>
01847                         <span class="comment">//DbgBreakPoint();</span>
01848 
01849                         <span class="comment">//</span>
01850                         <span class="comment">//  Save a pointer to the next tree, we already have the previous tree</span>
01851                         <span class="comment">//</span>
01852 
01853                         NextTree = CurrentTree-&gt;NextPrefixTree;
01854 
01855                         <span class="comment">//</span>
01856                         <span class="comment">//  Reset the current root to be an internal node</span>
01857                         <span class="comment">//</span>
01858 
01859                         CurrentTree-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a5">RTL_NTC_UNICODE_INTERNAL</a>;
01860                         CurrentTree-&gt;NextPrefixTree = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01861 
01862                         <span class="comment">//</span>
01863                         <span class="comment">//  Splay the tree and get the root</span>
01864                         <span class="comment">//</span>
01865 
01866                         Node = CONTAINING_RECORD(<a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(&amp;Node-&gt;Links), UNICODE_PREFIX_TABLE_ENTRY, Links);
01867 
01868                         <span class="comment">//</span>
01869                         <span class="comment">//  Set the new root's node type code and make it part of the</span>
01870                         <span class="comment">//  root tree list</span>
01871                         <span class="comment">//</span>
01872 
01873                         Node-&gt;NodeTypeCode = <a class="code" href="../../d4/d4/prefix_8c.html#a4">RTL_NTC_UNICODE_ROOT</a>;
01874                         PreviousTree-&gt;NextPrefixTree = Node;
01875                         Node-&gt;NextPrefixTree = NextTree;
01876                     }
01877 
01878                     <span class="comment">//</span>
01879                     <span class="comment">//  Now return the root to our caller</span>
01880                     <span class="comment">//</span>
01881 
01882                     <span class="keywordflow">return</span> Node;
01883                 }
01884 
01885                 <span class="comment">//</span>
01886                 <span class="comment">//  The caller wants an exact match so search the case match</span>
01887                 <span class="comment">//  until we find a complete match.  Get the first node</span>
01888                 <span class="comment">//</span>
01889 
01890                 Next = Node;
01891 
01892                 <span class="comment">//</span>
01893                 <span class="comment">//  Loop through the case match list checking to see if we</span>
01894                 <span class="comment">//  match case sensitive with anyone.</span>
01895                 <span class="comment">//</span>
01896 
01897                 <span class="keywordflow">do</span> {
01898 
01899                     <span class="comment">//</span>
01900                     <span class="comment">//  If we do match case sensitive then we found one</span>
01901                     <span class="comment">//  and we return it to our caller</span>
01902                     <span class="comment">//</span>
01903 
01904                     Comparison = <a class="code" href="../../d4/d4/prefix_8c.html#a15">CompareUnicodeStrings</a>( Next-&gt;Prefix,
01905                                                         FullName,
01906                                                         CaseInsensitiveIndex );
01907 
01908                     <span class="keywordflow">if</span> ((Comparison == <a class="code" href="../../d4/d4/prefix_8c.html#a25a10">IsEqual</a>) || (Comparison == <a class="code" href="../../d4/d4/prefix_8c.html#a25a9">IsPrefix</a>)) {
01909 
01910                         <span class="comment">//</span>
01911                         <span class="comment">//  We found a good one, so return it to our caller</span>
01912                         <span class="comment">//</span>
01913 
01914                         <span class="keywordflow">return</span> Next;
01915                     }
01916 
01917                     <span class="comment">//</span>
01918                     <span class="comment">//  Get the next case match record</span>
01919                     <span class="comment">//</span>
01920 
01921                     Next = Next-&gt;CaseMatch;
01922 
01923                     <span class="comment">//</span>
01924                     <span class="comment">//  And continue the loop until we reach the original</span>
01925                     <span class="comment">//  node again</span>
01926                     <span class="comment">//</span>
01927 
01928                 } <span class="keywordflow">while</span> ( Next != Node );
01929 
01930                 <span class="comment">//</span>
01931                 <span class="comment">//  We found a case blind prefix but the caller wants</span>
01932                 <span class="comment">//  case sensitive and we weren't able to find one of those</span>
01933                 <span class="comment">//  so we need to go on to the next tree, by breaking out</span>
01934                 <span class="comment">//  of the inner while-loop</span>
01935                 <span class="comment">//</span>
01936 
01937                 <span class="keywordflow">break</span>;
01938             }
01939         }
01940 
01941         <span class="comment">//</span>
01942         <span class="comment">//  This tree is done so now find the next tree</span>
01943         <span class="comment">//</span>
01944 
01945         PreviousTree = CurrentTree;
01946         CurrentTree = CurrentTree-&gt;NextPrefixTree;
01947     }
01948 
01949     <span class="comment">//</span>
01950     <span class="comment">//  We sesarched everywhere and didn't find a prefix so tell the</span>
01951     <span class="comment">//  caller none was found</span>
01952     <span class="comment">//</span>
01953 
01954     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01955 }
01956 
01957 
01958 PUNICODE_PREFIX_TABLE_ENTRY
<a name="l01959"></a><a class="code" href="../../d4/d4/prefix_8c.html#a24">01959</a> <a class="code" href="../../d4/d4/prefix_8c.html#a24">RtlNextUnicodePrefix</a> (
01960     IN PUNICODE_PREFIX_TABLE PrefixTable,
01961     IN BOOLEAN Restart
01962     )
01963 
01964 <span class="comment">/*++</span>
01965 <span class="comment"></span>
01966 <span class="comment">Routine Description:</span>
01967 <span class="comment"></span>
01968 <span class="comment">    This routine returns the next prefix entry stored in the prefix table</span>
01969 <span class="comment"></span>
01970 <span class="comment">Arguments:</span>
01971 <span class="comment"></span>
01972 <span class="comment">    PrefixTable - Supplies the prefix table to enumerate</span>
01973 <span class="comment"></span>
01974 <span class="comment">    Restart - Indicates if the enumeration should start over</span>
01975 <span class="comment"></span>
01976 <span class="comment">Return Value:</span>
01977 <span class="comment"></span>
01978 <span class="comment">    PPREFIX_TABLE_ENTRY - A pointer to the next prefix table entry if</span>
01979 <span class="comment">        one exists otherwise NULL</span>
01980 <span class="comment"></span>
01981 <span class="comment">--*/</span>
01982 
01983 {
01984     PUNICODE_PREFIX_TABLE_ENTRY Node;
01985 
01986     PRTL_SPLAY_LINKS Links;
01987 
01988     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01989 
01990     <span class="comment">//</span>
01991     <span class="comment">//  See if we are restarting the sequence</span>
01992     <span class="comment">//</span>
01993 
01994     <span class="keywordflow">if</span> (Restart || (<a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;LastNextEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01995 
01996         <span class="comment">//</span>
01997         <span class="comment">//  we are restarting the sequence so locate the first entry</span>
01998         <span class="comment">//  in the first tree</span>
01999         <span class="comment">//</span>
02000 
02001         Node = <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;NextPrefixTree;
02002 
02003         <span class="comment">//</span>
02004         <span class="comment">//  Make sure we've pointing at a prefix tree</span>
02005         <span class="comment">//</span>
02006 
02007         <span class="keywordflow">if</span> (Node-&gt;NodeTypeCode == <a class="code" href="../../d4/d4/prefix_8c.html#a3">RTL_NTC_UNICODE_PREFIX_TABLE</a>) {
02008 
02009             <span class="comment">//</span>
02010             <span class="comment">//  No we aren't so the table must be empty</span>
02011             <span class="comment">//</span>
02012 
02013             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02014         }
02015 
02016         <span class="comment">//</span>
02017         <span class="comment">//  Find the first node in the tree</span>
02018         <span class="comment">//</span>
02019 
02020         Links = &amp;Node-&gt;Links;
02021 
02022         <span class="keywordflow">while</span> (RtlLeftChild(Links) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02023 
02024             Links = RtlLeftChild(Links);
02025         }
02026 
02027         <span class="comment">//</span>
02028         <span class="comment">//  Set it as our the node we're returning</span>
02029         <span class="comment">//</span>
02030 
02031         Node = CONTAINING_RECORD( Links, UNICODE_PREFIX_TABLE_ENTRY, Links);
02032 
02033     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;LastNextEntry-&gt;CaseMatch-&gt;NodeTypeCode == <a class="code" href="../../d4/d4/prefix_8c.html#a6">RTL_NTC_UNICODE_CASE_MATCH</a>) {
02034 
02035         <span class="comment">//</span>
02036         <span class="comment">//  The last node has a case match that we should be returning</span>
02037         <span class="comment">//  this time around</span>
02038         <span class="comment">//</span>
02039 
02040         Node = <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;LastNextEntry-&gt;CaseMatch;
02041 
02042     } <span class="keywordflow">else</span> {
02043 
02044         <span class="comment">//</span>
02045         <span class="comment">//  Move over the last node returned by the case match link, this</span>
02046         <span class="comment">//  will enable us to finish off the last case match node if there</span>
02047         <span class="comment">//  was one, and go to the next internal/root node. If this node</span>
02048         <span class="comment">//  does not have a case match then we simply circle back to ourselves</span>
02049         <span class="comment">//</span>
02050 
02051         Node = <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;LastNextEntry-&gt;CaseMatch;
02052 
02053         <span class="comment">//</span>
02054         <span class="comment">//  Find the successor for the last node we returned</span>
02055         <span class="comment">//</span>
02056 
02057         Links = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(&amp;Node-&gt;Links);
02058 
02059         <span class="comment">//</span>
02060         <span class="comment">//  If links is null then we've exhausted this tree and need to</span>
02061         <span class="comment">//  the the next tree to use</span>
02062         <span class="comment">//</span>
02063 
02064         <span class="keywordflow">if</span> (Links == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02065 
02066             Links = &amp;<a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;LastNextEntry-&gt;Links;
02067 
02068             <span class="keywordflow">while</span> (!RtlIsRoot(Links)) {
02069 
02070                 Links = RtlParent(Links);
02071             }
02072 
02073             Node = CONTAINING_RECORD(Links, UNICODE_PREFIX_TABLE_ENTRY, Links);
02074 
02075             <span class="comment">//</span>
02076             <span class="comment">//  Now we've found the root see if there is another</span>
02077             <span class="comment">//  tree to enumerate</span>
02078             <span class="comment">//</span>
02079 
02080             Node = Node-&gt;NextPrefixTree;
02081 
02082             <span class="keywordflow">if</span> (Node-&gt;NameLength &lt;= 0) {
02083 
02084                 <span class="comment">//</span>
02085                 <span class="comment">//  We've run out of tree so tell our caller there</span>
02086                 <span class="comment">//  are no more</span>
02087                 <span class="comment">//</span>
02088 
02089                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02090             }
02091 
02092             <span class="comment">//</span>
02093             <span class="comment">//  We have another tree to go down</span>
02094             <span class="comment">//</span>
02095 
02096             Links = &amp;Node-&gt;Links;
02097 
02098             <span class="keywordflow">while</span> (RtlLeftChild(Links) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02099 
02100                 Links = RtlLeftChild(Links);
02101             }
02102         }
02103 
02104         <span class="comment">//</span>
02105         <span class="comment">//  Set it as our the node we're returning</span>
02106         <span class="comment">//</span>
02107 
02108         Node = CONTAINING_RECORD( Links, UNICODE_PREFIX_TABLE_ENTRY, Links);
02109     }
02110 
02111     <span class="comment">//</span>
02112     <span class="comment">//  Save node as the last next entry</span>
02113     <span class="comment">//</span>
02114 
02115     <a class="code" href="../../d4/d4/tprefix_8c.html#a10">PrefixTable</a>-&gt;LastNextEntry = Node;
02116 
02117     <span class="comment">//</span>
02118     <span class="comment">//  And return this entry to our caller</span>
02119     <span class="comment">//</span>
02120 
02121     <span class="keywordflow">return</span> Node;
02122 }
02123 
02124 
02125 CLONG
<a name="l02126"></a><a class="code" href="../../d4/d4/prefix_8c.html#a14">02126</a> <a class="code" href="../../d4/d4/prefix_8c.html#a14">ComputeUnicodeNameLength</a>(
02127     IN PUNICODE_STRING Name
02128     )
02129 
02130 <span class="comment">/*++</span>
02131 <span class="comment"></span>
02132 <span class="comment">Routine Description:</span>
02133 <span class="comment"></span>
02134 <span class="comment">    This routine counts the number of names appearing in the input string.</span>
02135 <span class="comment">    It does this by simply counting the number of backslashes in the string.</span>
02136 <span class="comment">    To handle ill-formed names (i.e., names that do not contain a backslash)</span>
02137 <span class="comment">    this routine really returns the number of backslashes plus 1.</span>
02138 <span class="comment"></span>
02139 <span class="comment">Arguments:</span>
02140 <span class="comment"></span>
02141 <span class="comment">    Name - Supplies the input name to examine</span>
02142 <span class="comment"></span>
02143 <span class="comment">Returns Value:</span>
02144 <span class="comment"></span>
02145 <span class="comment">    CLONG - the number of names in the input string</span>
02146 <span class="comment"></span>
02147 <span class="comment">--*/</span>
02148 
02149 {
02150     WCHAR UnicodeBackSlash = <span class="charliteral">'\\'</span>;
02151     ULONG NameLength;
02152     ULONG i;
02153     ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
02154 
02155     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02156 
02157     <span class="comment">//</span>
02158     <span class="comment">//  Save the name length, this should make the compiler be able to</span>
02159     <span class="comment">//  optimize not having to reload the length each time</span>
02160     <span class="comment">//</span>
02161 
02162     NameLength = (ULONG)<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length/2;
02163 
02164     <span class="comment">//</span>
02165     <span class="comment">//  Now loop through the input string counting back slashes</span>
02166     <span class="comment">//</span>
02167 
02168     <span class="keywordflow">for</span> (i = 0, <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 1; i &lt; (ULONG)NameLength - 1; i += 1) {
02169 
02170         <span class="comment">//</span>
02171         <span class="comment">//  check for a back slash</span>
02172         <span class="comment">//</span>
02173 
02174         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i] == UnicodeBackSlash) {
02175 
02176             <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1;
02177         }
02178     }
02179 
02180     <span class="comment">//</span>
02181     <span class="comment">//  return the number of back slashes we found</span>
02182     <span class="comment">//</span>
02183 
02184     <span class="comment">//DbgPrint("ComputeUnicodeNameLength(%Z) = %x\n", Name, Count);</span>
02185 
02186     <span class="keywordflow">return</span> <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
02187 }
02188 
02189 
02190 <a class="code" href="../../d4/d4/prefix_8c.html#a7">COMPARISON</a>
<a name="l02191"></a><a class="code" href="../../d4/d4/prefix_8c.html#a15">02191</a> <a class="code" href="../../d4/d4/prefix_8c.html#a15">CompareUnicodeStrings</a> (
02192     IN PUNICODE_STRING Prefix,
02193     IN PUNICODE_STRING Name,
02194     IN ULONG CaseInsensitiveIndex
02195     )
02196 
02197 <span class="comment">/*++</span>
02198 <span class="comment"></span>
02199 <span class="comment">Routine Description:</span>
02200 <span class="comment"></span>
02201 <span class="comment">    This routine takes a prefix string and a full name string and determines</span>
02202 <span class="comment">    if the prefix string is a proper prefix of the name string (case sensitive)</span>
02203 <span class="comment"></span>
02204 <span class="comment">Arguments:</span>
02205 <span class="comment"></span>
02206 <span class="comment">    Prefix - Supplies the input prefix string</span>
02207 <span class="comment"></span>
02208 <span class="comment">    Name - Supplies the full name input string</span>
02209 <span class="comment"></span>
02210 <span class="comment">    CaseInsensitiveIndex - Indicates the wchar index at which to do a case</span>
02211 <span class="comment">        insensitive search.  All characters before the index are searched</span>
02212 <span class="comment">        case sensitive and all characters at and after the index are searched</span>
02213 <span class="comment"></span>
02214 <span class="comment">Return Value:</span>
02215 <span class="comment"></span>
02216 <span class="comment">    COMPARISON - returns</span>
02217 <span class="comment"></span>
02218 <span class="comment">        IsLessThan    if Prefix &lt; Name lexicalgraphically,</span>
02219 <span class="comment">        IsPrefix      if Prefix is a proper prefix of Name</span>
02220 <span class="comment">        IsEqual       if Prefix is equal to Name, and</span>
02221 <span class="comment">        IsGreaterThan if Prefix &gt; Name lexicalgraphically</span>
02222 <span class="comment"></span>
02223 <span class="comment">--*/</span>
02224 
02225 {
02226     WCHAR UnicodeBackSlash = <span class="charliteral">'\\'</span>;
02227     ULONG PrefixLength;
02228     ULONG NameLength;
02229     ULONG MinLength;
02230     ULONG i;
02231 
02232     WCHAR PrefixChar;
02233     WCHAR NameChar;
02234 
02235     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02236 
02237     <span class="comment">//DbgPrint("CompareUnicodeStrings(\"%Z\", \"%Z\") = ", Prefix, Name);</span>
02238 
02239     <span class="comment">//</span>
02240     <span class="comment">//  Save the length of the prefix and name string, this should allow</span>
02241     <span class="comment">//  the compiler to not need to reload the length through a pointer every</span>
02242     <span class="comment">//  time we need their values</span>
02243     <span class="comment">//</span>
02244 
02245     PrefixLength = (ULONG)Prefix-&gt;Length/2;
02246     NameLength = (ULONG)<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length/2;
02247 
02248     <span class="comment">//</span>
02249     <span class="comment">//  Special case the situation where the prefix string is simply "\" and</span>
02250     <span class="comment">//  the name starts with an "\"</span>
02251     <span class="comment">//</span>
02252 
02253     <span class="keywordflow">if</span> ((PrefixLength == 1) &amp;&amp; (Prefix-&gt;Buffer[0] == UnicodeBackSlash) &amp;&amp;
02254         (NameLength &gt; 1) &amp;&amp; (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[0] == UnicodeBackSlash)) {
02255         <span class="comment">//DbgPrint("IsPrefix\n");</span>
02256         <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a9">IsPrefix</a>;
02257     }
02258 
02259     <span class="comment">//</span>
02260     <span class="comment">//  Figure out the minimum of the two lengths</span>
02261     <span class="comment">//</span>
02262 
02263     MinLength = (PrefixLength &lt; NameLength ? PrefixLength : NameLength);
02264 
02265     <span class="comment">//</span>
02266     <span class="comment">//  Loop through looking at all of the characters in both strings</span>
02267     <span class="comment">//  testing for equalilty.  First to the CaseSensitive part, then the</span>
02268     <span class="comment">//  CaseInsensitive part.</span>
02269     <span class="comment">//</span>
02270 
02271     <span class="keywordflow">if</span> (CaseInsensitiveIndex &gt; MinLength) {
02272 
02273         CaseInsensitiveIndex = MinLength;
02274     }
02275 
02276     <span class="comment">//</span>
02277     <span class="comment">//  CaseSensitive compare</span>
02278     <span class="comment">//</span>
02279 
02280     <span class="keywordflow">for</span> (i = 0; i &lt; CaseInsensitiveIndex; i += 1) {
02281 
02282         PrefixChar = Prefix-&gt;Buffer[i];
02283         NameChar   = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i];
02284 
02285         <span class="keywordflow">if</span> (PrefixChar != NameChar) {
02286 
02287             <span class="keywordflow">break</span>;
02288         }
02289     }
02290 
02291     <span class="comment">//</span>
02292     <span class="comment">//  If we didn't break out of the above loop, do the</span>
02293     <span class="comment">//  CaseInsensitive compare.</span>
02294     <span class="comment">//</span>
02295 
02296     <span class="keywordflow">if</span> (i == CaseInsensitiveIndex) {
02297 
02298         WCHAR *s1 = &amp;Prefix-&gt;Buffer[i];
02299         WCHAR *s2 = &amp;<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[i];
02300 
02301         <span class="keywordflow">for</span> (; i &lt; MinLength; i += 1) {
02302 
02303             PrefixChar = *s1++;
02304             NameChar = *s2++;
02305 
02306             <span class="keywordflow">if</span> (PrefixChar != NameChar) {
02307 
02308                 PrefixChar = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(PrefixChar);
02309                 NameChar   = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(NameChar);
02310 
02311                 <span class="keywordflow">if</span> (PrefixChar != NameChar) {
02312                     <span class="keywordflow">break</span>;
02313                 }
02314             }
02315         }
02316     }
02317 
02318     <span class="comment">//</span>
02319     <span class="comment">//  If we broke out of the above loop because of a mismatch, determine</span>
02320     <span class="comment">//  the result of the comparison.</span>
02321     <span class="comment">//</span>
02322 
02323     <span class="keywordflow">if</span> (i &lt; MinLength) {
02324 
02325         <span class="comment">//</span>
02326         <span class="comment">//  We also need to treat "\" as less than all other characters, so</span>
02327         <span class="comment">//  if the char is a "\" we'll drop it down to a value of zero.</span>
02328         <span class="comment">//</span>
02329 
02330         <span class="keywordflow">if</span> (PrefixChar == UnicodeBackSlash) {
02331 
02332             <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a8">IsLessThan</a>;
02333         }
02334 
02335         <span class="keywordflow">if</span> (NameChar == UnicodeBackSlash) {
02336 
02337             <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a11">IsGreaterThan</a>;
02338         }
02339 
02340         <span class="comment">//</span>
02341         <span class="comment">//  Now compare the characters</span>
02342         <span class="comment">//</span>
02343 
02344         <span class="keywordflow">if</span> (PrefixChar &lt; NameChar) {
02345 
02346             <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a8">IsLessThan</a>;
02347 
02348         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PrefixChar &gt; NameChar) {
02349 
02350             <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a11">IsGreaterThan</a>;
02351         }
02352     }
02353 
02354     <span class="comment">//</span>
02355     <span class="comment">//  They match upto the minimum length so now figure out the largest string</span>
02356     <span class="comment">//  and see if one is a proper prefix of the other</span>
02357     <span class="comment">//</span>
02358 
02359     <span class="keywordflow">if</span> (PrefixLength &lt; NameLength) {
02360 
02361         <span class="comment">//</span>
02362         <span class="comment">//  The prefix string is shorter so if it is a proper prefix we</span>
02363         <span class="comment">//  return prefix otherwise we return less than (e.g., "\a" &lt; "\ab")</span>
02364         <span class="comment">//</span>
02365 
02366         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[PrefixLength] == UnicodeBackSlash) {
02367 
02368             <span class="comment">//DbgPrint("IsPrefix\n");</span>
02369 
02370             <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a9">IsPrefix</a>;
02371 
02372         } <span class="keywordflow">else</span> {
02373 
02374             <span class="comment">//DbgPrint("IsLessThan\n");</span>
02375 
02376             <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a8">IsLessThan</a>;
02377         }
02378 
02379     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PrefixLength &gt; NameLength) {
02380 
02381         <span class="comment">//</span>
02382         <span class="comment">//  The Prefix string is longer so we say that the prefix is</span>
02383         <span class="comment">//  greater than the name (e.g., "\ab" &gt; "\a")</span>
02384         <span class="comment">//</span>
02385 
02386         <span class="comment">//DbgPrint("IsGreaterThan\n");</span>
02387 
02388         <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a11">IsGreaterThan</a>;
02389 
02390     } <span class="keywordflow">else</span> {
02391 
02392         <span class="comment">//</span>
02393         <span class="comment">//  They lengths are equal so the strings are equal</span>
02394         <span class="comment">//</span>
02395 
02396         <span class="comment">//DbgPrint("IsEqual\n");</span>
02397 
02398         <span class="keywordflow">return</span> <a class="code" href="../../d4/d4/prefix_8c.html#a25a10">IsEqual</a>;
02399     }
02400 }
02401 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:25 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
