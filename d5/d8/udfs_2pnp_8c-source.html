<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: pnp.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>pnp.c</h1><a href="../../d4/d9/udfs_2pnp_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1997  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    Pnp.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the Plug and Play routines for UDFS called by</span>
00012 <span class="comment">    the dispatch driver.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Dan Lovinger    [DanLo]     23-Jul-1997</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "UdfProcs.h"</span>
00023 
00024 <span class="comment">//</span>
00025 <span class="comment">//  The Bug check file id for this module</span>
00026 <span class="comment">//</span>
00027 
<a name="l00028"></a><a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a0">00028</a> <span class="preprocessor">#define BugCheckFileId                   (UDFS_BUG_CHECK_PNP)</span>
00029 <span class="preprocessor"></span>
00030 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00031 <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a1">UdfPnpQueryRemove</a> (
00032     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00033     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00034     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
00035     );
00036 
00037 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00038 <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a2">UdfPnpRemove</a> (
00039     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00040     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00041     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
00042     );
00043 
00044 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00045 <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a3">UdfPnpSurpriseRemove</a> (
00046     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00047     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00048     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
00049     );
00050 
00051 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00052 <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a4">UdfPnpCancelRemove</a> (
00053     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00054     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00055     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
00056     );
00057 
00058 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00059 <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a5">UdfPnpCompletionRoutine</a> (
00060     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00061     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00062     IN PVOID Contxt
00063     );
00064 
00065 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCommonPnp)</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfPnpCancelRemove)</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfPnpQueryRemove)</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfPnpRemove)</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfPnpSurpriseRemove)</span>
00071 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00072 <span class="preprocessor"></span>
00073 
00074 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00075"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a258">00075</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a258">UdfCommonPnp</a> (
00076     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00077     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00078     )
00079 
00080 <span class="comment">/*++</span>
00081 <span class="comment"></span>
00082 <span class="comment">Routine Description:</span>
00083 <span class="comment"></span>
00084 <span class="comment">    This is the common routine for doing PnP operations called</span>
00085 <span class="comment">    by both the fsd and fsp threads</span>
00086 <span class="comment"></span>
00087 <span class="comment">Arguments:</span>
00088 <span class="comment"></span>
00089 <span class="comment">    Irp - Supplies the Irp to process</span>
00090 <span class="comment"></span>
00091 <span class="comment">Return Value:</span>
00092 <span class="comment"></span>
00093 <span class="comment">    NTSTATUS - The return status for the operation</span>
00094 <span class="comment"></span>
00095 <span class="comment">--*/</span>
00096 
00097 {
00098     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00099     
00100     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
00101 
00102     <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">PVOLUME_DEVICE_OBJECT</a> OurDeviceObject;
00103     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
00104 
00105     <span class="comment">//</span>
00106     <span class="comment">//  Get the current Irp stack location.</span>
00107     <span class="comment">//</span>
00108 
00109     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00110 
00111     <span class="comment">//</span>
00112     <span class="comment">//  Find our Vcb.  This is tricky since we have no file object in the Irp.</span>
00113     <span class="comment">//</span>
00114 
00115     OurDeviceObject = (<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">PVOLUME_DEVICE_OBJECT</a>) IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a>;
00116 
00117     <span class="comment">//</span>
00118     <span class="comment">//  Make sure this device object really is big enough to be a volume device</span>
00119     <span class="comment">//  object.  If it isn't, we need to get out before we try to reference some</span>
00120     <span class="comment">//  field that takes us past the end of an ordinary device object.</span>
00121     <span class="comment">//</span>
00122     
00123     <span class="keywordflow">if</span> (OurDeviceObject-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o0">DeviceObject</a>.<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o1">Size</a> != <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">VOLUME_DEVICE_OBJECT</a>) ||
00124         <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a6">NodeType</a>( &amp;OurDeviceObject-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o5">Vcb</a> ) != <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a2">UDFS_NTC_VCB</a>) {
00125         
00126         <span class="comment">//</span>
00127         <span class="comment">//  We were called with something we don't understand.</span>
00128         <span class="comment">//</span>
00129         
00130         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
00131         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00132         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00133     }
00134 
00135     <span class="comment">//</span>
00136     <span class="comment">//  Force all PnP operations to be synchronous.</span>
00137     <span class="comment">//</span>
00138 
00139     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> );
00140 
00141     Vcb = &amp;OurDeviceObject-&gt;<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o5">Vcb</a>;
00142 
00143     <span class="comment">//</span>
00144     <span class="comment">//  Case on the minor code.</span>
00145     <span class="comment">//</span>
00146     
00147     <span class="keywordflow">switch</span> ( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> ) {
00148 
00149         <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a66">IRP_MN_QUERY_REMOVE_DEVICE</a>:
00150             
00151             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a1">UdfPnpQueryRemove</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, Vcb );
00152             <span class="keywordflow">break</span>;
00153         
00154         <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a87">IRP_MN_SURPRISE_REMOVAL</a>:
00155         
00156             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a3">UdfPnpSurpriseRemove</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, Vcb );
00157             <span class="keywordflow">break</span>;
00158 
00159         <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a67">IRP_MN_REMOVE_DEVICE</a>:
00160 
00161             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a2">UdfPnpRemove</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, Vcb );
00162             <span class="keywordflow">break</span>;
00163 
00164         <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a68">IRP_MN_CANCEL_REMOVE_DEVICE</a>:
00165     
00166             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a4">UdfPnpCancelRemove</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, Vcb );
00167             <span class="keywordflow">break</span>;
00168 
00169         <span class="keywordflow">default</span>:
00170     
00171             <span class="comment">//</span>
00172             <span class="comment">//  Just pass the IRP on.  As we do not need to be in the</span>
00173             <span class="comment">//  way on return, ellide ourselves out of the stack.</span>
00174             <span class="comment">//</span>
00175             
00176             <a class="code" href="../../d0/d5/io_8h.html#a240">IoSkipCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00177     
00178             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00179             
00180             <span class="comment">//</span>
00181             <span class="comment">//  Cleanup our Irp Context.  The driver has completed the Irp.</span>
00182             <span class="comment">//</span>
00183         
00184             <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, STATUS_SUCCESS );
00185             
00186             <span class="keywordflow">break</span>;
00187     }
00188         
00189     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00190 }
00191 
00192 
00193 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00194"></a><a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a1">00194</a> <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a1">UdfPnpQueryRemove</a> (
00195     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00196     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00197     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
00198     )
00199 
00200 <span class="comment">/*++</span>
00201 <span class="comment"></span>
00202 <span class="comment">Routine Description:</span>
00203 <span class="comment"></span>
00204 <span class="comment">    This routine handles the PnP query remove operation.  The filesystem</span>
00205 <span class="comment">    is responsible for answering whether there are any reasons it sees</span>
00206 <span class="comment">    that the volume can not go away (and the device removed).  Initiation</span>
00207 <span class="comment">    of the dismount begins when we answer yes to this question.</span>
00208 <span class="comment">    </span>
00209 <span class="comment">    Query will be followed by a Cancel or Remove.</span>
00210 <span class="comment"></span>
00211 <span class="comment">Arguments:</span>
00212 <span class="comment"></span>
00213 <span class="comment">    Irp - Supplies the Irp to process</span>
00214 <span class="comment">    </span>
00215 <span class="comment">    Vcb - Supplies the volume being queried.</span>
00216 <span class="comment"></span>
00217 <span class="comment">Return Value:</span>
00218 <span class="comment"></span>
00219 <span class="comment">    NTSTATUS - The return status for the operation</span>
00220 <span class="comment"></span>
00221 <span class="comment">--*/</span>
00222 
00223 {
00224     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00225     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00226     BOOLEAN VcbPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00227 
00228     <span class="comment">//</span>
00229     <span class="comment">//  Having said yes to a QUERY, any communication with the</span>
00230     <span class="comment">//  underlying storage stack is undefined (and may block)</span>
00231     <span class="comment">//  until the bounding CANCEL or REMOVE is sent.</span>
00232     <span class="comment">//</span>
00233 
00234     <span class="comment">//</span>
00235     <span class="comment">//  Acquire the global resource so that we can try to vaporize</span>
00236     <span class="comment">//  the volume, and the vcb resource itself.</span>
00237     <span class="comment">//</span>
00238     
00239     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00240 
00241     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a190">UdfLockVolumeInternal</a>( IrpContext, Vcb, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00242 
00243     <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00244     <a class="code" href="../../d3/d8/udfprocs_8h.html#a72">UdfAcquireUdfData</a>( IrpContext );
00245     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00246 
00247     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00248 
00249         <span class="comment">//</span>
00250         <span class="comment">//  We need to pass this down before starting the dismount, which</span>
00251         <span class="comment">//  could disconnect us immediately from the stack.</span>
00252         <span class="comment">//</span>
00253         
00254         <span class="comment">//</span>
00255         <span class="comment">//  Get the next stack location, and copy over the stack location</span>
00256         <span class="comment">//</span>
00257 
00258         <a class="code" href="../../d0/d5/io_8h.html#a239">IoCopyCurrentIrpStackLocationToNext</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00259 
00260         <span class="comment">//</span>
00261         <span class="comment">//  Set up the completion routine</span>
00262         <span class="comment">//</span>
00263     
00264         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00265         <a class="code" href="../../d0/d5/io_8h.html#a237">IoSetCompletionRoutine</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00266                                 <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a5">UdfPnpCompletionRoutine</a>,
00267                                 &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00268                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00269                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00270                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00271 
00272         <span class="comment">//</span>
00273         <span class="comment">//  Send the request and wait.</span>
00274         <span class="comment">//</span>
00275 
00276         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00277 
00278         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_PENDING) {
00279 
00280             <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00281                                    <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00282                                    <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00283                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00284                                    <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00285 
00286             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status;
00287         }
00288 
00289         <span class="comment">//</span>
00290         <span class="comment">//  Now if no one below us failed already, initiate the dismount</span>
00291         <span class="comment">//  on this volume, make it go away.  PnP needs to see our internal</span>
00292         <span class="comment">//  streams close and drop their references to the target device.</span>
00293         <span class="comment">//</span>
00294         <span class="comment">//  Since we were able to lock the volume, we are guaranteed to</span>
00295         <span class="comment">//  move this volume into dismount state and disconnect it from</span>
00296         <span class="comment">//  the underlying storage stack.  The force on our part is actually</span>
00297         <span class="comment">//  unnecesary, though complete.</span>
00298         <span class="comment">//</span>
00299         <span class="comment">//  What is not strictly guaranteed, though, is that the closes</span>
00300         <span class="comment">//  for the metadata streams take effect synchronously underneath</span>
00301         <span class="comment">//  of this call.  This would leave references on the target device</span>
00302         <span class="comment">//  even though we are disconnected!</span>
00303         <span class="comment">//</span>
00304 
00305         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00306             
00307             VcbPresent = <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">UdfCheckForDismount</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00308     
00309             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !VcbPresent || Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a> );
00310         }
00311     }
00312     
00313     <span class="comment">//</span>
00314     <span class="comment">//  Release the Vcb if it could still remain.</span>
00315     <span class="comment">//</span>
00316     <span class="comment">//  Note: if everything else succeeded and the Vcb is persistent because the</span>
00317     <span class="comment">//  internal streams did not vaporize, we really need to pend this IRP off on</span>
00318     <span class="comment">//  the side until the dismount is completed.  I can't think of a reasonable</span>
00319     <span class="comment">//  case (in UDFS) where this would actually happen, though it might still need</span>
00320     <span class="comment">//  to be implemented.</span>
00321     <span class="comment">//</span>
00322     <span class="comment">//  The reason this is the case is that handles/fileobjects place a reference</span>
00323     <span class="comment">//  on the device objects they overly.  In the filesystem case, these references</span>
00324     <span class="comment">//  are on our target devices.  PnP correcly thinks that if references remain</span>
00325     <span class="comment">//  on the device objects in the stack that someone has a handle, and that this</span>
00326     <span class="comment">//  counts as a reason to not succeed the query - even though every interrogated</span>
00327     <span class="comment">//  driver thinks that it is OK.</span>
00328     <span class="comment">//</span>
00329     
00330     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !(<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) &amp;&amp; VcbPresent &amp;&amp; Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a> != 0));
00331     
00332     <span class="keywordflow">if</span> (VcbPresent) {
00333 
00334         <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00335     }
00336 
00337     <a class="code" href="../../d3/d8/udfprocs_8h.html#a73">UdfReleaseUdfData</a>( IrpContext );
00338     
00339     <span class="comment">//</span>
00340     <span class="comment">//  Cleanup our IrpContext and complete the IRP if neccesary.</span>
00341     <span class="comment">//</span>
00342 
00343     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00344 
00345     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00346 }
00347 
00348 
00349 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00350"></a><a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a2">00350</a> <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a2">UdfPnpRemove</a> (
00351     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00352     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00353     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
00354     )
00355 
00356 <span class="comment">/*++</span>
00357 <span class="comment"></span>
00358 <span class="comment">Routine Description:</span>
00359 <span class="comment"></span>
00360 <span class="comment">    This routine handles the PnP remove operation.  This is our notification</span>
00361 <span class="comment">    that the underlying storage device for the volume we have is gone, and</span>
00362 <span class="comment">    an excellent indication that the volume will never reappear. The filesystem</span>
00363 <span class="comment">    is responsible for initiation or completion the dismount.</span>
00364 <span class="comment">    </span>
00365 <span class="comment">Arguments:</span>
00366 <span class="comment"></span>
00367 <span class="comment">    Irp - Supplies the Irp to process</span>
00368 <span class="comment">    </span>
00369 <span class="comment">    Vcb - Supplies the volume being removed.</span>
00370 <span class="comment"></span>
00371 <span class="comment">Return Value:</span>
00372 <span class="comment"></span>
00373 <span class="comment">    NTSTATUS - The return status for the operation</span>
00374 <span class="comment"></span>
00375 <span class="comment">--*/</span>
00376 
00377 {
00378     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00379     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00380     BOOLEAN VcbPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00381     
00382     <span class="comment">//</span>
00383     <span class="comment">//  REMOVE - a storage device is now gone.  We either got</span>
00384     <span class="comment">//  QUERY'd and said yes OR got a SURPRISE OR a storage</span>
00385     <span class="comment">//  stack failed to spin back up from a sleep/stop state</span>
00386     <span class="comment">//  (the only case in which this will be the first warning).</span>
00387     <span class="comment">//</span>
00388     <span class="comment">//  Note that it is entirely unlikely that we will be around</span>
00389     <span class="comment">//  for a REMOVE in the first two cases, as we try to intiate</span>
00390     <span class="comment">//  dismount.</span>
00391     <span class="comment">//</span>
00392     
00393     <span class="comment">//</span>
00394     <span class="comment">//  Acquire the global resource so that we can try to vaporize</span>
00395     <span class="comment">//  the volume, and the vcb resource itself.</span>
00396     <span class="comment">//</span>
00397     
00398     <a class="code" href="../../d3/d8/udfprocs_8h.html#a72">UdfAcquireUdfData</a>( IrpContext );
00399     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00400 
00401     <span class="comment">//</span>
00402     <span class="comment">//  The device will be going away.  Remove our lock and find</span>
00403     <span class="comment">//  out if we ever had one in the first place.</span>
00404     <span class="comment">//</span>
00405 
00406     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a191">UdfUnlockVolumeInternal</a>( IrpContext, Vcb, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00407 
00408     <span class="comment">//</span>
00409     <span class="comment">//  If the volume had not been locked, we must invalidate the</span>
00410     <span class="comment">//  volume to ensure it goes away properly.  The remove will</span>
00411     <span class="comment">//  succeed.</span>
00412     <span class="comment">//</span>
00413 
00414     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00415 
00416         <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
00417         
00418         <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> != <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>) {
00419             Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>;
00420         }
00421         
00422         <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00423         
00424         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00425     }
00426     
00427     <span class="comment">//</span>
00428     <span class="comment">//  We need to pass this down before starting the dismount, which</span>
00429     <span class="comment">//  could disconnect us immediately from the stack.</span>
00430     <span class="comment">//</span>
00431     
00432     <span class="comment">//</span>
00433     <span class="comment">//  Get the next stack location, and copy over the stack location</span>
00434     <span class="comment">//</span>
00435 
00436     <a class="code" href="../../d0/d5/io_8h.html#a239">IoCopyCurrentIrpStackLocationToNext</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00437 
00438     <span class="comment">//</span>
00439     <span class="comment">//  Set up the completion routine</span>
00440     <span class="comment">//</span>
00441 
00442     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00443     <a class="code" href="../../d0/d5/io_8h.html#a237">IoSetCompletionRoutine</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00444                             <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a5">UdfPnpCompletionRoutine</a>,
00445                             &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00446                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00447                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00448                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00449 
00450     <span class="comment">//</span>
00451     <span class="comment">//  Send the request and wait.</span>
00452     <span class="comment">//</span>
00453 
00454     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00455 
00456     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_PENDING) {
00457 
00458         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00459                                <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00460                                <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00461                                <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00462                                <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00463 
00464         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status;
00465     }
00466 
00467     <span class="comment">//</span>
00468     <span class="comment">//  Now make our dismount happen.  This may not vaporize the</span>
00469     <span class="comment">//  Vcb, of course, since there could be any number of handles</span>
00470     <span class="comment">//  outstanding if we were not preceeded by a QUERY.</span>
00471     <span class="comment">//</span>
00472     <span class="comment">//  PnP will take care of disconnecting this stack if we</span>
00473     <span class="comment">//  couldn't get off of it immediately.</span>
00474     <span class="comment">//</span>
00475 
00476     VcbPresent = <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">UdfCheckForDismount</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00477 
00478     <span class="comment">//</span>
00479     <span class="comment">//  Release the Vcb if it could still remain.</span>
00480     <span class="comment">//</span>
00481     
00482     <span class="keywordflow">if</span> (VcbPresent) {
00483 
00484         <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00485     }
00486 
00487     <a class="code" href="../../d3/d8/udfprocs_8h.html#a73">UdfReleaseUdfData</a>( IrpContext );
00488     
00489     <span class="comment">//</span>
00490     <span class="comment">//  Cleanup our IrpContext and complete the IRP.</span>
00491     <span class="comment">//</span>
00492 
00493     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00494 
00495     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00496 }
00497 
00498 
00499 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00500"></a><a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a3">00500</a> <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a3">UdfPnpSurpriseRemove</a> (
00501     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00502     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00503     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
00504     )
00505 
00506 <span class="comment">/*++</span>
00507 <span class="comment"></span>
00508 <span class="comment">Routine Description:</span>
00509 <span class="comment"></span>
00510 <span class="comment">    This routine handles the PnP surprise remove operation.  This is another</span>
00511 <span class="comment">    type of notification that the underlying storage device for the volume we</span>
00512 <span class="comment">    have is gone, and is excellent indication that the volume will never reappear.</span>
00513 <span class="comment">    The filesystem is responsible for initiation or completion the dismount.</span>
00514 <span class="comment">    </span>
00515 <span class="comment">    For the most part, only "real" drivers care about the distinction of a</span>
00516 <span class="comment">    surprise remove, which is a result of our noticing that a user (usually)</span>
00517 <span class="comment">    physically reached into the machine and pulled something out.</span>
00518 <span class="comment">    </span>
00519 <span class="comment">    Surprise will be followed by a Remove when all references have been shut down.</span>
00520 <span class="comment"></span>
00521 <span class="comment">Arguments:</span>
00522 <span class="comment"></span>
00523 <span class="comment">    Irp - Supplies the Irp to process</span>
00524 <span class="comment">    </span>
00525 <span class="comment">    Vcb - Supplies the volume being removed.</span>
00526 <span class="comment"></span>
00527 <span class="comment">Return Value:</span>
00528 <span class="comment"></span>
00529 <span class="comment">    NTSTATUS - The return status for the operation</span>
00530 <span class="comment"></span>
00531 <span class="comment">--*/</span>
00532 
00533 {
00534     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00535     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00536     BOOLEAN VcbPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00537     
00538     <span class="comment">//</span>
00539     <span class="comment">//  SURPRISE - a device was physically yanked away without</span>
00540     <span class="comment">//  any warning.  This means external forces.</span>
00541     <span class="comment">//</span>
00542     
00543     <a class="code" href="../../d3/d8/udfprocs_8h.html#a72">UdfAcquireUdfData</a>( IrpContext );
00544     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00545         
00546     <span class="comment">//</span>
00547     <span class="comment">//  Invalidate the volume right now.</span>
00548     <span class="comment">//</span>
00549     <span class="comment">//  The intent here is to make every subsequent operation</span>
00550     <span class="comment">//  on the volume fail and grease the rails toward dismount.</span>
00551     <span class="comment">//  By definition there is no going back from a SURPRISE.</span>
00552     <span class="comment">//</span>
00553         
00554     <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
00555     
00556     <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> != <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>) {
00557         Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>;
00558     }
00559     
00560     <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00561     
00562     <span class="comment">//</span>
00563     <span class="comment">//  We need to pass this down before starting the dismount, which</span>
00564     <span class="comment">//  could disconnect us immediately from the stack.</span>
00565     <span class="comment">//</span>
00566     
00567     <span class="comment">//</span>
00568     <span class="comment">//  Get the next stack location, and copy over the stack location</span>
00569     <span class="comment">//</span>
00570 
00571     <a class="code" href="../../d0/d5/io_8h.html#a239">IoCopyCurrentIrpStackLocationToNext</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00572 
00573     <span class="comment">//</span>
00574     <span class="comment">//  Set up the completion routine</span>
00575     <span class="comment">//</span>
00576 
00577     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00578     <a class="code" href="../../d0/d5/io_8h.html#a237">IoSetCompletionRoutine</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00579                             <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a5">UdfPnpCompletionRoutine</a>,
00580                             &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00581                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00582                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00583                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00584 
00585     <span class="comment">//</span>
00586     <span class="comment">//  Send the request and wait.</span>
00587     <span class="comment">//</span>
00588 
00589     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00590 
00591     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_PENDING) {
00592 
00593         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00594                                <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00595                                <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00596                                <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00597                                <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00598 
00599         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status;
00600     }
00601     
00602     <span class="comment">//</span>
00603     <span class="comment">//  Now make our dismount happen.  This may not vaporize the</span>
00604     <span class="comment">//  Vcb, of course, since there could be any number of handles</span>
00605     <span class="comment">//  outstanding since this is an out of band notification.</span>
00606     <span class="comment">//</span>
00607 
00608     VcbPresent = <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">UdfCheckForDismount</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00609     
00610     <span class="comment">//</span>
00611     <span class="comment">//  Release the Vcb if it could still remain.</span>
00612     <span class="comment">//</span>
00613     
00614     <span class="keywordflow">if</span> (VcbPresent) {
00615 
00616         <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00617     }
00618 
00619     <a class="code" href="../../d3/d8/udfprocs_8h.html#a73">UdfReleaseUdfData</a>( IrpContext );
00620     
00621     <span class="comment">//</span>
00622     <span class="comment">//  Cleanup our IrpContext and complete the IRP.</span>
00623     <span class="comment">//</span>
00624 
00625     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00626 
00627     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00628 }
00629 
00630 
00631 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00632"></a><a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a4">00632</a> <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a4">UdfPnpCancelRemove</a> (
00633     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00634     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00635     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
00636     )
00637 
00638 <span class="comment">/*++</span>
00639 <span class="comment"></span>
00640 <span class="comment">Routine Description:</span>
00641 <span class="comment"></span>
00642 <span class="comment">    This routine handles the PnP cancel remove operation.  This is our</span>
00643 <span class="comment">    notification that a previously proposed remove (query) was eventually</span>
00644 <span class="comment">    vetoed by a component.  The filesystem is responsible for cleaning up</span>
00645 <span class="comment">    and getting ready for more IO.</span>
00646 <span class="comment">    </span>
00647 <span class="comment">Arguments:</span>
00648 <span class="comment"></span>
00649 <span class="comment">    Irp - Supplies the Irp to process</span>
00650 <span class="comment">    </span>
00651 <span class="comment">    Vcb - Supplies the volume being removed.</span>
00652 <span class="comment"></span>
00653 <span class="comment">Return Value:</span>
00654 <span class="comment"></span>
00655 <span class="comment">    NTSTATUS - The return status for the operation</span>
00656 <span class="comment"></span>
00657 <span class="comment">--*/</span>
00658 
00659 {
00660     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00661 
00662     <span class="comment">//</span>
00663     <span class="comment">//  CANCEL - a previous QUERY has been rescinded as a result</span>
00664     <span class="comment">//  of someone vetoing.  Since PnP cannot figure out who may</span>
00665     <span class="comment">//  have gotten the QUERY (think about it: stacked drivers),</span>
00666     <span class="comment">//  we must expect to deal with getting a CANCEL without having</span>
00667     <span class="comment">//  seen the QUERY.</span>
00668     <span class="comment">//</span>
00669     <span class="comment">//  For UDFS, this is quite easy.  In fact, we can't get a</span>
00670     <span class="comment">//  CANCEL if the underlying drivers succeeded the QUERY since</span>
00671     <span class="comment">//  we disconnect the Vpb on our dismount initiation.  This is</span>
00672     <span class="comment">//  actually pretty important because if PnP could get to us</span>
00673     <span class="comment">//  after the disconnect we'd be thoroughly unsynchronized</span>
00674     <span class="comment">//  with respect to the Vcb getting torn apart - merely referencing</span>
00675     <span class="comment">//  the volume device object is insufficient to keep us intact.</span>
00676     <span class="comment">//</span>
00677     
00678     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00679     
00680     <span class="comment">//</span>
00681     <span class="comment">//  Unlock the volume.  This is benign if we never had seen</span>
00682     <span class="comment">//  a QUERY.</span>
00683     <span class="comment">//</span>
00684 
00685     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d3/d8/udfprocs_8h.html#a191">UdfUnlockVolumeInternal</a>( IrpContext, Vcb, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00686 
00687     <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00688 
00689     <span class="comment">//</span>
00690     <span class="comment">//  Send the request.  The underlying driver will complete the</span>
00691     <span class="comment">//  IRP.  Since we don't need to be in the way, simply ellide</span>
00692     <span class="comment">//  ourselves out of the IRP stack.</span>
00693     <span class="comment">//</span>
00694 
00695     <a class="code" href="../../d0/d5/io_8h.html#a240">IoSkipCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00696 
00697     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00698 
00699     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, STATUS_SUCCESS );
00700 
00701     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00702 }
00703 
00704 
00705 <span class="comment">//</span>
00706 <span class="comment">//  Local support routine</span>
00707 <span class="comment">//</span>
00708 
00709 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00710"></a><a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a5">00710</a> <a class="code" href="../../d4/d9/udfs_2pnp_8c.html#a5">UdfPnpCompletionRoutine</a> (
00711     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00712     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00713     IN PVOID Contxt
00714     )
00715 {
00716     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) Contxt;
00717 
00718     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00719 
00720     <span class="keywordflow">return</span> STATUS_MORE_PROCESSING_REQUIRED;
00721 
00722     UNREFERENCED_PARAMETER( DeviceObject );
00723     UNREFERENCED_PARAMETER( Contxt );
00724 }
00725 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:15 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
