<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: handtabl.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>handtabl.c</h1><a href="../../d4/d8/handtabl_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/****************************** Module Header ******************************\</span>
00002 <span class="comment">* Module Name: handtabl.c</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 1985 - 1999, Microsoft Corporation</span>
00005 <span class="comment">*</span>
00006 <span class="comment">* Implements the USER handle table.</span>
00007 <span class="comment">*</span>
00008 <span class="comment">* 01-13-92 ScottLu      Created.</span>
00009 <span class="comment">\***************************************************************************/</span>
00010 
00011 <span class="preprocessor">#include "<a class="code" href="../../d0/d4/w32_2ntuser_2kernel_2precomp_8h.html">precomp.h</a>"</span>
00012 <span class="preprocessor">#pragma hdrstop</span>
00013 <span class="preprocessor"></span>
00014 <span class="preprocessor">#pragma alloc_text(INIT, HMInitHandleTable)</span>
00015 <span class="preprocessor"></span>
00016 <span class="preprocessor">#if DBG</span>
00017 <span class="preprocessor"></span>
00018 <span class="preprocessor">#define HTIENTRY(szObjectType, structName, fnDestroy, dwAllocTag, bObjectCreateFlags) \</span>
00019 <span class="preprocessor">    {szObjectType, sizeof(structName), (FnDestroyUserObject)fnDestroy, (CONST DWORD)dwAllocTag, (CONST BYTE)(bObjectCreateFlags)}</span>
00020 <span class="preprocessor"></span>
00021 <span class="preprocessor">#else // DBG</span>
00022 <span class="preprocessor"></span>
<a name="l00023"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a0">00023</a> <span class="preprocessor">#define HTIENTRY(szObjectType, structName, fnDestroy, dwAllocTag, bObjectCreateFlags) \</span>
00024 <span class="preprocessor">    {(FnDestroyUserObject)fnDestroy, (CONST DWORD)dwAllocTag, (CONST BYTE)(bObjectCreateFlags)}</span>
00025 <span class="preprocessor"></span>
00026 <span class="preprocessor">#endif // DBG</span>
00027 <span class="preprocessor"></span>
<a name="l00028"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a9">00028</a> <span class="keywordtype">void</span> <a class="code" href="../../d4/d8/handtabl_8c.html#a9">HMNullFnDestroy</a>(PVOID pobj)
00029 {
00030     RIPMSG1(RIP_WARNING, <span class="stringliteral">"HM: No clean up function for %#p"</span>, pobj);
00031     <a class="code" href="../../d4/d1/userk_8h.html#a972">HMDestroyObject</a>(pobj);
00032     <span class="keywordflow">return</span>;
00033 }
00034 <span class="comment">/***************************************************************************\</span>
00035 <span class="comment">*</span>
00036 <span class="comment">* Table of user objects statistics.  Used by userkdx.dumhmgr debugger extension</span>
00037 <span class="comment">*</span>
00038 <span class="comment">\***************************************************************************/</span>
00039 
00040 <span class="preprocessor">#if DBG</span>
00041 <span class="preprocessor"></span>
00042 <span class="comment">/*</span>
00043 <span class="comment"> * Note that we need to statically initialize gaPrevhti so that it is</span>
00044 <span class="comment"> * included during the link phase. It is not refered to anywher in win32k.sys,</span>
00045 <span class="comment"> * only in userkdx.dll, so it will be optimized out in the link phase otherwise.</span>
00046 <span class="comment"> * Marking it volatile did not seem to help.</span>
00047 <span class="comment"> */</span>
00048 
00049 <a class="code" href="../../d1/d3/structtagPERFINFO.html">PERFHANDLEINFO</a> gaPerfhti[<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a254">TYPE_CTYPES</a>] = {0};  <span class="comment">/* stores current counts */</span>
00050 <a class="code" href="../../d1/d3/structtagPERFINFO.html">PERFHANDLEINFO</a> gaPrevhti[<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a254">TYPE_CTYPES</a>] = {0};  <span class="comment">/* stores previous counts */</span>
00051 
00052 <span class="preprocessor">#endif // DBG</span>
00053 <span class="preprocessor"></span>
00054 <span class="comment">/***************************************************************************\</span>
00055 <span class="comment">*</span>
00056 <span class="comment">* Table of handle type information.</span>
00057 <span class="comment">*</span>
00058 <span class="comment">* Desktop and Shared Heap objects can't be tagged as yet</span>
00059 <span class="comment">* (TAG_WINDOW is bogus for heap windows, but not for desktop and other</span>
00060 <span class="comment">* windows allocated in pool).</span>
00061 <span class="comment">*</span>
00062 <span class="comment">* WARNING: Keep it in sync with aszTypeNames table from ntuser\kdexts\userexts.c</span>
00063 <span class="comment">*</span>
00064 <span class="comment">* All HM objects must start with a HEAD strucutre. In addition:</span>
00065 <span class="comment">* (If you find these comments to be wrong, please fix them)</span>
00066 <span class="comment">*</span>
00067 <span class="comment">* OCF_PROCESSOWNED: Object must start with a PROC*HEAD structure</span>
00068 <span class="comment">*                   A ptiOwner must be provided</span>
00069 <span class="comment">*                   The object affects the handle quota (ppi-&gt;UserHandleCount)</span>
00070 <span class="comment">*                   The object will be destroyed if the process goes away.</span>
00071 <span class="comment">*</span>
00072 <span class="comment">* OCF_MARKPROCESS:  Object must start with a PROCMARKHEAD structure</span>
00073 <span class="comment">*                   A ptiOwner must be provided</span>
00074 <span class="comment">*                   It must not use OCF_DESKTOPHEAP (implementation limitation)</span>
00075 <span class="comment">*</span>
00076 <span class="comment">* OCF_THREADOWNED:  Object must start with a THR*HEAD structure</span>
00077 <span class="comment">*                   The object affects the handle quota (ppi-&gt;UserHandleCount)</span>
00078 <span class="comment">*                   The object will be destroyed if the thread goes away.</span>
00079 <span class="comment">*</span>
00080 <span class="comment">* OCF_DESKTOPHEAP:  Object must start with a *DESKHEAD structure</span>
00081 <span class="comment">*                   A pdeskSrc must be provided at allocation time</span>
00082 <span class="comment">*                   It must not use OCF_MARKPROCESS (implementation limitation)</span>
00083 <span class="comment">*</span>
00084 <span class="comment">\***************************************************************************/</span>
00085 
00086 <span class="preprocessor">#if (TYPE_FREE != 0)</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#error TYPE_FREE must be zero.</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00089 <span class="preprocessor"></span>
<a name="l00090"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a6">00090</a> CONST <a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html">HANDLETYPEINFO</a>    <a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a254">TYPE_CTYPES</a>] = {
00091     <span class="comment">/* TYPE_FREE - HEAD */</span>
00092     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Free"</span>, <a class="code" href="../../d4/d5/struct__HEAD.html">HEAD</a>,
00093              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00094              0,
00095              0),
00096 
00097     <span class="comment">/* TYPE_WINDOW - WND(THRDESKHEAD) */</span>
00098     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Window"</span>, <a class="code" href="../../d6/d9/structtagWND.html">WND</a>,
00099              <a class="code" href="../../d4/d8/createw_8c.html#a5">xxxDestroyWindow</a>,
00100              TAG_WINDOW,
00101              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a416">OCF_USEPOOLQUOTA</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a418">OCF_USEPOOLIFNODESKTOP</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a420">OCF_VARIABLESIZE</a>),
00102 
00103     <span class="comment">/* TYPE_MENU - MENU(PROCDESKHEAD) */</span>
00104     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Menu"</span>, <a class="code" href="../../d1/d1/structtagMENU.html">MENU</a>,
00105              <a class="code" href="../../d7/d2/mndstry_8c.html#a0">_DestroyMenu</a>,
00106              0,
00107              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>),
00108 
00109     <span class="comment">/* TYPE_CURSOR - CURSOR(PROCMARKHEAD) or ACON(PROCMARKHEAD) */</span>
00110     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Icon/Cursor"</span>, <a class="code" href="../../d6/d1/structtagCURSOR.html">CURSOR</a>,
00111              <a class="code" href="../../d7/d4/loadbits_8c.html#a9">DestroyUnlockedCursor</a>,
00112              TAG_CURSOR,
00113              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a415">OCF_MARKPROCESS</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a416">OCF_USEPOOLQUOTA</a>),
00114 
00115     <span class="comment">/* TYPE_SETWINDOWPOS - SMWP(HEAD) */</span>
00116     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"WPI(SWP) structure"</span>, <a class="code" href="../../d8/d6/structtagSMWP.html">SMWP</a>,
00117              <a class="code" href="../../d2/d8/swp_8c.html#a20">DestroySMWP</a>,
00118              TAG_SWP,
00119              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a416">OCF_USEPOOLQUOTA</a>),
00120 
00121     <span class="comment">/* TYPE_HOOK - HOOK(THRDESKHEAD) */</span>
00122     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Hook"</span>, <a class="code" href="../../d5/d6/structtagHOOK.html">HOOK</a>,
00123              <a class="code" href="../../d1/d2/hooks_8c.html#a26">FreeHook</a>,
00124              0,
00125              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>),
00126 
00127     <span class="comment">/* TYPE_CLIPDATA -  CLIPDATA(HEAD) */</span>
00128     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Clipboard Data"</span>, <a class="code" href="../../d6/d0/structtagCLIPDATA.html">CLIPDATA</a>,
00129              <a class="code" href="../../d4/d8/handtabl_8c.html#a9">HMNullFnDestroy</a>,
00130              TAG_CLIPBOARD,
00131              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a420">OCF_VARIABLESIZE</a>),
00132 
00133     <span class="comment">/* TYPE_CALLPROC - CALLPROCDATA(THRDESKHEAD) */</span>
00134     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"CallProcData"</span>, <a class="code" href="../../d3/d7/struct__CALLPROCDATA.html">CALLPROCDATA</a>,
00135              <a class="code" href="../../d4/d8/handtabl_8c.html#a20">HMDestroyObject</a>,
00136              0,
00137              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>),
00138 
00139     <span class="comment">/* TYPE_ACCELTABLE - ACCELTABLE(PROCOBJHEAD) */</span>
00140     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Accelerator"</span>, <a class="code" href="../../d0/d8/structtagACCELTABLE.html">ACCELTABLE</a>,
00141              <a class="code" href="../../d4/d8/handtabl_8c.html#a20">HMDestroyObject</a>,
00142              TAG_ACCEL,
00143              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a416">OCF_USEPOOLQUOTA</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a420">OCF_VARIABLESIZE</a>),
00144 
00145     <span class="comment">/* TYPE_DDEACCESS - SVR_INSTANCE_INFO(THROBJHEAD) */</span>
00146     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"DDE access"</span>, <a class="code" href="../../d6/d7/structtagSVR__INSTANCE__INFO.html">SVR_INSTANCE_INFO</a>,
00147              <a class="code" href="../../d4/d8/handtabl_8c.html#a9">HMNullFnDestroy</a>,
00148              TAG_DDE9,
00149              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a416">OCF_USEPOOLQUOTA</a>),
00150 
00151     <span class="comment">/* TYPE_DDECONV - DDECONV(THROBJHEAD) */</span>
00152     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"DDE conv"</span>, <a class="code" href="../../d6/d2/structtagDDECONV.html">DDECONV</a>,
00153              <a class="code" href="../../d5/d4/kernel_2ddetrack_8c.html#a66">FreeDdeConv</a>,
00154              TAG_DDEa,
00155              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a416">OCF_USEPOOLQUOTA</a>),
00156 
00157     <span class="comment">/* TYPE_DDEXACT - XSTATE(THROBJHEAD) */</span>
00158     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"DDE Transaction"</span>, <a class="code" href="../../d1/d0/structtagXSTATE.html">XSTATE</a>,
00159              <a class="code" href="../../d5/d4/kernel_2ddetrack_8c.html#a70">FreeDdeXact</a>,
00160              TAG_DDEb,
00161              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a416">OCF_USEPOOLQUOTA</a>),
00162 
00163     <span class="comment">/* TYPE_MONITOR - MONITOR(HEAD) */</span>
00164     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Monitor"</span>, <a class="code" href="../../d0/d2/structtagMONITOR.html">MONITOR</a>,
00165              <a class="code" href="../../d1/d5/multimon_8c.html#a3">DestroyMonitor</a>,
00166              TAG_DISPLAYINFO,
00167              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a419">OCF_SHAREDHEAP</a>),
00168 
00169     <span class="comment">/* TYPE_KBDLAYOUT - KL(HEAD) */</span>
00170     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Keyboard Layout"</span>,  <a class="code" href="../../d4/d9/structtagKL.html">KL</a>,
00171              <a class="code" href="../../d6/d2/kbdlyout_8c.html#a23">DestroyKL</a>,
00172              TAG_KBDLAYOUT,
00173              0),
00174 
00175     <span class="comment">/* TYPE_KBDFILE - KBDFILE(HEAD) */</span>
00176     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Keyboard File"</span>, <a class="code" href="../../d1/d9/structtagKBDFILE.html">KBDFILE</a>,
00177              <a class="code" href="../../d6/d2/kbdlyout_8c.html#a8">DestroyKF</a>,
00178              TAG_KBDFILE,
00179              0),
00180 
00181     <span class="comment">/* TYPE_WINEVENTHOOK - EVENTHOOK(THROBJHEAD) */</span>
00182     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"WinEvent hook"</span>, <a class="code" href="../../d8/d4/structtagEVENTHOOK.html">EVENTHOOK</a>,
00183              <a class="code" href="../../d4/d1/userk_8h.html#a1951">DestroyEventHook</a>,
00184              TAG_WINEVENT,
00185              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a>),
00186 
00187 
00188     <span class="comment">/* TYPE_TIMER - TIMER(HEAD) */</span>
00189     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Timer"</span>, <a class="code" href="../../d4/d8/structtagTIMER.html">TIMER</a>,
00190              <a class="code" href="../../d4/d2/timers_8c.html#a8">FreeTimer</a>,
00191              TAG_TIMER,
00192              0),
00193 
00194     <span class="comment">/* TYPE_INPUTCONTEXT - IMC(THRDESKHEAD) */</span>
00195     <a class="code" href="../../d4/d8/handtabl_8c.html#a0">HTIENTRY</a>(<span class="stringliteral">"Input Context"</span>, <a class="code" href="../../d1/d7/structtagIMC.html">IMC</a>,
00196              <a class="code" href="../../d5/d8/ntimm_8c.html#a3">FreeInputContext</a>,
00197              0,
00198              <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>),
00199 };
00200 
00201 <span class="comment">/*</span>
00202 <span class="comment"> * Handle table allocation globals.  The purpose of keeping per-page free</span>
00203 <span class="comment"> * lists is to keep the table as small as is practical and to minimize</span>
00204 <span class="comment"> * the number of pages touched while performing handle table operations.</span>
00205 <span class="comment"> */</span>
<a name="l00206"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a1">00206</a> <span class="preprocessor">#define CPAGEENTRIESINIT    4</span>
00207 <span class="preprocessor"></span>
<a name="l00208"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a7">00208</a> <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> <a class="code" href="../../d4/d8/handtabl_8c.html#a7">gcHandlePages</a>;
<a name="l00209"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a8">00209</a> <a class="code" href="../../d4/d4/struct__HANDLEPAGE.html">PHANDLEPAGE</a> <a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a>;
00210 
00211 <span class="preprocessor">#if DBG</span>
00212 <span class="preprocessor"></span><a class="code" href="../../d1/d8/struct__PAGED__LOOKASIDE__LIST.html">PPAGED_LOOKASIDE_LIST</a> LockRecordLookaside;
00213 
00214 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> InitLockRecordLookaside();
00215 <span class="keywordtype">void</span> FreeLockRecord(<a class="code" href="../../d1/d3/struct__LOCKRECORD.html">PLR</a> plr);
00216 <span class="keywordtype">void</span> InitGlobalThreadLockArray(DWORD dwIndex);
00217 <span class="preprocessor">#endif</span>
00218 <span class="preprocessor"></span>
00219 <span class="keywordtype">void</span> <a class="code" href="../../d4/d1/userk_8h.html#a977">HMDestroyUnlockedObject</a>(<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> phe);
00220 <span class="keywordtype">void</span> <a class="code" href="../../d4/d8/handtabl_8c.html#a11">HMRecordLock</a>(PVOID ppobj, PVOID pobj, DWORD cLockObj);
00221 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d4/d8/handtabl_8c.html#a12">HMUnrecordLock</a>(PVOID ppobj, PVOID pobj);
00222 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> <a class="code" href="../../d4/d8/handtabl_8c.html#a13">ShowLocks</a>(<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a>);
00223 
00224 
00225 <span class="comment">/***************************************************************************\</span>
00226 <span class="comment">* DBGValidateHandleQuota</span>
00227 <span class="comment">*</span>
00228 <span class="comment">* 11-19-97 GerardoB         Created.</span>
00229 <span class="comment">\***************************************************************************/</span>
00230 <span class="preprocessor">#ifdef VALIDATEHANDLEQUOTA</span>
00231 <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="../../d4/d8/handtabl_8c.html#a2">DBGValidateHandleQuota</a> (<span class="keywordtype">void</span>)
00232 {
00233     <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> bCreateFlags;
00234     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dw;
00235     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">HANDLEENTRY</a> * phe;
00236 
00237     <a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a> ppiT = <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a110">gppiList</a>;
00238 
00239     <span class="keywordflow">while</span> (ppiT != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00240         ppiT-&gt;lHandles = 0;
00241         ppiT = ppiT-&gt;<a class="code" href="../../d7/d3/structtagPROCESSINFO.html#o8">ppiNextRunning</a>;
00242     }
00243 
00244     phe = <a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>;
00245     <span class="keywordflow">for</span> (dw = 0; dw &lt;= <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a308">giheLast</a>; dw++, phe++) {
00246         <span class="keywordflow">if</span> (phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>) {
00247             UserAssert(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> == NULL);
00248             <span class="keywordflow">continue</span>;
00249         }
00250         bCreateFlags = <a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html#o2">bObjectCreateFlags</a>;
00251         <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a>) {
00252             ((<a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a>)phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>)-&gt;lHandles++;
00253             <span class="keywordflow">continue</span>;
00254         }
00255         <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a>) {
00256             ((<a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a>)phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>)-&gt;ppi-&gt;lHandles++;
00257             <span class="keywordflow">continue</span>;
00258         }
00259         UserAssert(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> == NULL);
00260     }
00261 
00262     ppiT = <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a110">gppiList</a>;
00263     <span class="keywordflow">while</span> (ppiT != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00264         UserAssert(ppiT-&gt;lHandles == ppiT-&gt;UserHandleCount);
00265         ppiT = ppiT-&gt;<a class="code" href="../../d7/d3/structtagPROCESSINFO.html#o8">ppiNextRunning</a>;
00266     }
00267 }
00268 <span class="preprocessor">#else</span>
<a name="l00269"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a2">00269</a> <span class="preprocessor"></span><span class="preprocessor">#define DBGValidateHandleQuota()</span>
00270 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00271 <span class="preprocessor"></span><span class="comment">/***************************************************************************\</span>
00272 <span class="comment">* DBGHMPheFromObject</span>
00273 <span class="comment">*</span>
00274 <span class="comment">* Validates and returns the HANDLEENTRY corresponding to a given object</span>
00275 <span class="comment">*</span>
00276 <span class="comment">* 09-23-97 GerardoB         Created.</span>
00277 <span class="comment">\***************************************************************************/</span>
00278 <span class="preprocessor">#if DBG</span>
00279 <span class="preprocessor"></span><a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> DBGHMPheFromObject (PVOID p)
00280 {
00281     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> phe = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a433">_HMPheFromObject</a>(p);
00282 
00283     UserAssert(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a> == p);
00284     UserAssert(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a434">_HMObjectFromHandle</a>(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>-&gt;<a class="code" href="../../d4/d5/struct__HEAD.html#o0">h</a>) == p);
00285     UserAssert(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o4">wUniq</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a435">HMUniqFromHandle</a>(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>-&gt;<a class="code" href="../../d4/d5/struct__HEAD.html#o0">h</a>));
00286     UserAssert(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> &lt; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a254">TYPE_CTYPES</a>);
00287     UserAssert((phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
00288                 || !(<a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].bObjectCreateFlags &amp; (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a>)));
00289     UserAssert(!(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; ~<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a427">HANDLEF_VALID</a>));
00290 
00291     <span class="keywordflow">return</span> phe;
00292 }
00293 <span class="preprocessor">#endif</span>
00294 <span class="preprocessor"></span><span class="comment">/***************************************************************************\</span>
00295 <span class="comment">* DBGHMPheFromObject</span>
00296 <span class="comment">*</span>
00297 <span class="comment">* Validates and returns the object corresponding to a given handle.</span>
00298 <span class="comment">*</span>
00299 <span class="comment">* 09-23-97 GerardoB         Created.</span>
00300 <span class="comment">\***************************************************************************/</span>
00301 <span class="preprocessor">#if DBG</span>
00302 <span class="preprocessor"></span>PVOID DBGHMObjectFromHandle (HANDLE h)
00303 {
00304     PVOID p = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a434">_HMObjectFromHandle</a>(h);
00305 
00306     UserAssert((h != NULL) ^ (p == NULL));
00307     <span class="keywordflow">if</span> (p != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00308         UserAssert(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a432">HMIndexFromHandle</a>(((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)p)-&gt;h) == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a432">HMIndexFromHandle</a>(h));
00309         UserAssert(p == <a class="code" href="../../d1/d0/inc_2user_8h.html#a429">HMRevalidateCatHandle</a>(h));
00310     <span class="comment">/*</span>
00311 <span class="comment">     * This routine, unlike Validation, should return a real pointer if</span>
00312 <span class="comment">     * the object exists, even if it is destroyed.  But we should still</span>
00313 <span class="comment">     * generate a warning.</span>
00314 <span class="comment">     */</span>
00315         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a446">HMPheFromObject</a>(p)-&gt;bFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a421">HANDLEF_DESTROY</a>) {
00316             RIPMSG1(RIP_WARNING, <span class="stringliteral">"HMObjectFromHandle: Object p %#p is destroyed"</span>,
00317                     p);
00318         }
00319     }
00320 
00321     <span class="keywordflow">return</span> p;
00322 }
00323 PVOID DBGHMCatObjectFromHandle (HANDLE h)
00324 {
00325     <span class="comment">/*</span>
00326 <span class="comment">     * Note -- at this point, _HMObjectFromHandle does not check</span>
00327 <span class="comment">     *   to see if an object is destroyed.</span>
00328 <span class="comment">     */</span>
00329     PVOID p = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a434">_HMObjectFromHandle</a>(h);
00330 
00331     UserAssert((h != NULL) ^ (p == NULL));
00332     <span class="keywordflow">if</span> (p != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00333         UserAssert(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a432">HMIndexFromHandle</a>(((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)p)-&gt;h) == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a432">HMIndexFromHandle</a>(h));
00334         UserAssert(p == <a class="code" href="../../d1/d0/inc_2user_8h.html#a429">HMRevalidateCatHandle</a>(h));
00335     }
00336 
00337     <span class="keywordflow">return</span> p;
00338 }
00339 <span class="preprocessor">#endif</span>
00340 <span class="preprocessor"></span><span class="comment">/***************************************************************************\</span>
00341 <span class="comment">* DBGPtoH and DBGPtoHq</span>
00342 <span class="comment">*</span>
00343 <span class="comment">* Validates and returns the handle corresponding to a given object</span>
00344 <span class="comment">*</span>
00345 <span class="comment">* 09-23-97 GerardoB         Created.</span>
00346 <span class="comment">\***************************************************************************/</span>
00347 <span class="preprocessor">#if DBG</span>
00348 <span class="preprocessor"></span><span class="keywordtype">void</span> DBGValidatePtoH (PVOID p, HANDLE h)
00349 {
00350     UserAssert((h != NULL) ^ (p == NULL));
00351     <span class="keywordflow">if</span> (h != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00352         UserAssert(p == <a class="code" href="../../d1/d0/inc_2user_8h.html#a429">HMRevalidateCatHandle</a>(h));
00353     }
00354 }
00355 HANDLE DBGPtoH (PVOID p)
00356 {
00357     HANDLE h = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a443">_PtoH</a>(p);
00358     DBGValidatePtoH(p, h);
00359     <span class="keywordflow">return</span> h;
00360 }
00361 HANDLE DBGPtoHq (PVOID p)
00362 {
00363     HANDLE h;
00364     UserAssert(p != NULL);
00365     h = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a442">_PtoHq</a>(p);
00366     DBGValidatePtoH(p, h);
00367     <span class="keywordflow">return</span> h;
00368 }
00369 <span class="preprocessor">#endif</span>
00370 <span class="preprocessor"></span><span class="comment">/***************************************************************************\</span>
00371 <span class="comment">* DBGHW and DBGHWq</span>
00372 <span class="comment">*</span>
00373 <span class="comment">* Validates and returns the hwnd corresponding to a given pwnd</span>
00374 <span class="comment">*</span>
00375 <span class="comment">* 09-23-97 GerardoB         Created.</span>
00376 <span class="comment">\***************************************************************************/</span>
00377 <span class="preprocessor">#if DBG</span>
00378 <span class="preprocessor"></span><span class="keywordtype">void</span> DBGValidateHW(<a class="code" href="../../d6/d9/structtagWND.html">PWND</a> pwnd, HWND hwnd)
00379 {
00380     UserAssert((hwnd != NULL) ^ (pwnd == NULL));
00381     <span class="keywordflow">if</span> (hwnd != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00382         UserAssert(pwnd == <a class="code" href="../../d1/d0/inc_2user_8h.html#a1181">HMValidateCatHandleNoSecure</a>(hwnd, TYPE_WINDOW));
00383     }
00384 }
00385 <span class="keywordtype">void</span> DBGValidateHWCCX(<a class="code" href="../../d6/d9/structtagWND.html">PWND</a> ccxPwnd, HWND hwnd, <a class="code" href="../../d2/d2/struct__CLIENTINFO.html">PCLIENTINFO</a> ccxPci)
00386 {
00387     UserAssert((hwnd != NULL) ^ (ccxPwnd == NULL));
00388     <span class="keywordflow">if</span> (hwnd != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00389         UserAssert(ccxPwnd == <a class="code" href="../../d1/d0/inc_2user_8h.html#a1182">HMValidateCatHandleNoSecureCCX</a>(hwnd, TYPE_WINDOW, ccxPci));
00390     }
00391 }
00392 HWND DBGHW (<a class="code" href="../../d6/d9/structtagWND.html">PWND</a> pwnd)
00393 {
00394     HWND hwnd = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a444">_HW</a>(pwnd);
00395     DBGValidateHW(pwnd, hwnd);
00396     <span class="keywordflow">return</span> hwnd;
00397 }
00398 HWND DBGHWCCX (<a class="code" href="../../d6/d9/structtagWND.html">PWND</a> ccxPwnd)
00399 {
00400     HWND hwnd = <a class="code" href="../../d1/d0/inc_2user_8h.html#a435">_HWCCX</a>(ccxPwnd);
00401     <a class="code" href="../../d2/d2/struct__CLIENTINFO.html">PCLIENTINFO</a> ccxPci = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a452">_GETPTI</a>(ccxPwnd)-&gt;pClientInfo;
00402     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/ke_8h.html#a25">KeIsAttachedProcess</a>()) {
00403         UserAssert(<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;ApcState.Process == &amp;(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a452">_GETPTI</a>(ccxPwnd)-&gt;ppi-&gt;Process-&gt;Pcb));
00404     } <span class="keywordflow">else</span> {
00405         UserAssert(<a class="code" href="../../d4/d1/userk_8h.html#a16">PpiCurrent</a>() == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a452">_GETPTI</a>(ccxPwnd)-&gt;ppi);
00406     }
00407     DBGValidateHWCCX(ccxPwnd, hwnd, ccxPci);
00408     <span class="keywordflow">return</span> hwnd;
00409 }
00410 HWND DBGHWq (<a class="code" href="../../d6/d9/structtagWND.html">PWND</a> pwnd)
00411 {
00412     HWND hwnd;
00413     UserAssert(pwnd != NULL);
00414     hwnd = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a445">_HWq</a>(pwnd);
00415     DBGValidateHW(pwnd, hwnd);
00416     <span class="keywordflow">return</span> hwnd;
00417 }
00418 <span class="preprocessor">#endif</span>
00419 <span class="preprocessor"></span><span class="comment">/***************************************************************************\</span>
00420 <span class="comment">* DBGHMValidateFreeLists</span>
00421 <span class="comment">*</span>
00422 <span class="comment">* Walks all handle free lists to make sure all links are fine.</span>
00423 <span class="comment">*</span>
00424 <span class="comment">* 10/08/97  GerardoB    Created</span>
00425 <span class="comment">\***************************************************************************/</span>
00426 <span class="preprocessor">#if DBG</span>
00427 <span class="preprocessor"></span><span class="keywordtype">void</span> DBGHMValidateFreeList (ULONG_PTR iheFreeNext, BOOL fEven)
00428 {
00429     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> phe;
00430     <span class="keywordflow">do</span> {
00431         UserAssert(fEven ^ !!(iheFreeNext &amp; 0x1));
00432         UserAssert(iheFreeNext &lt; gpsi-&gt;cHandleEntries);
00433         phe = &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[iheFreeNext];
00434         UserAssert(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == TYPE_FREE);
00435         UserAssert(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> == NULL);
00436         UserAssert(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> == 0);
00437         iheFreeNext = (ULONG_PTR)phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>;
00438     } <span class="keywordflow">while</span> (iheFreeNext != 0);
00439 }
00440 <span class="keywordtype">void</span> <a class="code" href="../../d4/d8/handtabl_8c.html#a3">DBGHMValidateFreeLists</a> (<span class="keywordtype">void</span>)
00441 {
00442     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dw;
00443     <a class="code" href="../../d4/d4/struct__HANDLEPAGE.html">PHANDLEPAGE</a> php = <a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a>;
00444 
00445     <span class="keywordflow">for</span> (dw = 0; dw &lt; <a class="code" href="../../d4/d8/handtabl_8c.html#a7">gcHandlePages</a>; ++dw, ++php) {
00446         <span class="keywordflow">if</span> (php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o1">iheFreeEven</a> != 0) {
00447             DBGHMValidateFreeList(php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o1">iheFreeEven</a>, TRUE);
00448         }
00449         <span class="keywordflow">if</span> (php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> != 0) {
00450             DBGHMValidateFreeList(php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a>, FALSE);
00451         }
00452     } <span class="comment">/* for */</span>
00453 }
00454 <span class="preprocessor">#else</span>
<a name="l00455"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a3">00455</a> <span class="preprocessor"></span><span class="preprocessor">#define DBGHMValidateFreeLists()</span>
00456 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00457 <span class="preprocessor"></span>
00458 <span class="preprocessor">#if DBG</span>
00459 <span class="preprocessor"></span>
00460 <span class="comment">/***************************************************************************\</span>
00461 <span class="comment">* DbgDumpHandleTable</span>
00462 <span class="comment">*</span>
00463 <span class="comment">\***************************************************************************/</span>
00464 <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> DbgDumpHandleTable(
00465     VOID)
00466 {
00467     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dw;
00468     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a>   phe;
00469     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dwHandles = 0;
00470 
00471     phe = <a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>;
00472 
00473     <span class="keywordflow">if</span> (phe == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00474         KdPrint((<span class="stringliteral">"\nTERMSRV\nEmpty handle table\n"</span>));
00475         <span class="keywordflow">return</span> 0;
00476     }
00477 
00478     KdPrint((<span class="stringliteral">"\nTERMSRV\nDump the handle table\n"</span>));
00479     KdPrint((<span class="stringliteral">"---------------------------------------------------\n"</span>));
00480     KdPrint((<span class="stringliteral">"     phead    handle   lock     pOwner   type flags\n"</span>));
00481     KdPrint((<span class="stringliteral">"---------------------------------------------------\n"</span>));
00482 
00483     <span class="keywordflow">for</span> (dw = 0; dw &lt;= <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a308">giheLast</a>; dw++, phe++) {
00484         <span class="keywordflow">if</span> (phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>) {
00485             UserAssert(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00486             <span class="keywordflow">continue</span>;
00487         }
00488 
00489         KdPrint((<span class="stringliteral">"%04d %08x %08x %08d %08x %04x %05x\n"</span>,
00490                  dwHandles++,
00491                  phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>,
00492                  phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>-&gt;<a class="code" href="../../d4/d5/struct__HEAD.html#o0">h</a>,
00493                  phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>-&gt;<a class="code" href="../../d4/d5/struct__HEAD.html#o1">cLockObj</a>,
00494                  phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>,
00495                  phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>,
00496                  phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a>));
00497     }
00498 
00499     KdPrint((<span class="stringliteral">"----------------------------------------------\n"</span>));
00500     KdPrint((<span class="stringliteral">"Number of handles left: %d\n"</span>, dwHandles));
00501     KdPrint((<span class="stringliteral">"End of handle table\n"</span>));
00502 
00503     UserAssert(dwHandles == 0);
00504 
00505     <span class="keywordflow">return</span> dwHandles;
00506 }
00507 
00508 <span class="comment">/***************************************************************************\</span>
00509 <span class="comment">* HMCleanUpHandleTable</span>
00510 <span class="comment">*</span>
00511 <span class="comment">\***************************************************************************/</span>
00512 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> HMCleanUpHandleTable(
00513     VOID)
00514 {
00515     DbgDumpHandleTable();
00516 
00517     <span class="keywordflow">if</span> (LockRecordLookaside != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00518         <a class="code" href="../../d5/d8/ex_8h.html#a251">ExDeletePagedLookasideList</a>(LockRecordLookaside);
00519         UserFreePool(LockRecordLookaside);
00520     }
00521 }
00522 <span class="preprocessor">#endif // DBG</span>
00523 <span class="preprocessor"></span>
00524 <span class="comment">/***************************************************************************\</span>
00525 <span class="comment">* HMInitHandleEntries</span>
00526 <span class="comment">*</span>
00527 <span class="comment">* 10/10/97  GerardoB    Extracted from HMInitHandleTable and HMGrowHandleTable</span>
00528 <span class="comment">\***************************************************************************/</span>
<a name="l00529"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a14">00529</a> <span class="keywordtype">void</span> <a class="code" href="../../d4/d8/handtabl_8c.html#a14">HMInitHandleEntries</a> (ULONG_PTR iheFirstFree)
00530 {
00531     ULONG_PTR ihe;
00532     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a>      pheT;
00533     <span class="comment">/*</span>
00534 <span class="comment">     * Zero out all the new entries</span>
00535 <span class="comment">     */</span>
00536     RtlZeroMemory (&amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[iheFirstFree],
00537                     (<a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> - iheFirstFree) * <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">HANDLEENTRY</a>));
00538     <span class="comment">/*</span>
00539 <span class="comment">     * Link them together.</span>
00540 <span class="comment">     * Each free odd/even entry points to the next odd/even free entry.</span>
00541 <span class="comment">     */</span>
00542     ihe = iheFirstFree;
00543     <span class="keywordflow">for</span> (pheT = &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[ihe]; ihe &lt; <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a>; ihe++, pheT++) {
00544         pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a> = (<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)(ihe + 2);
00545         <span class="comment">/* pheT-&gt;bType = TYPE_FREE; */</span>
00546         pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o4">wUniq</a> = 1;
00547     }
00548     <span class="comment">/*</span>
00549 <span class="comment">     * Terminate the lists.</span>
00550 <span class="comment">     */</span>
00551     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> &gt; iheFirstFree) {
00552         UserAssert(pheT - 1 &gt;= &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[iheFirstFree]);
00553         (pheT - 1)-&gt;phead = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00554     }
00555     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> &gt; iheFirstFree + 1) {
00556         UserAssert(pheT - 2 &gt;= &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[iheFirstFree]);
00557         (pheT - 2)-&gt;phead = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00558     }
00559     <span class="comment">/*</span>
00560 <span class="comment">     * Let's check that we got it right</span>
00561 <span class="comment">     */</span>
00562     <a class="code" href="../../d4/d8/handtabl_8c.html#a3">DBGHMValidateFreeLists</a>();
00563 }
00564 <span class="comment">/***************************************************************************\</span>
00565 <span class="comment">* HMInitHandleTable</span>
00566 <span class="comment">*</span>
00567 <span class="comment">* Initialize the handle table. Unused entries are linked together.</span>
00568 <span class="comment">*</span>
00569 <span class="comment">* 01-13-92 ScottLu      Created.</span>
00570 <span class="comment">\***************************************************************************/</span>
00571 
<a name="l00572"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a4">00572</a> <span class="preprocessor">#define CHANDLEENTRIESINIT 200</span>
<a name="l00573"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a5">00573</a> <span class="preprocessor"></span><span class="preprocessor">#define CLOCKENTRIESINIT   100</span>
00574 <span class="preprocessor"></span>
<a name="l00575"></a><a class="code" href="../../d4/d1/userk_8h.html#a968">00575</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d4/d1/userk_8h.html#a968">HMInitHandleTable</a>(
00576     PVOID pReadOnlySharedSectionBase)
00577 {
00578     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00579     SIZE_T   ulCommit;
00580 
00581     <span class="comment">/*</span>
00582 <span class="comment">     * Allocate the handle page array.  Make it big enough</span>
00583 <span class="comment">     * for 4 pages, which should be sufficient for nearly</span>
00584 <span class="comment">     * all instances.</span>
00585 <span class="comment">     */</span>
00586     <a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a> = UserAllocPool(
00587             <a class="code" href="../../d4/d8/handtabl_8c.html#a1">CPAGEENTRIESINIT</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html">HANDLEPAGE</a>), TAG_SYSTEM);
00588 
00589     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
00590         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00591 
00592 <span class="preprocessor">#if DBG</span>
00593 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(InitLockRecordLookaside()))
00594         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00595 <span class="preprocessor">#endif</span>
00596 <span class="preprocessor"></span>
00597     <span class="comment">/*</span>
00598 <span class="comment">     * Allocate the array.  We have the space from</span>
00599 <span class="comment">     * NtCurrentPeb()-&gt;ReadOnlySharedMemoryBase to</span>
00600 <span class="comment">     * NtCurrentPeb()-&gt;ReadOnlySharedMemoryHeap reserved for</span>
00601 <span class="comment">     * the handle table.  All we need to do is commit the pages.</span>
00602 <span class="comment">     *</span>
00603 <span class="comment">     * Compute the minimum size of the table.  The allocation will</span>
00604 <span class="comment">     * round this up to the next page size.</span>
00605 <span class="comment">     */</span>
00606     ulCommit = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o11">cbHandleTable</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00607     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d1/userk_8h.html#a1002">CommitReadOnlyMemory</a>(<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a320">ghSectionShared</a>, &amp;ulCommit, 0, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00608 
00609     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>))
00610         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00611 
00612     <a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a> = pReadOnlySharedSectionBase;
00613     <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o11">cbHandleTable</a> / <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">HANDLEENTRY</a>);
00614     <a class="code" href="../../d4/d8/handtabl_8c.html#a7">gcHandlePages</a> = 1;
00615 
00616     <span class="comment">/*</span>
00617 <span class="comment">     * Initialize the handlepage info. Handle 0 is reserved so even free list</span>
00618 <span class="comment">     *  starts at 2.</span>
00619 <span class="comment">     */</span>
00620     <a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a>[0].<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> = 1;
00621     <a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a>[0].<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o1">iheFreeEven</a> = 2;
00622     <a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a>[0].<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o0">iheLimit</a> = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a>;
00623     <span class="comment">/*</span>
00624 <span class="comment">     * Initialize the handle entries.</span>
00625 <span class="comment">     */</span>
00626     <a class="code" href="../../d4/d8/handtabl_8c.html#a14">HMInitHandleEntries</a>(0);
00627     <span class="comment">/*</span>
00628 <span class="comment">     * PW(NULL) (ie, handle 0) must map to a NULL pointer.</span>
00629 <span class="comment">     * Old comment:</span>
00630 <span class="comment">     * Reserve the first handle table entry so that PW(NULL) maps to a</span>
00631 <span class="comment">     * NULL pointer. Set it to TYPE_FREE so the cleanup code doesn't think</span>
00632 <span class="comment">     * it is allocated. Set wUniq to 1 so that RevalidateHandles on NULL</span>
00633 <span class="comment">     * will fail.</span>
00634 <span class="comment">     */</span>
00635     <a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[0].<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00636     UserAssert(<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[0].<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>);
00637     UserAssert(<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[0].<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o4">wUniq</a> == 1);
00638 
00639 <span class="preprocessor">#if DBG</span>
00640 <span class="preprocessor"></span>    <span class="comment">/*</span>
00641 <span class="comment">     * Make sure we don't need to add the special case to handle HMINDEXBITS in this function.</span>
00642 <span class="comment">     */</span>
00643     UserAssert(<a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> &lt;= <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a428">HMINDEXBITS</a>);
00644     <span class="comment">/*</span>
00645 <span class="comment">     * PDESKOBJHEAD won't do the right casting unless these structs have</span>
00646 <span class="comment">     *  the same size.</span>
00647 <span class="comment">     */</span>
00648     UserAssert(<span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/struct__THROBJHEAD.html">THROBJHEAD</a>) == <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d0/struct__PROCOBJHEAD.html">PROCOBJHEAD</a>));
00649     UserAssert(<span class="keyword">sizeof</span>(<a class="code" href="../../d9/d0/struct__THRDESKHEAD.html">THRDESKHEAD</a>) == <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d9/struct__PROCDESKHEAD.html">PROCDESKHEAD</a>));
00650     UserAssert(<span class="keyword">sizeof</span>(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1026">THRDESKHEAD</a>) == <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d2/struct__DESKOBJHEAD.html">DESKOBJHEAD</a>));
00651     <span class="comment">/*</span>
00652 <span class="comment">     * Validate type flags to make sure that assumptions made</span>
00653 <span class="comment">     *  throughout HM code are OK.</span>
00654 <span class="comment">     */</span>
00655     {
00656         <a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html">HANDLETYPEINFO</a> * pahti = (<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html">HANDLETYPEINFO</a> *) <a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>;
00657         <a class="code" href="../../d9/d5/ndismain_8h.html#a265">UINT</a> uTypes = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a254">TYPE_CTYPES</a>;
00658         <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> bObjectCreateFlags;
00659         <span class="keywordflow">while</span> (uTypes-- != 0) {
00660             bObjectCreateFlags = pahti-&gt;<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html#o2">bObjectCreateFlags</a>;
00661             <span class="comment">/*</span>
00662 <span class="comment">             * Illegal flag combinations</span>
00663 <span class="comment">             */</span>
00664             UserAssert(!((bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>) &amp;&amp; (bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a415">OCF_MARKPROCESS</a>)));
00665             <span class="comment">/*</span>
00666 <span class="comment">             * Pointless (and probably illegal) flag combinations</span>
00667 <span class="comment">             */</span>
00668             UserAssert(!((bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>) &amp;&amp; (bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a419">OCF_SHAREDHEAP</a>)));
00669             UserAssert(!((bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a416">OCF_USEPOOLQUOTA</a>) &amp;&amp; (bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a419">OCF_SHAREDHEAP</a>)));
00670             UserAssert(!((bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a>) &amp;&amp; (bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a>)));
00671             UserAssert(!(bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a416">OCF_USEPOOLQUOTA</a>)
00672                         || !(bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>)
00673                         || (bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a418">OCF_USEPOOLIFNODESKTOP</a>));
00674 
00675             <span class="comment">/*</span>
00676 <span class="comment">             * Required flag combinations</span>
00677 <span class="comment">             */</span>
00678             UserAssert(!(bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>)
00679                         || (bObjectCreateFlags &amp; (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a>)));
00680 
00681             UserAssert(!(bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a415">OCF_MARKPROCESS</a>)
00682                         || (bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a>));
00683 
00684             UserAssert(!(bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a418">OCF_USEPOOLIFNODESKTOP</a>)
00685                         || (bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>));
00686 
00687 
00688             pahti++;
00689         } <span class="comment">/* while (uTypes-- != 0) */</span>
00690     }
00691 <span class="preprocessor">#endif</span>
00692 <span class="preprocessor"></span>
00693     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00694 }
00695 
00696 <span class="comment">/***************************************************************************\</span>
00697 <span class="comment">* HMGrowHandleTable</span>
00698 <span class="comment">*</span>
00699 <span class="comment">* Grows the handle table. Assumes the handle table already exists.</span>
00700 <span class="comment">*</span>
00701 <span class="comment">* 01-13-92 ScottLu      Created.</span>
00702 <span class="comment">\***************************************************************************/</span>
00703 
<a name="l00704"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a16">00704</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d4/d8/handtabl_8c.html#a16">HMGrowHandleTable</a>()
00705 {
00706     ULONG_PTR   i, iheFirstFree;
00707     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a>         pheT;
00708     PVOID       p;
00709     <a class="code" href="../../d4/d4/struct__HANDLEPAGE.html">PHANDLEPAGE</a> phpNew;
00710     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>       dwCommitOffset;
00711     SIZE_T      ulCommit;
00712     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>    <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00713 
00714     <span class="comment">/*</span>
00715 <span class="comment">     * If we've run out of handle space, fail.</span>
00716 <span class="comment">     */</span>
00717     i = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a>;
00718     <span class="keywordflow">if</span> (i &amp; ~<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a428">HMINDEXBITS</a>)
00719         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00720 
00721     <span class="comment">/*</span>
00722 <span class="comment">     * Grow the page table if need be.</span>
00723 <span class="comment">     */</span>
00724     i = <a class="code" href="../../d4/d8/handtabl_8c.html#a7">gcHandlePages</a> + 1;
00725     <span class="keywordflow">if</span> (i &gt; <a class="code" href="../../d4/d8/handtabl_8c.html#a1">CPAGEENTRIESINIT</a>) {
00726         <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dwSize = <a class="code" href="../../d4/d8/handtabl_8c.html#a7">gcHandlePages</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html">HANDLEPAGE</a>);
00727 
00728         phpNew = UserReAllocPool(
00729                 <a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a>, dwSize, dwSize + <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html">HANDLEPAGE</a>), TAG_SYSTEM);
00730 
00731         <span class="keywordflow">if</span> (phpNew == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
00732             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00733 
00734         <a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a> = phpNew;
00735     }
00736 
00737     <span class="comment">/*</span>
00738 <span class="comment">     * Commit some more pages to the table.  First find the</span>
00739 <span class="comment">     * address where the commitment needs to be.</span>
00740 <span class="comment">     */</span>
00741     p = (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a> + <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o11">cbHandleTable</a>;
00742 
00743     <span class="keywordflow">if</span> (p &gt;= Win32HeapGetHandle(<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a322">gpvSharedAlloc</a>)) {
00744         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00745     }
00746 
00747     dwCommitOffset = (ULONG)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)p - (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a321">gpvSharedBase</a>);
00748 
00749     ulCommit = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00750 
00751     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d1/userk_8h.html#a1002">CommitReadOnlyMemory</a>(<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a320">ghSectionShared</a>, &amp;ulCommit, dwCommitOffset, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00752 
00753     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>))
00754         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00755 
00756     phpNew = &amp;<a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a>[<a class="code" href="../../d4/d8/handtabl_8c.html#a7">gcHandlePages</a>++];
00757 
00758     <span class="comment">/*</span>
00759 <span class="comment">     * Update the global information to include the new</span>
00760 <span class="comment">     * page.</span>
00761 <span class="comment">     */</span>
00762     iheFirstFree = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a>;
00763     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> &amp; 0x1) {
00764         phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a>;
00765         phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o1">iheFreeEven</a> = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> + 1;
00766     } <span class="keywordflow">else</span> {
00767         phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o1">iheFreeEven</a> = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a>;
00768         phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> + 1;
00769     }
00770     <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o11">cbHandleTable</a> += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00771 
00772     <span class="comment">/*</span>
00773 <span class="comment">     * Check for handle overflow</span>
00774 <span class="comment">     */</span>
00775     <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o11">cbHandleTable</a> / <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">HANDLEENTRY</a>);
00776     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> &amp; ~<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a428">HMINDEXBITS</a>) {
00777         <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> = (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a428">HMINDEXBITS</a> + 1);
00778     }
00779 
00780     phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o0">iheLimit</a> = <a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a>;
00781     <span class="keywordflow">if</span> (phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o1">iheFreeEven</a> &gt;= phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o0">iheLimit</a>) {
00782         phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o1">iheFreeEven</a> = 0;
00783     }
00784     <span class="keywordflow">if</span> (phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> &gt;= phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o0">iheLimit</a>) {
00785         phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> = 0;
00786     }
00787 
00788     <a class="code" href="../../d4/d8/handtabl_8c.html#a14">HMInitHandleEntries</a>(iheFirstFree);
00789 
00790     <span class="comment">/*</span>
00791 <span class="comment">     * HMINDEXBITS has a special meaning. We used to handle this in HMAllocObject.</span>
00792 <span class="comment">     * Now we handle it here right after adding that handle to the table.</span>
00793 <span class="comment">     * Old Comment:</span>
00794 <span class="comment">     * Reserve this table entry so that PW(HMINDEXBITS) maps to a</span>
00795 <span class="comment">     * NULL pointer. Set it to TYPE_FREE so the cleanup code doesn't think</span>
00796 <span class="comment">     * it is allocated. Set wUniq to 1 so that RevalidateHandles on HMINDEXBITS</span>
00797 <span class="comment">     * will fail.</span>
00798 <span class="comment">     */</span>
00799     <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> &gt; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a428">HMINDEXBITS</a>)
00800             &amp;&amp; (phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> != 0)
00801             &amp;&amp; (phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> &lt;= <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a428">HMINDEXBITS</a>)) {
00802 
00803         pheT = &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a428">HMINDEXBITS</a>];
00804         <span class="keywordflow">if</span> (phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a428">HMINDEXBITS</a>) {
00805             phpNew-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> = (ULONG_PTR)pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>;
00806         } <span class="keywordflow">else</span> {
00807             UserAssert(pheT - 2 &gt;= &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[iheFirstFree]);
00808             UserAssert((pheT - 2)-&gt;phead == (PVOID)<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a428">HMINDEXBITS</a>);
00809             (pheT - 2)-&gt;phead = pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>;
00810         }
00811         pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00812         UserAssert(pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>);
00813         UserAssert(pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o4">wUniq</a> == 1);
00814     }
00815 
00816     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00817 }
00818 
00819 <span class="comment">/***************************************************************************\</span>
00820 <span class="comment">* HMAllocObject</span>
00821 <span class="comment">*</span>
00822 <span class="comment">* Allocs a non-secure object by allocating a handle and memory for</span>
00823 <span class="comment">* the object.</span>
00824 <span class="comment">*</span>
00825 <span class="comment">* 01-13-92 ScottLu      Created.</span>
00826 <span class="comment">\***************************************************************************/</span>
00827 
<a name="l00828"></a><a class="code" href="../../d4/d1/userk_8h.html#a969">00828</a> PVOID <a class="code" href="../../d4/d1/userk_8h.html#a969">HMAllocObject</a>(
00829     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiOwner,
00830     <a class="code" href="../../d0/d3/structtagDESKTOP.html">PDESKTOP</a> pdeskSrc,
00831     BYTE bType,
00832     DWORD size)
00833 {
00834     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>       i;
00835     <a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>       phead;
00836     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a>         pheT;
00837     ULONG_PTR    iheFree, *piheFreeHead;
00838     <a class="code" href="../../d4/d4/struct__HANDLEPAGE.html">PHANDLEPAGE</a> php;
00839     <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a>        bCreateFlags;
00840     <a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a> ppiQuotaCharge = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00841     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>        fUsePoolIfNoDesktop;
00842     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>        fEven;
00843 
00844     <a class="code" href="../../d4/d1/userk_8h.html#a154">CheckCritIn</a>();
00845     bCreateFlags = <a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[bType].<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html#o2">bObjectCreateFlags</a>;
00846 
00847 <span class="preprocessor">#if DBG</span>
00848 <span class="preprocessor"></span>    <span class="comment">/*</span>
00849 <span class="comment">     * Validate size</span>
00850 <span class="comment">     */</span>
00851     <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a420">OCF_VARIABLESIZE</a>) {
00852         UserAssert(<a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[bType].uSize &lt;= size);
00853     } <span class="keywordflow">else</span> {
00854         UserAssert(<a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[bType].uSize == size);
00855     }
00856 <span class="preprocessor">#endif</span>
00857 <span class="preprocessor"></span>
00858     <span class="comment">/*</span>
00859 <span class="comment">     * Check for process handle quota</span>
00860 <span class="comment">     */</span>
00861     <span class="keywordflow">if</span> (bCreateFlags &amp; (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a> | <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a>)) {
00862         UserAssert(ptiOwner != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00863         ppiQuotaCharge = ptiOwner-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o2">ppi</a>;
00864         <span class="keywordflow">if</span> (ppiQuotaCharge-&gt;UserHandleCount &gt;= <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a253">gUserProcessHandleQuota</a>) {
00865             RIPERR0(ERROR_NO_MORE_USER_HANDLES,
00866                    RIP_WARNING,
00867                 <span class="stringliteral">"USER: HMAllocObject: out of handle quota\n"</span>);
00868             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00869         }
00870     }
00871 
00872     <span class="comment">/*</span>
00873 <span class="comment">     * Find the next free handle</span>
00874 <span class="comment">     * Window handles must be even; hence we try first to use odd handles</span>
00875 <span class="comment">     *  for all other objects.</span>
00876 <span class="comment">     * Old comment:</span>
00877 <span class="comment">     * Some wow apps, like WinProj, require even Window handles so we'll</span>
00878 <span class="comment">     * accomodate them; build a list of the odd handles so they won't get lost</span>
00879 <span class="comment">     * 10/13/97: WinProj never fixed this; even the 32 bit version has the problem.</span>
00880 <span class="comment">     */</span>
00881     fEven = (bType == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a237">TYPE_WINDOW</a>);
00882     piheFreeHead = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00883     <span class="keywordflow">do</span> {
00884         php = <a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a>;
00885         <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d4/d8/handtabl_8c.html#a7">gcHandlePages</a>; ++i, ++php) {
00886             <span class="keywordflow">if</span> (fEven) {
00887                 <span class="keywordflow">if</span> (php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o1">iheFreeEven</a> != 0) {
00888                     piheFreeHead = &amp;php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o1">iheFreeEven</a>;
00889                     <span class="keywordflow">break</span>;
00890                 }
00891             } <span class="keywordflow">else</span> {
00892                 <span class="keywordflow">if</span> (php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> != 0) {
00893                     piheFreeHead = &amp;php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a>;
00894                     <span class="keywordflow">break</span>;
00895                 }
00896             }
00897         } <span class="comment">/* for */</span>
00898         <span class="comment">/*</span>
00899 <span class="comment">         * If we couldn't find an odd handle, then search for an even one</span>
00900 <span class="comment">         */</span>
00901         fEven = ((piheFreeHead == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; !fEven);
00902     } <span class="keywordflow">while</span> (fEven);
00903     <span class="comment">/*</span>
00904 <span class="comment">     * If there are no free handles we can use, grow the table</span>
00905 <span class="comment">     */</span>
00906     <span class="keywordflow">if</span> (piheFreeHead == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00907         <a class="code" href="../../d4/d8/handtabl_8c.html#a16">HMGrowHandleTable</a>();
00908         <span class="comment">/*</span>
00909 <span class="comment">         * If the table didn't grow, get out.</span>
00910 <span class="comment">         */</span>
00911         <span class="keywordflow">if</span> (i == <a class="code" href="../../d4/d8/handtabl_8c.html#a7">gcHandlePages</a>) {
00912             RIPMSG0(RIP_WARNING, <span class="stringliteral">"HMAllocObject: could not grow handle space"</span>);
00913             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00914         }
00915         <span class="comment">/*</span>
00916 <span class="comment">         * Because the handle page table may have moved,</span>
00917 <span class="comment">         * recalc the page entry pointer.</span>
00918 <span class="comment">         */</span>
00919         php = &amp;<a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a>[i];
00920         piheFreeHead = (bType == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a237">TYPE_WINDOW</a> ? &amp;php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o1">iheFreeEven</a> : &amp;php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a>);
00921         <span class="keywordflow">if</span> (*piheFreeHead == 0) {
00922             UserAssert(<a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o4">cHandleEntries</a> == (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a428">HMINDEXBITS</a> + 1));
00923             RIPMSG0(RIP_WARNING, <span class="stringliteral">"HMAllocObject: handle table is full"</span>);
00924             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00925         }
00926     }
00927     <span class="comment">/*</span>
00928 <span class="comment">     * HMINDEXBITS is a reserved value that should never be in the free lists</span>
00929 <span class="comment">     *  (see HMGrowHandleTable());</span>
00930 <span class="comment">     */</span>
00931     UserAssert(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a432">HMIndexFromHandle</a>(*piheFreeHead) != <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a428">HMINDEXBITS</a>);
00932     <span class="comment">/*</span>
00933 <span class="comment">     * Try to allocate the object. If this fails, bail out.</span>
00934 <span class="comment">     */</span>
00935     <span class="keywordflow">if</span> ((bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>) &amp;&amp; pdeskSrc) {
00936         phead = (<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)<a class="code" href="../../d4/d1/userk_8h.html#a1020">DesktopAlloc</a>(pdeskSrc, size, <a class="code" href="../../d4/d1/userk_8h.html#a306">DTAG_HANDTABL</a>);
00937         <span class="keywordflow">if</span> (phead) {
00938             <a class="code" href="../../d4/d1/userk_8h.html#a126">LockDesktop</a>(&amp;((<a class="code" href="../../d8/d2/struct__DESKOBJHEAD.html">PDESKOBJHEAD</a>)phead)-&gt;rpdesk, pdeskSrc, LDL_OBJ_DESK, (ULONG_PTR)phead);
00939             ((<a class="code" href="../../d8/d2/struct__DESKOBJHEAD.html">PDESKOBJHEAD</a>)phead)-&gt;pSelf = (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)phead;
00940         }
00941     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a419">OCF_SHAREDHEAP</a>) {
00942         UserAssert(!pdeskSrc);
00943         phead = (<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)<a class="code" href="../../d4/d1/userk_8h.html#a1000">SharedAlloc</a>(size);
00944     } <span class="keywordflow">else</span> {
00945         fUsePoolIfNoDesktop = !pdeskSrc &amp;&amp; (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a418">OCF_USEPOOLIFNODESKTOP</a>);
00946         UserAssert(!(bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>) || fUsePoolIfNoDesktop);
00947 
00948         <span class="keywordflow">if</span> ((bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a416">OCF_USEPOOLQUOTA</a>) &amp;&amp; !fUsePoolIfNoDesktop) {
00949             phead = (<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)UserAllocPoolWithQuotaZInit(size, <a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[bType].dwAllocTag);
00950         } <span class="keywordflow">else</span> {
00951             phead = (<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)UserAllocPoolZInit(size, <a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[bType].dwAllocTag);
00952         }
00953     }
00954 
00955     <span class="keywordflow">if</span> (phead == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00956         RIPERR0(ERROR_NOT_ENOUGH_MEMORY,
00957                 RIP_WARNING,
00958                 <span class="stringliteral">"USER: HMAllocObject: out of memory"</span>);
00959         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00960     }
00961     <span class="comment">/*</span>
00962 <span class="comment">     * We're going to use this handle so get it off its free list.</span>
00963 <span class="comment">     * The free handle phead points to the next free handle.</span>
00964 <span class="comment">     */</span>
00965     iheFree = *piheFreeHead;
00966     pheT = &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[iheFree];
00967     *piheFreeHead = (ULONG_PTR)pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>;
00968     <a class="code" href="../../d4/d8/handtabl_8c.html#a3">DBGHMValidateFreeLists</a>();
00969     <span class="comment">/*</span>
00970 <span class="comment">     * Track high water mark for handle allocation.</span>
00971 <span class="comment">     */</span>
00972     <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>)iheFree &gt; <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a308">giheLast</a>) {
00973         <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a308">giheLast</a> = (<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>)iheFree;
00974     }
00975     <span class="comment">/*</span>
00976 <span class="comment">     * Setup the handle contents, plus initialize the object header.</span>
00977 <span class="comment">     */</span>
00978     pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> = bType;
00979     pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a> = phead;
00980     UserAssert(pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> == 0);
00981     <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a>) {
00982         <span class="keywordflow">if</span> ((ptiOwner-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o9">TIF_flags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a796">TIF_16BIT</a>) &amp;&amp; (ptiOwner-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o22">ptdb</a>)) {
00983             ((<a class="code" href="../../d8/d0/struct__PROCOBJHEAD.html">PPROCOBJHEAD</a>)phead)-&gt;hTaskWow = ptiOwner-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o22">ptdb</a>-&gt;<a class="code" href="../../d0/d8/structtagTDB.html#o5">hTaskWow</a>;
00984         } <span class="keywordflow">else</span> {
00985             ((<a class="code" href="../../d8/d0/struct__PROCOBJHEAD.html">PPROCOBJHEAD</a>)phead)-&gt;hTaskWow = 0;
00986         }
00987         pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> = ptiOwner-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o2">ppi</a>;
00988         <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a415">OCF_MARKPROCESS</a>) {
00989             ((<a class="code" href="../../d7/d0/struct__PROCMARKHEAD.html">PPROCMARKHEAD</a>)phead)-&gt;ppi = ptiOwner-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o2">ppi</a>;
00990         }
00991     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a>) {
00992         ((<a class="code" href="../../d1/d1/struct__THROBJHEAD.html">PTHROBJHEAD</a>)phead)-&gt;pti = pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> = ptiOwner;
00993     } <span class="keywordflow">else</span> {
00994         <span class="comment">/*</span>
00995 <span class="comment">         * The caller is wasting time if ptiOwner != NULL</span>
00996 <span class="comment">         * The handle entry must already have pOwner == NULL.</span>
00997 <span class="comment">         */</span>
00998         UserAssert(ptiOwner == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00999         UserAssert(pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01000     }
01001 
01002     phead-&gt;<a class="code" href="../../d4/d5/struct__HEAD.html#o0">h</a> = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a431">HMHandleFromIndex</a>(iheFree);
01003 
01004     <span class="keywordflow">if</span> (ppiQuotaCharge) {
01005         ppiQuotaCharge-&gt;UserHandleCount++;
01006         <a class="code" href="../../d4/d8/handtabl_8c.html#a2">DBGValidateHandleQuota</a>();
01007     }
01008 
01009 <span class="preprocessor">#if DBG</span>
01010 <span class="preprocessor"></span>    <span class="comment">/*</span>
01011 <span class="comment">     *   performance counter dumphmgr</span>
01012 <span class="comment">     *   dwPrevCount is used for the snapshot option</span>
01013 <span class="comment">     */</span>
01014 
01015     gaPerfhti[bType].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o2">lTotalCount</a>++;
01016     gaPerfhti[bType].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o0">lCount</a>++;
01017     <span class="keywordflow">if</span> (gaPerfhti[bType].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o0">lCount</a> &gt; gaPerfhti[bType].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o1">lMaxCount</a>) {
01018         gaPerfhti[bType].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o1">lMaxCount</a> = gaPerfhti[bType].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o0">lCount</a>;
01019     }
01020     <span class="keywordflow">if</span> ((bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>) &amp;&amp; (pdeskSrc != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01021         gaPerfhti[bType].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o3">lSize</a> += <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a21">RtlSizeHeap</a>(Win32HeapGetHandle(pdeskSrc-&gt;<a class="code" href="../../d0/d3/structtagDESKTOP.html#o16">pheapDesktop</a>), 0, phead);
01022     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a419">OCF_SHAREDHEAP</a>) {
01023         gaPerfhti[bType].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o3">lSize</a> += <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a21">RtlSizeHeap</a>(Win32HeapGetHandle(<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a322">gpvSharedAlloc</a>), 0, phead);
01024     } <span class="keywordflow">else</span> {
01025         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  notUsed;
01026         gaPerfhti[bType].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o3">lSize</a> += <a class="code" href="../../d5/d8/ex_8h.html#a228">ExQueryPoolBlockSize</a>(phead, &amp;notUsed);
01027     }
01028 
01029 <span class="preprocessor">#endif // DBG</span>
01030 <span class="preprocessor"></span>
01031     <span class="comment">/*</span>
01032 <span class="comment">     * Return a handle entry pointer.</span>
01033 <span class="comment">     */</span>
01034     <span class="keywordflow">return</span> pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>;
01035 }
01036 
01037 
01038 
01039 <span class="preprocessor">#if 0</span>
01040 <span class="preprocessor"></span><span class="preprocessor">#define HANDLEF_FREECHECK 0x80</span>
01041 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> CheckHMTable(
01042     PVOID pobj)
01043 {
01044     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> pheT, pheMax;
01045 
01046     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a308">giheLast</a>) {
01047         pheMax = &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a308">giheLast</a>];
01048         <span class="keywordflow">for</span> (pheT = <a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>; pheT &lt;= pheMax; pheT++) {
01049             <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>) {
01050                 <span class="keywordflow">continue</span>;
01051             }
01052             <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a> == pobj &amp;&amp; !(pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; HANDLEF_FREECHECK)) {
01053                 UserAssert(FALSE);
01054             }
01055         }
01056     }
01057 }
01058 <span class="preprocessor">#endif</span>
01059 <span class="preprocessor"></span>
01060 
01061 <span class="comment">/***************************************************************************\</span>
01062 <span class="comment">* HMFreeObject</span>
01063 <span class="comment">*</span>
01064 <span class="comment">* Frees an object - the handle and the referenced memory.</span>
01065 <span class="comment">*</span>
01066 <span class="comment">* 01-13-92 ScottLu      Created.</span>
01067 <span class="comment">\***************************************************************************/</span>
01068 
<a name="l01069"></a><a class="code" href="../../d4/d1/userk_8h.html#a970">01069</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d4/d1/userk_8h.html#a970">HMFreeObject</a>(
01070     PVOID pobj)
01071 {
01072     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a>         pheT;
01073     WORD        wUniqT;
01074     <a class="code" href="../../d4/d4/struct__HANDLEPAGE.html">PHANDLEPAGE</a> php;
01075     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>       i;
01076     ULONG_PTR    iheCurrent, *piheCurrentHead;
01077     <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a>        bCreateFlags;
01078     <a class="code" href="../../d0/d3/structtagDESKTOP.html">PDESKTOP</a>    pdesk;
01079     <a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a> ppiQuotaCharge = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01080 <span class="preprocessor">#if DBG</span>
01081 <span class="preprocessor"></span>    <a class="code" href="../../d1/d3/struct__LOCKRECORD.html">PLR</a>         plrT, plrNextT;
01082     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  notUsed;
01083 <span class="preprocessor">#endif</span>
01084 <span class="preprocessor"></span>
01085     UserAssert(((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)pobj)-&gt;cLockObj == 0);
01086     UserAssert(pobj == <a class="code" href="../../d4/d1/userk_8h.html#a101">HtoPqCat</a>(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a449">PtoHq</a>(pobj)));
01087     <span class="comment">/*</span>
01088 <span class="comment">     * Free the object first.</span>
01089 <span class="comment">     */</span>
01090     pheT = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a446">HMPheFromObject</a>(pobj);
01091     bCreateFlags = <a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html#o2">bObjectCreateFlags</a>;
01092 
01093     UserAssertMsg1(pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> != <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>,
01094                    <span class="stringliteral">"Object already marked as freed!!! %#p"</span>, pobj);
01095 
01096     <span class="comment">/*</span>
01097 <span class="comment">     * decr process handle use</span>
01098 <span class="comment">     */</span>
01099     <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a>) {
01100         ppiQuotaCharge = (<a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a>)pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>;
01101         UserAssert(ppiQuotaCharge != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01102     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a>) {
01103         ppiQuotaCharge = (<a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a>)(((<a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a>)(pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>))-&gt;ppi);
01104         UserAssert(ppiQuotaCharge != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01105     } <span class="keywordflow">else</span> {
01106         ppiQuotaCharge = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01107     }
01108 
01109     <span class="keywordflow">if</span> (ppiQuotaCharge != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01110         ppiQuotaCharge-&gt;UserHandleCount--;
01111     }
01112 
01113     <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a426">HANDLEF_GRANTED</a>) {
01114         <a class="code" href="../../d4/d1/userk_8h.html#a978">HMCleanupGrantedHandle</a>(pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>-&gt;<a class="code" href="../../d4/d5/struct__HEAD.html#o0">h</a>);
01115         pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp;= ~<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a426">HANDLEF_GRANTED</a>;
01116     }
01117 
01118 <span class="preprocessor">#if DBG</span>
01119 <span class="preprocessor"></span>    <span class="comment">/*</span>
01120 <span class="comment">     *   performance counters</span>
01121 <span class="comment">     */</span>
01122     gaPerfhti[pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o0">lCount</a>--;
01123 
01124     <span class="keywordflow">if</span> ((bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>) &amp;&amp; ((<a class="code" href="../../d8/d2/struct__DESKOBJHEAD.html">PDESKOBJHEAD</a>)pobj)-&gt;rpdesk) {
01125         pdesk = ((<a class="code" href="../../d8/d2/struct__DESKOBJHEAD.html">PDESKOBJHEAD</a>)pobj)-&gt;rpdesk;
01126         gaPerfhti[pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o3">lSize</a> -= <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a21">RtlSizeHeap</a>(Win32HeapGetHandle(pdesk-&gt;<a class="code" href="../../d0/d3/structtagDESKTOP.html#o16">pheapDesktop</a>), 0, pobj);
01127     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a419">OCF_SHAREDHEAP</a>) {
01128         gaPerfhti[pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o3">lSize</a> -= <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a21">RtlSizeHeap</a>(Win32HeapGetHandle(<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a322">gpvSharedAlloc</a>), 0, pobj);
01129     } <span class="keywordflow">else</span> {
01130         gaPerfhti[pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d3/structtagPERFINFO.html#o3">lSize</a> -= <a class="code" href="../../d5/d8/ex_8h.html#a228">ExQueryPoolBlockSize</a>(pobj, &amp;notUsed);
01131     }
01132 
01133 <span class="preprocessor">#endif // DBG</span>
01134 <span class="preprocessor"></span>
01135     <span class="keywordflow">if</span> ((bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a417">OCF_DESKTOPHEAP</a>)) {
01136 <span class="preprocessor">#if DBG</span>
01137 <span class="preprocessor"></span>        <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> bSuccess;
01138 <span class="preprocessor">#endif</span>
01139 <span class="preprocessor"></span>        UserAssert(((<a class="code" href="../../d8/d2/struct__DESKOBJHEAD.html">PDESKOBJHEAD</a>)pobj)-&gt;rpdesk != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01140 
01141         pdesk = ((<a class="code" href="../../d8/d2/struct__DESKOBJHEAD.html">PDESKOBJHEAD</a>)pobj)-&gt;rpdesk;
01142         <a class="code" href="../../d4/d1/userk_8h.html#a127">UnlockDesktop</a>(&amp;((<a class="code" href="../../d8/d2/struct__DESKOBJHEAD.html">PDESKOBJHEAD</a>)pobj)-&gt;rpdesk, LDU_OBJ_DESK, (ULONG_PTR)pobj);
01143 
01144         <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; <a class="code" href="../../d1/d0/inc_2user_8h.html#a417">HANDLEF_POOL</a>) {
01145             UserFreePool(pobj);
01146         } <span class="keywordflow">else</span> {
01147 
01148 <span class="preprocessor">#if DBG</span>
01149 <span class="preprocessor"></span>            bSuccess =
01150 <span class="preprocessor">#endif</span>
01151 <span class="preprocessor"></span>            <a class="code" href="../../d4/d1/userk_8h.html#a313">DesktopFree</a>(pdesk, pobj);
01152 <span class="preprocessor">#if DBG</span>
01153 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (!bSuccess) {
01154                 <span class="comment">/*</span>
01155 <span class="comment">                 * We would hit this assert in HYDRA trying to free the</span>
01156 <span class="comment">                 * mother desktop window which was allocated out of pool</span>
01157 <span class="comment">                 */</span>
01158                 RIPMSG1(RIP_ERROR, <span class="stringliteral">"Object already freed from desktop heap! %#p"</span>, pobj);
01159             }
01160 <span class="preprocessor">#endif</span>
01161 <span class="preprocessor"></span>        }
01162 
01163     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a419">OCF_SHAREDHEAP</a>) {
01164         <a class="code" href="../../d4/d1/userk_8h.html#a1001">SharedFree</a>(pobj);
01165     } <span class="keywordflow">else</span> {
01166         UserFreePool(pobj);
01167     }
01168 
01169 <span class="preprocessor">#if DBG</span>
01170 <span class="preprocessor"></span>    <span class="comment">/*</span>
01171 <span class="comment">     * Go through and delete the lock records, if they exist.</span>
01172 <span class="comment">     */</span>
01173     <span class="keywordflow">for</span> (plrT = pheT-&gt;plr; plrT != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; plrT = plrNextT) {
01174 
01175         <span class="comment">/*</span>
01176 <span class="comment">         * Remember the next one before freeing this one.</span>
01177 <span class="comment">         */</span>
01178         plrNextT = plrT-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o0">plrNext</a>;
01179         FreeLockRecord((HANDLE)plrT);
01180     }
01181 <span class="preprocessor">#endif</span>
01182 <span class="preprocessor"></span>
01183     <span class="comment">/*</span>
01184 <span class="comment">     * Clear the handle contents. Need to remember the uniqueness across</span>
01185 <span class="comment">     * the clear. Also, advance uniqueness on free so that uniqueness checking</span>
01186 <span class="comment">     * against old handles also fails.</span>
01187 <span class="comment">     */</span>
01188     wUniqT = (WORD)((pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o4">wUniq</a> + 1) &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a430">HMUNIQBITS</a>);
01189     RtlZeroMemory(pheT, <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">HANDLEENTRY</a>));
01190     pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o4">wUniq</a> = wUniqT;
01191 
01192     <span class="comment">/*</span>
01193 <span class="comment">     * Change the handle type to TYPE_FREE so we know what type this handle</span>
01194 <span class="comment">     * is. (TYPE_FREE is defined as zero)</span>
01195 <span class="comment">     */</span>
01196     <span class="comment">/* pheT-&gt;bType = TYPE_FREE; */</span>
01197     UserAssert(pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>);
01198 
01199     <span class="comment">/*</span>
01200 <span class="comment">     * Put the handle on the free list of the appropriate page.</span>
01201 <span class="comment">     */</span>
01202     php = <a class="code" href="../../d4/d8/handtabl_8c.html#a8">gpHandlePages</a>;
01203     iheCurrent = pheT - <a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>;
01204     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d4/d8/handtabl_8c.html#a7">gcHandlePages</a>; ++i, ++php) {
01205         <span class="keywordflow">if</span> (iheCurrent &lt; php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o0">iheLimit</a>) {
01206             piheCurrentHead = (iheCurrent &amp; 0x1 ? &amp;php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o2">iheFreeOdd</a> : &amp;php-&gt;<a class="code" href="../../d4/d4/struct__HANDLEPAGE.html#o1">iheFreeEven</a>);
01207             pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a> = (<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)*piheCurrentHead;
01208             *piheCurrentHead = iheCurrent;
01209             <a class="code" href="../../d4/d8/handtabl_8c.html#a3">DBGHMValidateFreeLists</a>();
01210             <span class="keywordflow">break</span>;
01211         }
01212     }
01213     <span class="comment">/*</span>
01214 <span class="comment">     * We must have found it.</span>
01215 <span class="comment">     */</span>
01216     UserAssert(i &lt; <a class="code" href="../../d4/d8/handtabl_8c.html#a7">gcHandlePages</a>);
01217 
01218     UserAssert(pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01219 
01220     <a class="code" href="../../d4/d8/handtabl_8c.html#a2">DBGValidateHandleQuota</a>();
01221 
01222     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01223 }
01224 
01225 
01226 <span class="comment">/***************************************************************************\</span>
01227 <span class="comment">* HMMarkObjectDestroy</span>
01228 <span class="comment">*</span>
01229 <span class="comment">* Marks an object for destruction.</span>
01230 <span class="comment">*</span>
01231 <span class="comment">* Returns TRUE if the object can be destroyed; that is, if it's</span>
01232 <span class="comment">* lock count is 0.</span>
01233 <span class="comment">*</span>
01234 <span class="comment">* 02-10-92 ScottLu      Created.</span>
01235 <span class="comment">\***************************************************************************/</span>
01236 
<a name="l01237"></a><a class="code" href="../../d4/d1/userk_8h.html#a971">01237</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d4/d1/userk_8h.html#a971">HMMarkObjectDestroy</a>(
01238     PVOID pobj)
01239 {
01240     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> phe;
01241 
01242     phe = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a446">HMPheFromObject</a>(pobj);
01243 
01244 <span class="preprocessor">#if DEBUGTAGS</span>
01245 <span class="preprocessor"></span>    <span class="comment">/*</span>
01246 <span class="comment">     * Record where the object was marked for destruction.</span>
01247 <span class="comment">     */</span>
01248     <span class="keywordflow">if</span> (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
01249         <span class="keywordflow">if</span> (!(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a421">HANDLEF_DESTROY</a>)) {
01250             <a class="code" href="../../d4/d8/handtabl_8c.html#a11">HMRecordLock</a>(<a class="code" href="../../d4/d1/userk_8h.html#a265">LOCKRECORD_MARKDESTROY</a>, pobj, ((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)pobj)-&gt;cLockObj);
01251         }
01252     }
01253 <span class="preprocessor">#endif</span>
01254 <span class="preprocessor"></span>
01255     <span class="comment">/*</span>
01256 <span class="comment">     * Set the destroy flag so our unlock code will know we're trying to</span>
01257 <span class="comment">     * destroy this object.</span>
01258 <span class="comment">     */</span>
01259     phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> |= <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a421">HANDLEF_DESTROY</a>;
01260 
01261     <span class="comment">/*</span>
01262 <span class="comment">     * If this object can't be destroyed, then CLEAR the HANDLEF_INDESTROY</span>
01263 <span class="comment">     * flag - because this object won't be currently "in destruction"!</span>
01264 <span class="comment">     * (if we didn't clear it, when it was unlocked it wouldn't get destroyed).</span>
01265 <span class="comment">     */</span>
01266     <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)pobj)-&gt;cLockObj != 0) {
01267         phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp;= ~<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a422">HANDLEF_INDESTROY</a>;
01268 
01269         <span class="comment">/*</span>
01270 <span class="comment">         * Return FALSE because we can't destroy this object.</span>
01271 <span class="comment">         */</span>
01272         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01273     }
01274 
01275 <span class="preprocessor">#if DBG</span>
01276 <span class="preprocessor"></span>    <span class="comment">/*</span>
01277 <span class="comment">     * Ensure that this function only returns TRUE once.</span>
01278 <span class="comment">     */</span>
01279     UserAssert(!(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a425">HANDLEF_MARKED_OK</a>));
01280     phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> |= <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a425">HANDLEF_MARKED_OK</a>;
01281 <span class="preprocessor">#endif</span>
01282 <span class="preprocessor"></span>
01283     <span class="comment">/*</span>
01284 <span class="comment">     * Return TRUE because Lock count is zero - ok to destroy this object.</span>
01285 <span class="comment">     */</span>
01286     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01287 }
01288 
01289 
01290 <span class="comment">/***************************************************************************\</span>
01291 <span class="comment">* HMDestroyObject</span>
01292 <span class="comment">*</span>
01293 <span class="comment">* This routine marks an object for destruction, and frees it if</span>
01294 <span class="comment">* it is unlocked.</span>
01295 <span class="comment">*</span>
01296 <span class="comment">* 10-13-94 JimA         Created.</span>
01297 <span class="comment">\***************************************************************************/</span>
01298 
<a name="l01299"></a><a class="code" href="../../d4/d1/userk_8h.html#a972">01299</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d4/d1/userk_8h.html#a972">HMDestroyObject</a>(
01300     PVOID pobj)
01301 {
01302     <span class="comment">/*</span>
01303 <span class="comment">     * First mark the object for destruction.  This tells the locking code</span>
01304 <span class="comment">     * that we want to destroy this object when the lock count goes to 0.</span>
01305 <span class="comment">     * If this returns FALSE, we can't destroy the object yet (and can't get</span>
01306 <span class="comment">     * rid of security yet either.)</span>
01307 <span class="comment">     */</span>
01308 
01309     <span class="keywordflow">if</span> (!<a class="code" href="../../d4/d1/userk_8h.html#a971">HMMarkObjectDestroy</a>(pobj))
01310         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01311 
01312     <span class="comment">/*</span>
01313 <span class="comment">     * Ok to destroy...  Free the handle (which will free the object</span>
01314 <span class="comment">     * and the handle).</span>
01315 <span class="comment">     */</span>
01316     <a class="code" href="../../d4/d1/userk_8h.html#a970">HMFreeObject</a>(pobj);
01317     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01318 }
01319 
01320 <span class="preprocessor">#if DBG</span>
01321 <span class="preprocessor"></span>
01322 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01323 InitLockRecordLookaside()
01324 {
01325     LockRecordLookaside = UserAllocPoolNonPaged(<span class="keyword">sizeof</span>(<a class="code" href="../../d1/d8/struct__PAGED__LOOKASIDE__LIST.html">PAGED_LOOKASIDE_LIST</a>),
01326                                                 TAG_LOOKASIDE);
01327     <span class="keywordflow">if</span> (LockRecordLookaside == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01328         <span class="keywordflow">return</span> STATUS_NO_MEMORY;
01329     }
01330 
01331     <a class="code" href="../../d5/d8/ex_8h.html#a250">ExInitializePagedLookasideList</a>(LockRecordLookaside,
01332                                    NULL,
01333                                    NULL,
01334                                    SESSION_POOL_MASK,
01335                                    <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d3/struct__LOCKRECORD.html">LOCKRECORD</a>),
01336                                    TAG_LOCKRECORD,
01337                                    1000);
01338     <span class="keywordflow">return</span> STATUS_SUCCESS;
01339 }
01340 
01341 <a class="code" href="../../d1/d3/struct__LOCKRECORD.html">PLR</a> AllocLockRecord()
01342 {
01343     <a class="code" href="../../d1/d3/struct__LOCKRECORD.html">PLR</a> plr;
01344 
01345     <span class="comment">/*</span>
01346 <span class="comment">     * Allocate a LOCKRECORD structure.</span>
01347 <span class="comment">     */</span>
01348     <span class="keywordflow">if</span> ((plr = <a class="code" href="../../d5/d8/ex_8h.html#a252">ExAllocateFromPagedLookasideList</a>(LockRecordLookaside)) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01349         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01350     }
01351 
01352     RtlZeroMemory(plr, <span class="keyword">sizeof</span>(*plr));
01353 
01354     <span class="keywordflow">return</span> plr;
01355 }
01356 
01357 
01358 <span class="keywordtype">void</span> FreeLockRecord(
01359     <a class="code" href="../../d1/d3/struct__LOCKRECORD.html">PLR</a> plr)
01360 {
01361     <a class="code" href="../../d5/d8/ex_8h.html#a253">ExFreeToPagedLookasideList</a>(LockRecordLookaside, plr);
01362 }
01363 
01364 
01365 <span class="comment">/***************************************************************************\</span>
01366 <span class="comment">* HMRecordLock</span>
01367 <span class="comment">*</span>
01368 <span class="comment">* This routine records a lock on a "lock list", so that locks and unlocks</span>
01369 <span class="comment">* can be tracked in the debugger. Only called if DBGTAG_TrackLocks is enabled.</span>
01370 <span class="comment">*</span>
01371 <span class="comment">* 02-27-92 ScottLu      Created.</span>
01372 <span class="comment">\***************************************************************************/</span>
01373 <span class="keywordtype">void</span> <a class="code" href="../../d4/d8/handtabl_8c.html#a11">HMRecordLock</a>(
01374     PVOID ppobj,
01375     PVOID pobj,
01376     DWORD cLockObj)
01377 {
01378     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a>   phe;
01379     <a class="code" href="../../d1/d3/struct__LOCKRECORD.html">PLR</a>   plr;
01380     <span class="keywordtype">int</span>   i;
01381     ULONG hash;
01382 
01383     phe = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a446">HMPheFromObject</a>(pobj);
01384 
01385     <span class="keywordflow">if</span> ((plr = AllocLockRecord()) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01386         RIPMSG0(RIP_ERROR, <span class="stringliteral">"HMRecordLock failed to allocate memory"</span>);
01387         <span class="keywordflow">return</span>;
01388     }
01389 
01390     <span class="comment">/*</span>
01391 <span class="comment">     * Link it in front of the list</span>
01392 <span class="comment">     */</span>
01393     plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o0">plrNext</a> = phe-&gt;plr;
01394     phe-&gt;plr = plr;
01395 
01396     <span class="comment">/*</span>
01397 <span class="comment">     * This propably happens only for unmatched locks</span>
01398 <span class="comment">     */</span>
01399     <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)pobj)-&gt;cLockObj &gt; cLockObj) {
01400 
01401         RIPMSG3(RIP_WARNING, <span class="stringliteral">"Unmatched lock. ppobj %#p pobj %#p cLockObj %d"</span>,
01402                ppobj, pobj, cLockObj);
01403 
01404         i = (<span class="keywordtype">int</span>)cLockObj;
01405         i = -i;
01406         cLockObj = (<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>)i;
01407     }
01408 
01409     plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o2">ppobj</a>    = ppobj;
01410     plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o1">cLockObj</a> = cLockObj;
01411 
01412     GetStackTrace(1,
01413                   LOCKRECORD_STACK,
01414                   plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o3">trace</a>,
01415                   &amp;hash);
01416     <span class="keywordflow">return</span>;
01417 }
01418 <span class="preprocessor">#endif // DBG</span>
01419 <span class="preprocessor"></span>
01420 
01421 <span class="comment">/***************************************************************************\</span>
01422 <span class="comment">* HMLockObject</span>
01423 <span class="comment">*</span>
01424 <span class="comment">* This routine locks an object. This is a macro in retail systems.</span>
01425 <span class="comment">*</span>
01426 <span class="comment">* 02-24-92 ScottLu      Created.</span>
01427 <span class="comment">\***************************************************************************/</span>
01428 
01429 <span class="preprocessor">#if DBG</span>
01430 <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="../../d4/d1/userk_8h.html#a112">HMLockObject</a>(
01431     PVOID pobj)
01432 {
01433     HANDLE h;
01434     PVOID  pobjValidate;
01435 
01436     <span class="comment">/*</span>
01437 <span class="comment">     * Validate by going through the handle entry so that we make sure pobj</span>
01438 <span class="comment">     * is not just pointing off into space. This may GP fault, but that's</span>
01439 <span class="comment">     * ok: this case should not ever happen if we're bug free.</span>
01440 <span class="comment">     */</span>
01441 
01442     h = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a446">HMPheFromObject</a>(pobj)-&gt;phead-&gt;h;
01443     pobjValidate = <a class="code" href="../../d1/d0/inc_2user_8h.html#a429">HMRevalidateCatHandle</a>(h);
01444     <span class="keywordflow">if</span> (!pobj || pobj != pobjValidate) {
01445         RIPMSG2(RIP_ERROR,
01446                 <span class="stringliteral">"HMLockObject invalid object %#p, handle %#p"</span>,
01447                 pobj, h);
01448         <span class="keywordflow">return</span>;
01449     }
01450 
01451     <span class="comment">/*</span>
01452 <span class="comment">     * Inc the reference count.</span>
01453 <span class="comment">     */</span>
01454     ((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)pobj)-&gt;cLockObj++;
01455 
01456     <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)pobj)-&gt;cLockObj == 0)
01457         RIPMSG1(RIP_ERROR, <span class="stringliteral">"Object lock count has overflowed: %#p"</span>, pobj);
01458 }
01459 <span class="preprocessor">#endif // DBG</span>
01460 <span class="preprocessor"></span>
01461 
01462 <span class="comment">/***************************************************************************\</span>
01463 <span class="comment">* HMUnlockObjectInternal</span>
01464 <span class="comment">*</span>
01465 <span class="comment">* This routine is called from the macro HMUnlockObject when an object's</span>
01466 <span class="comment">* reference count drops to zero. This routine will destroy an object</span>
01467 <span class="comment">* if is has been marked for destruction.</span>
01468 <span class="comment">*</span>
01469 <span class="comment">* 01-21-92 ScottLu      Created.</span>
01470 <span class="comment">\***************************************************************************/</span>
01471 
<a name="l01472"></a><a class="code" href="../../d4/d1/userk_8h.html#a979">01472</a> PVOID <a class="code" href="../../d4/d1/userk_8h.html#a979">HMUnlockObjectInternal</a>(
01473     PVOID pobj)
01474 {
01475     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> phe;
01476 
01477     <span class="comment">/*</span>
01478 <span class="comment">     * The object is not reference counted. If the object is not a zombie,</span>
01479 <span class="comment">     * return success because the object is still around.</span>
01480 <span class="comment">     */</span>
01481     phe = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a446">HMPheFromObject</a>(pobj);
01482     <span class="keywordflow">if</span> (!(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a421">HANDLEF_DESTROY</a>))
01483         <span class="keywordflow">return</span> pobj;
01484 
01485     <span class="comment">/*</span>
01486 <span class="comment">     * We're destroying the object based on an unlock... Make sure it isn't</span>
01487 <span class="comment">     * currently being destroyed! (It is valid to have lock counts go from</span>
01488 <span class="comment">     * 0 to != 0 to 0 during destruction... don't want recursion into</span>
01489 <span class="comment">     * the destroy routine.</span>
01490 <span class="comment">     */</span>
01491     <span class="keywordflow">if</span> (phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a422">HANDLEF_INDESTROY</a>)
01492         <span class="keywordflow">return</span> pobj;
01493 
01494     <a class="code" href="../../d4/d1/userk_8h.html#a977">HMDestroyUnlockedObject</a>(phe);
01495     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01496 }
01497 
01498 
01499 <span class="comment">/***************************************************************************\</span>
01500 <span class="comment">* HMAssignmentLock</span>
01501 <span class="comment">*</span>
01502 <span class="comment">* This api is used for structure and global variable assignment.</span>
01503 <span class="comment">* Returns pobjOld if the object was *not* destroyed. Means the object is</span>
01504 <span class="comment">* still valid.</span>
01505 <span class="comment">*</span>
01506 <span class="comment">* 02-24-92 ScottLu      Created.</span>
01507 <span class="comment">\***************************************************************************/</span>
01508 
<a name="l01509"></a><a class="code" href="../../d4/d1/userk_8h.html#a973">01509</a> PVOID <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a> <a class="code" href="../../d4/d1/userk_8h.html#a973">HMAssignmentLock</a>(
01510     PVOID *ppobj,
01511     PVOID pobj)
01512 {
01513     PVOID pobjOld;
01514 
01515     pobjOld = *ppobj;
01516     *ppobj = pobj;
01517 
01518     <span class="comment">/*</span>
01519 <span class="comment">     * Unlocks the old, locks the new.</span>
01520 <span class="comment">     */</span>
01521     <span class="keywordflow">if</span> (pobjOld != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01522 
01523         <span class="comment">/*</span>
01524 <span class="comment">         * if we are locking in the same object that is there then</span>
01525 <span class="comment">         * it is a no-op but we don't want to do the Unlock and the Lock</span>
01526 <span class="comment">         * because the unlock could free object and the lock would lock</span>
01527 <span class="comment">         * in a freed pointer; 6410.</span>
01528 <span class="comment">         */</span>
01529         <span class="keywordflow">if</span> (pobjOld == pobj) {
01530             <span class="keywordflow">return</span> pobjOld;
01531         }
01532 
01533 <span class="preprocessor">#if DEBUGTAGS</span>
01534 <span class="preprocessor"></span>
01535         <span class="comment">/*</span>
01536 <span class="comment">         * Track assignment locks.</span>
01537 <span class="comment">         */</span>
01538         <span class="keywordflow">if</span> (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
01539             <span class="keywordflow">if</span> (!<a class="code" href="../../d4/d8/handtabl_8c.html#a12">HMUnrecordLock</a>(ppobj, pobjOld)) {
01540                 <a class="code" href="../../d4/d8/handtabl_8c.html#a11">HMRecordLock</a>(ppobj, pobjOld, ((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)pobjOld)-&gt;cLockObj - 1);
01541             }
01542         }
01543 <span class="preprocessor">#endif</span>
01544 <span class="preprocessor"></span>
01545     }
01546 
01547 
01548     <span class="keywordflow">if</span> (pobj != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01549         UserAssert(pobj == <a class="code" href="../../d1/d0/inc_2user_8h.html#a1181">HMValidateCatHandleNoSecure</a>(((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)pobj)-&gt;h, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a255">TYPE_GENERIC</a>));
01550         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a438">HMIsMarkDestroy</a>(pobj)) {
01551             RIPERR2(ERROR_INVALID_PARAMETER,
01552                     RIP_WARNING,
01553                     <span class="stringliteral">"HMAssignmentLock, locking object %#p marked for destruction at %#p\n"</span>,
01554                     pobj, ppobj);
01555         }
01556 <span class="preprocessor">#if DEBUGTAGS</span>
01557 <span class="preprocessor"></span>
01558         <span class="comment">/*</span>
01559 <span class="comment">         * Track assignment locks.</span>
01560 <span class="comment">         */</span>
01561         <span class="keywordflow">if</span> (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
01562             <a class="code" href="../../d4/d8/handtabl_8c.html#a11">HMRecordLock</a>(ppobj, pobj, ((<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1015">PHEAD</a>)pobj)-&gt;cLockObj + 1);
01563             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a438">HMIsMarkDestroy</a>(pobj)) {
01564 
01565                 RIPMSG2(RIP_WARNING,
01566                         <span class="stringliteral">"Locking object %#p marked for destruction at %#p"</span>,
01567                         pobj, ppobj);
01568             }
01569         }
01570 <span class="preprocessor">#endif</span>
01571 <span class="preprocessor"></span>        <a class="code" href="../../d4/d1/userk_8h.html#a112">HMLockObject</a>(pobj);
01572     }
01573 
01574 <span class="comment">/*</span>
01575 <span class="comment"> * This unlock has been moved from up above, so that we implement a</span>
01576 <span class="comment"> * "lock before unlock" strategy.  Just in case pobjOld was the</span>
01577 <span class="comment"> * only object referencing pobj, pobj won't go away when we unlock</span>
01578 <span class="comment"> * pobjNew -- it will have been locked above.</span>
01579 <span class="comment"> */</span>
01580 
01581     <span class="keywordflow">if</span> (pobjOld) {
01582         pobjOld = <a class="code" href="../../d4/d1/userk_8h.html#a110">HMUnlockObject</a>(pobjOld);
01583     }
01584 
01585     <span class="keywordflow">return</span> pobjOld;
01586 }
01587 
01588 
01589 <span class="comment">/***************************************************************************\</span>
01590 <span class="comment">* HMAssignmentLock</span>
01591 <span class="comment">*</span>
01592 <span class="comment">* This api is used for structure and global variable assignment.</span>
01593 <span class="comment">* Returns pobjOld if the object was *not* destroyed. Means the object is</span>
01594 <span class="comment">* still valid.</span>
01595 <span class="comment">*</span>
01596 <span class="comment">* 02-24-92 ScottLu      Created.</span>
01597 <span class="comment">\***************************************************************************/</span>
01598 
<a name="l01599"></a><a class="code" href="../../d4/d1/userk_8h.html#a974">01599</a> PVOID <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a> <a class="code" href="../../d4/d1/userk_8h.html#a974">HMAssignmentUnlock</a>(
01600     PVOID *ppobj)
01601 {
01602     PVOID pobjOld;
01603 
01604     pobjOld = *ppobj;
01605     *ppobj = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01606 
01607     <span class="comment">/*</span>
01608 <span class="comment">     * Unlocks the old, locks the new.</span>
01609 <span class="comment">     */</span>
01610     <span class="keywordflow">if</span> (pobjOld != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01611 
01612 <span class="preprocessor">#if DEBUGTAGS</span>
01613 <span class="preprocessor"></span>
01614         <span class="comment">/*</span>
01615 <span class="comment">         * Track assignment locks.</span>
01616 <span class="comment">         */</span>
01617         <span class="keywordflow">if</span> (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
01618             <span class="keywordflow">if</span> (!<a class="code" href="../../d4/d8/handtabl_8c.html#a12">HMUnrecordLock</a>(ppobj, pobjOld)) {
01619                 <a class="code" href="../../d4/d8/handtabl_8c.html#a11">HMRecordLock</a>(ppobj, pobjOld, ((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)pobjOld)-&gt;cLockObj - 1);
01620             }
01621         }
01622 <span class="preprocessor">#endif</span>
01623 <span class="preprocessor"></span>        pobjOld = <a class="code" href="../../d4/d1/userk_8h.html#a110">HMUnlockObject</a>(pobjOld);
01624     }
01625 
01626     <span class="keywordflow">return</span> pobjOld;
01627 }
01628 
01629 
01630 <span class="comment">/***************************************************************************\</span>
01631 <span class="comment">* IsValidThreadLock</span>
01632 <span class="comment">*</span>
01633 <span class="comment">* This routine checks to make sure that the thread lock structures passed</span>
01634 <span class="comment">* in are valid.</span>
01635 <span class="comment">*</span>
01636 <span class="comment">* 03-17-92 ScottLu      Created.</span>
01637 <span class="comment">* 02-22-99 MCostea      Also validate the shadow of the stack TL</span>
01638 <span class="comment">*                       from gThreadLocksArray</span>
01639 <span class="comment">\***************************************************************************/</span>
01640 <span class="preprocessor">#if DBG</span>
01641 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> IsValidThreadLock(<a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> pti, <a class="code" href="../../d5/d1/struct__TL.html">PTL</a> ptl, ULONG_PTR dwLimit, BOOLEAN fHM)
01642 {
01643     <span class="comment">/*</span>
01644 <span class="comment">     * Check that ptl is a valid stack address</span>
01645 <span class="comment">     * Allow (ULONG_PTR)ptl == dwLimit so we can call ValidateThreadLocks passing</span>
01646 <span class="comment">     *  the address of the last thing we locked.</span>
01647 <span class="comment">     */</span>
01648     UserAssert((ULONG_PTR)ptl &gt;= dwLimit);
01649     UserAssert((ULONG_PTR)ptl &lt; (ULONG_PTR)KeGetCurrentThread()-&gt;StackBase);
01650     <span class="comment">/*</span>
01651 <span class="comment">     * Check ptl owner.</span>
01652 <span class="comment">     */</span>
01653     UserAssert(ptl-&gt;pW32Thread == (PW32THREAD)pti);
01654     <span class="comment">/*</span>
01655 <span class="comment">     * If this is an HM object, verify handle and lock count (guess max value)</span>
01656 <span class="comment">     */</span>
01657     <span class="keywordflow">if</span> (fHM &amp;&amp; (ptl-&gt;pobj != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01658         <span class="comment">/*</span>
01659 <span class="comment">         * The locked object could be a destroyed object.</span>
01660 <span class="comment">         */</span>
01661         UserAssert(ptl-&gt;pobj == <a class="code" href="../../d4/d1/userk_8h.html#a101">HtoPqCat</a>(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a449">PtoHq</a>(ptl-&gt;pobj)));
01662         <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)ptl-&gt;pobj)-&gt;cLockObj &gt;= 32000) {
01663             RIPMSG2(RIP_WARNING, <span class="stringliteral">"IsValidThreadLock: Object %#p has %d locks"</span>, ptl-&gt;pobj, ((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)ptl-&gt;pobj)-&gt;cLockObj);
01664         }
01665     }
01666     <span class="comment">/*</span>
01667 <span class="comment">     * Make sure the shadow in gThreadLocksArray is doing fine</span>
01668 <span class="comment">     */</span>
01669     UserAssert(ptl-&gt;ptl-&gt;ptl == ptl);
01670 }
01671 <span class="preprocessor">#endif</span>
01672 <span class="preprocessor"></span>
01673 <span class="comment">/***************************************************************************\</span>
01674 <span class="comment">* ValidateThreadLocks</span>
01675 <span class="comment">*</span>
01676 <span class="comment">* This routine validates the thread lock list of a thread.</span>
01677 <span class="comment">*</span>
01678 <span class="comment">* 03-10-92 ScottLu      Created.</span>
01679 <span class="comment">\***************************************************************************/</span>
01680 
01681 <span class="preprocessor">#if DBG</span>
01682 <span class="preprocessor"></span>ULONG ValidateThreadLocks(<a class="code" href="../../d5/d1/struct__TL.html">PTL</a> NewLock, <a class="code" href="../../d5/d1/struct__TL.html">PTL</a> OldLock, ULONG_PTR dwLimit, BOOLEAN fHM)
01683 {
01684     <a class="code" href="../../d9/d5/ndismain_8h.html#a265">UINT</a> uTLCount = 0;
01685     <a class="code" href="../../d5/d1/struct__TL.html">PTL</a> ptlTopLock = OldLock;
01686     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent;
01687 
01688     BEGIN_REENTERCRIT();
01689 
01690     ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>();
01691 
01692     <span class="comment">/*</span>
01693 <span class="comment">     * Validate the new thread lock.</span>
01694 <span class="comment">     */</span>
01695     <span class="keywordflow">if</span> (NewLock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01696         UserAssert(NewLock-&gt;next == OldLock);
01697         IsValidThreadLock(ptiCurrent, NewLock, dwLimit, fHM);
01698         uTLCount++;
01699     }
01700 
01701     <span class="comment">/*</span>
01702 <span class="comment">     * Loop through the list of thread locks and check to make sure the</span>
01703 <span class="comment">     * new lock is not in the list and that list is valid.</span>
01704 <span class="comment">     */</span>
01705     <span class="keywordflow">while</span> (OldLock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01706         <span class="comment">/*</span>
01707 <span class="comment">         * The new lock must not be the same as the old lock.</span>
01708 <span class="comment">         */</span>
01709         UserAssert(NewLock != OldLock);
01710         <span class="comment">/*</span>
01711 <span class="comment">         * Validate the old thread lock.</span>
01712 <span class="comment">         */</span>
01713         IsValidThreadLock(ptiCurrent, OldLock, dwLimit, fHM);
01714         uTLCount++;
01715         OldLock = OldLock-&gt;next;
01716     }
01717     <span class="comment">/*</span>
01718 <span class="comment">     * If this is thread lock, set uTLCount, else verify it</span>
01719 <span class="comment">     */</span>
01720     <span class="keywordflow">if</span> (NewLock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01721         NewLock-&gt;uTLCount = uTLCount;
01722     } <span class="keywordflow">else</span> {
01723         <span class="keywordflow">if</span> (ptlTopLock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01724             RIPMSG0(RIP_WARNING, <span class="stringliteral">"ptlTopLock is NULL, the system will AV now"</span>);
01725         }
01726         UserAssert(uTLCount == ptlTopLock-&gt;uTLCount);
01727     }
01728 
01729     END_REENTERCRIT();
01730 
01731     <span class="keywordflow">return</span> uTLCount;
01732 }
01733 <span class="preprocessor">#endif</span>
01734 <span class="preprocessor"></span>
01735 
01736 <span class="comment">/***************************************************************************\</span>
01737 <span class="comment">* CreateShadowTL</span>
01738 <span class="comment">*</span>
01739 <span class="comment">* This function creates a shaddow for the stack allocated ptl parameter</span>
01740 <span class="comment">* in the global thread locks arrays</span>
01741 <span class="comment">*</span>
01742 <span class="comment">* 08-04-99 MCostea      Created.</span>
01743 <span class="comment">\***************************************************************************/</span>
01744 
01745 <span class="preprocessor">#if DBG</span>
01746 <span class="preprocessor"></span><span class="keywordtype">void</span>
01747 CreateShadowTL(<a class="code" href="../../d5/d1/struct__TL.html">PTL</a> ptl)
01748 {
01749     <a class="code" href="../../d5/d1/struct__TL.html">PTL</a> pTLNextFree;
01750     <span class="keywordflow">if</span> (gFreeTLList-&gt;next == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01751         UserAssert(gcThreadLocksArraysAllocated &lt; MAX_THREAD_LOCKS_ARRAYS &amp;&amp;
01752                    <span class="stringliteral">"No more room in gpaThreadLocksArrays!  The system will bugcheck."</span>);
01753         gFreeTLList-&gt;next = gpaThreadLocksArrays[gcThreadLocksArraysAllocated] =
01754             UserAllocPoolZInit(<span class="keyword">sizeof</span>(<a class="code" href="../../d5/d1/struct__TL.html">TL</a>)*MAX_THREAD_LOCKS, TAG_GLOBALTHREADLOCK);
01755         <span class="keywordflow">if</span> (gFreeTLList-&gt;next == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01756             UserAssert(<span class="stringliteral">"Can't allocate memory for gpaThreadLocksArrays: the system will bugcheck soon!"</span>);
01757         }
01758         InitGlobalThreadLockArray(gcThreadLocksArraysAllocated);
01759         gcThreadLocksArraysAllocated++;
01760     }
01761     pTLNextFree = gFreeTLList-&gt;next;
01762     RtlCopyMemory(gFreeTLList, ptl, <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d1/struct__TL.html">TL</a>));
01763     gFreeTLList-&gt;ptl = ptl;
01764     ptl-&gt;ptl = gFreeTLList;
01765     gFreeTLList = pTLNextFree;
01766 }
01767 <span class="preprocessor">#endif // DBG</span>
01768 <span class="preprocessor"></span>
01769 <span class="comment">/***************************************************************************\</span>
01770 <span class="comment">* ThreadLock</span>
01771 <span class="comment">*</span>
01772 <span class="comment">* This api is used for locking objects across callbacks, so they are still</span>
01773 <span class="comment">* there when the callback returns.</span>
01774 <span class="comment">*</span>
01775 <span class="comment">* 03-04-92 ScottLu      Created.</span>
01776 <span class="comment">\***************************************************************************/</span>
01777 
01778 <span class="preprocessor">#if DBG</span>
01779 <span class="preprocessor"></span><span class="keywordtype">void</span>
01780 <a class="code" href="../../d6/d0/usercli_8h.html#a36">ThreadLock</a>(
01781     PVOID pobj,
01782     <a class="code" href="../../d5/d1/struct__TL.html">PTL</a> ptl)
01783 
01784 {
01785 
01786     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent;
01787     PVOID pfnT;
01788 
01789 
01790     <span class="comment">/*</span>
01791 <span class="comment">     * This is a handy place, because it is called so often, to see if User is</span>
01792 <span class="comment">     * eating up too much stack.</span>
01793 <span class="comment">     */</span>
01794     UserAssert(((ULONG_PTR)&amp;pfnT - (ULONG_PTR)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;StackLimit) &gt; KERNEL_STACK_MINIMUM_RESERVE);
01795 
01796     <span class="comment">/*</span>
01797 <span class="comment">     * Store the address of the object in the thread lock structure and</span>
01798 <span class="comment">     * link the structure into the thread lock list.</span>
01799 <span class="comment">     *</span>
01800 <span class="comment">     * N.B. The lock structure is always linked into the thread lock list</span>
01801 <span class="comment">     *      regardless of whether the object address is NULL. The reason</span>
01802 <span class="comment">     *      this is done is so the lock address does not need to be passed</span>
01803 <span class="comment">     *      to the unlock function since the first entry in the lock list</span>
01804 <span class="comment">     *      is always the entry to be unlocked.</span>
01805 <span class="comment">     */</span>
01806 
01807     UserAssert(!(<a class="code" href="../../d4/d1/userk_8h.html#a16">PpiCurrent</a>()-&gt;W32PF_Flags &amp; W32PF_TERMINATED));
01808     ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>();
01809     UserAssert(ptiCurrent);
01810 
01811     <span class="comment">/*</span>
01812 <span class="comment">     * Get the callers address and validate the thread lock list.</span>
01813 <span class="comment">     */</span>
01814     <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;ptl-&gt;pfnCaller, &amp;pfnT);
01815     ptl-&gt;pW32Thread = (PW32THREAD)ptiCurrent;
01816 
01817     ptl-&gt;next = ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o1">ptl</a>;
01818     ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o1">ptl</a> = ptl;
01819     ptl-&gt;pobj = pobj;
01820     <span class="keywordflow">if</span> (pobj != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01821         <a class="code" href="../../d4/d1/userk_8h.html#a112">HMLockObject</a>(pobj);
01822     }
01823     CreateShadowTL(ptl);
01824     ValidateThreadLocks(ptl, ptl-&gt;next, (ULONG_PTR)&amp;pobj, TRUE);
01825     <span class="keywordflow">return</span>;
01826 }
01827 <span class="preprocessor">#endif</span>
01828 <span class="preprocessor"></span>
01829 
01830 <span class="comment">/***************************************************************************\</span>
01831 <span class="comment">* ThreadLockExchange</span>
01832 <span class="comment">*</span>
01833 <span class="comment">* Reuses a TL structure by locking the new object and unlocking</span>
01834 <span class="comment">* the old one. This is used where you enumerate a list of</span>
01835 <span class="comment">* structure locked objects, e.g. the window list.</span>
01836 <span class="comment">*</span>
01837 <span class="comment">* History:</span>
01838 <span class="comment">* 05-Mar-1997 adams     Created.</span>
01839 <span class="comment">\***************************************************************************/</span>
01840 
01841 <span class="preprocessor">#if DBG</span>
01842 <span class="preprocessor"></span>PVOID
01843 <a class="code" href="../../d4/d1/userk_8h.html#a982">ThreadLockExchange</a>(PVOID pobj, <a class="code" href="../../d5/d1/struct__TL.html">PTL</a> ptl)
01844 {
01845     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent;
01846     PVOID       pobjOld;
01847     PVOID       pfnT;
01848 
01849     <span class="comment">/*</span>
01850 <span class="comment">     * This is a handy place, because it is called so often, to see if User is</span>
01851 <span class="comment">     * eating up too much stack.</span>
01852 <span class="comment">     */</span>
01853     UserAssert((ULONG_PTR)&amp;pfnT - (ULONG_PTR)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;StackLimit &gt; KERNEL_STACK_MINIMUM_RESERVE);
01854 
01855     <span class="comment">/*</span>
01856 <span class="comment">     * Store the address of the object in the thread lock structure and</span>
01857 <span class="comment">     * link the structure into the thread lock list.</span>
01858 <span class="comment">     *</span>
01859 <span class="comment">     * N.B. The lock structure is always linked into the thread lock list</span>
01860 <span class="comment">     *      regardless of whether the object address is NULL. The reason</span>
01861 <span class="comment">     *      this is done is so the lock address does not need to be passed</span>
01862 <span class="comment">     *      to the unlock function since the first entry in the lock list</span>
01863 <span class="comment">     *      is always the entry to be unlocked.</span>
01864 <span class="comment">     */</span>
01865 
01866     UserAssert(!(<a class="code" href="../../d4/d1/userk_8h.html#a16">PpiCurrent</a>()-&gt;W32PF_Flags &amp; W32PF_TERMINATED));
01867     ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>();
01868     UserAssert(ptiCurrent);
01869 
01870     <span class="comment">/*</span>
01871 <span class="comment">     * Get the callers address.</span>
01872 <span class="comment">     */</span>
01873     <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;ptl-&gt;pfnCaller, &amp;pfnT);
01874     UserAssert(ptl-&gt;pW32Thread == (PW32THREAD)ptiCurrent);
01875 
01876     <span class="comment">/*</span>
01877 <span class="comment">     * Remember the old object.</span>
01878 <span class="comment">     */</span>
01879     pobjOld = ptl-&gt;pobj;
01880 
01881     <span class="comment">/*</span>
01882 <span class="comment">     * Store and lock the new object. It is important to do this step</span>
01883 <span class="comment">     * before unlocking the old object, since the new object might be</span>
01884 <span class="comment">     * structure locked by the old object.</span>
01885 <span class="comment">     */</span>
01886     ptl-&gt;pobj = pobj;
01887     <span class="keywordflow">if</span> (pobj != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01888         <a class="code" href="../../d4/d1/userk_8h.html#a112">HMLockObject</a>(pobj);
01889     }
01890 
01891     <span class="comment">/*</span>
01892 <span class="comment">     * Unlock the old object.</span>
01893 <span class="comment">     */</span>
01894     <span class="keywordflow">if</span> (pobjOld) {
01895         pobjOld = <a class="code" href="../../d4/d1/userk_8h.html#a110">HMUnlockObject</a>((<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)pobjOld);
01896     }
01897     <span class="comment">/*</span>
01898 <span class="comment">     * Validate the entire thread lock list.</span>
01899 <span class="comment">     */</span>
01900     ValidateThreadLocks(NULL, ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o1">ptl</a>, (ULONG_PTR)&amp;pobj, TRUE);
01901     {
01902         <span class="comment">/*</span>
01903 <span class="comment">         * Maintain gFreeTLList</span>
01904 <span class="comment">         */</span>
01905         UserAssert(ptl-&gt;ptl-&gt;ptl == ptl);
01906         UserAssert(ptl-&gt;ptl-&gt;pobj == pobjOld);
01907         ptl-&gt;ptl-&gt;pobj = pobj;
01908         ptl-&gt;ptl-&gt;pfnCaller = ptl-&gt;pfnCaller;
01909     }
01910 
01911     <span class="keywordflow">return</span> pobjOld;
01912 }
01913 <span class="preprocessor">#endif</span>
01914 <span class="preprocessor"></span>
01915 
01916 <span class="comment">/*</span>
01917 <span class="comment"> * The thread locking routines should be optimized for time, not size,</span>
01918 <span class="comment"> * since they get called so often.</span>
01919 <span class="comment"> */</span>
01920 <span class="preprocessor">#pragma optimize("t", on)</span>
01921 <span class="preprocessor"></span>
01922 <span class="comment">/***************************************************************************\</span>
01923 <span class="comment">* ThreadUnlock1</span>
01924 <span class="comment">*</span>
01925 <span class="comment">* This api unlocks a thread locked object. Returns pobj if the object</span>
01926 <span class="comment">* was *not* destroyed (meaning the pointer is still valid).</span>
01927 <span class="comment">*</span>
01928 <span class="comment">* N.B. In a free build the first entry in the thread lock list is unlocked.</span>
01929 <span class="comment">*</span>
01930 <span class="comment">* 03-04-92 ScottLu      Created.</span>
01931 <span class="comment">\***************************************************************************/</span>
01932 
01933 <span class="preprocessor">#if DBG</span>
01934 <span class="preprocessor"></span>PVOID
01935 <a class="code" href="../../d4/d1/userk_8h.html#a984">ThreadUnlock1</a>(
01936     <a class="code" href="../../d5/d1/struct__TL.html">PTL</a> ptlIn)
01937 #<span class="keywordflow">else</span>
01938 PVOID
<a name="l01939"></a><a class="code" href="../../d4/d1/userk_8h.html#a984">01939</a> <a class="code" href="../../d4/d1/userk_8h.html#a984">ThreadUnlock1</a>(
01940     VOID)
01941 #endif
01942 {
01943     <a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a> phead;
01944     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent;
01945     <a class="code" href="../../d5/d1/struct__TL.html">PTL</a> ptl;
01946 
01947     ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>();
01948     ptl = ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o1">ptl</a>;
01949     UserAssert(ptl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01950      <span class="comment">/*</span>
01951 <span class="comment">      * Validate the thread lock list.</span>
01952 <span class="comment">      */</span>
01953      ValidateThreadLocks(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, ptl, (ULONG_PTR)&amp;ptlIn, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01954     <span class="comment">/*</span>
01955 <span class="comment">     * Make sure the caller wants to unlock the top lock.</span>
01956 <span class="comment">     */</span>
01957     UserAssert(ptlIn == ptl);
01958     ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o1">ptl</a> = ptl-&gt;next;
01959     <span class="comment">/*</span>
01960 <span class="comment">     * If the object address is not NULL, then unlock the object.</span>
01961 <span class="comment">     */</span>
01962     phead = (<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)(ptl-&gt;pobj);
01963     <span class="keywordflow">if</span> (phead != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01964 
01965         <span class="comment">/*</span>
01966 <span class="comment">         * Unlock the object.</span>
01967 <span class="comment">         */</span>
01968 
01969         phead = (<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a>)<a class="code" href="../../d4/d1/userk_8h.html#a110">HMUnlockObject</a>(phead);
01970     }
01971 <span class="preprocessor">#if DBG</span>
01972 <span class="preprocessor"></span>    {
01973         <span class="comment">/*</span>
01974 <span class="comment">         * Remove the corresponding element from gFreeTLList</span>
01975 <span class="comment">         */</span>
01976         ptl-&gt;ptl-&gt;next = gFreeTLList;
01977         ptl-&gt;ptl-&gt;uTLCount += TL_FREED_PATTERN;
01978         gFreeTLList = ptl-&gt;ptl;
01979     }
01980 <span class="preprocessor">#endif</span>
01981 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (PVOID)phead;
01982 }
01983 
01984 <span class="comment">/*</span>
01985 <span class="comment"> * Switch back to default optimization.</span>
01986 <span class="comment"> */</span>
01987 <span class="preprocessor">#pragma optimize("", on)</span>
01988 <span class="preprocessor"></span>
01989 <span class="comment">/***************************************************************************\</span>
01990 <span class="comment">* CheckLock</span>
01991 <span class="comment">*</span>
01992 <span class="comment">* This routine only exists in DBG builds - it checks to make sure objects</span>
01993 <span class="comment">* are thread locked.</span>
01994 <span class="comment">*</span>
01995 <span class="comment">* 03-09-92 ScottLu      Created.</span>
01996 <span class="comment">\***************************************************************************/</span>
01997 
01998 <span class="preprocessor">#if DBG</span>
01999 <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="../../d6/d0/usercli_8h.html#a35">CheckLock</a>(
02000     PVOID pobj)
02001 {
02002     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a10">PtiCurrentShared</a>();
02003     <a class="code" href="../../d5/d1/struct__TL.html">PTL</a> ptl;
02004 
02005     <span class="keywordflow">if</span> (pobj == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02006         <span class="keywordflow">return</span>;
02007     }
02008 
02009     <span class="comment">/*</span>
02010 <span class="comment">     * Validate all locks first</span>
02011 <span class="comment">     */</span>
02012     UserAssert(ptiCurrent != NULL);
02013     ValidateThreadLocks(NULL, ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o1">ptl</a>, (ULONG_PTR)&amp;pobj, TRUE);
02014 
02015     <span class="keywordflow">for</span> (ptl = ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o1">ptl</a>; ptl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; ptl=ptl-&gt;next) {
02016         <span class="keywordflow">if</span> (ptl-&gt;pobj == pobj)
02017             <span class="keywordflow">return</span>;
02018     }
02019 
02020     <span class="comment">/*</span>
02021 <span class="comment">     * WM_FINALDESTROY messages get sent without thread locking, so if</span>
02022 <span class="comment">     * marked for destruction, don't print the message.</span>
02023 <span class="comment">     */</span>
02024     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a446">HMPheFromObject</a>(pobj)-&gt;bFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a421">HANDLEF_DESTROY</a>)
02025         <span class="keywordflow">return</span>;
02026 
02027     RIPMSG1(RIP_ERROR, <span class="stringliteral">"Object not thread locked! %#p"</span>, pobj);
02028 }
02029 <span class="preprocessor">#endif</span>
02030 <span class="preprocessor"></span>
02031 
02032 <span class="comment">/***************************************************************************\</span>
02033 <span class="comment">* HMDestroyUnlockedObject</span>
02034 <span class="comment">*</span>
02035 <span class="comment">* Destroy an object based on an unlock or cleanup from thread or</span>
02036 <span class="comment">* process termination.</span>
02037 <span class="comment">*</span>
02038 <span class="comment">* The functions called to destroy a particular object can be called</span>
02039 <span class="comment">* directly from code as well as the result of an unlock. Destroy</span>
02040 <span class="comment">* functions have the following 4 sections.</span>
02041 <span class="comment">*</span>
02042 <span class="comment">*     (1) Remove the object from a list or other global</span>
02043 <span class="comment">*     context. If the destroy function has to leave the</span>
02044 <span class="comment">*     critical section (e.g. make an xxx call), it must</span>
02045 <span class="comment">*     do so in this step.</span>
02046 <span class="comment">*</span>
02047 <span class="comment">*     (2) Call HMMarkDestroy, and return if HMMarkDestroy</span>
02048 <span class="comment">*     returns FALSE. This is required.</span>
02049 <span class="comment">*</span>
02050 <span class="comment">*     (3) Destroy resources held by the objects - locks to</span>
02051 <span class="comment">*     other objects, alloc'd memory, etc. This is required.</span>
02052 <span class="comment">*</span>
02053 <span class="comment">*     (4) Free the memory of the object and its handle by calling</span>
02054 <span class="comment">*     HMFreeObject. This is required.</span>
02055 <span class="comment">*</span>
02056 <span class="comment">* Note that if the object is locked when it's destroy function</span>
02057 <span class="comment">* is called directly, step (1) will be repeated when the object is</span>
02058 <span class="comment">* unlocked. We should probably check for this in the destroy functions,</span>
02059 <span class="comment">* which we currently do not do.</span>
02060 <span class="comment">*</span>
02061 <span class="comment">* Note that we could be destroying this object in a context different</span>
02062 <span class="comment">* than the one that created it. This is very important to understand</span>
02063 <span class="comment">* since in lots of code the "current thread" is referenced and assumed</span>
02064 <span class="comment">* as the creator.</span>
02065 <span class="comment">*</span>
02066 <span class="comment">* 02-10-92 ScottLu      Created.</span>
02067 <span class="comment">\***************************************************************************/</span>
02068 
<a name="l02069"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a10">02069</a> <span class="keywordtype">void</span> <a class="code" href="../../d4/d1/userk_8h.html#a977">HMDestroyUnlockedObject</a>(
02070     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> phe)
02071 {
02072     <a class="code" href="../../d4/d1/userk_8h.html#a159">BEGINATOMICCHECK</a>();
02073 
02074     <span class="comment">/*</span>
02075 <span class="comment">     * Remember that we're destroying this object so we don't try to destroy</span>
02076 <span class="comment">     * it again when the lock count goes from != 0 to 0 (especially true</span>
02077 <span class="comment">     * for thread locks).</span>
02078 <span class="comment">     */</span>
02079     phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> |= <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a422">HANDLEF_INDESTROY</a>;
02080 
02081     <span class="comment">/*</span>
02082 <span class="comment">     * This'll call the destroy handler for this object type.</span>
02083 <span class="comment">     */</span>
02084     (*<a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html#o0">fnDestroy</a>)(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>);
02085 
02086     <span class="comment">/*</span>
02087 <span class="comment">     * HANDLEF_INDESTROY is supposed to be cleared either by HMMarkObjectDestroy</span>
02088 <span class="comment">     *  or by HMFreeObject; the destroy handler was supposed to call at least</span>
02089 <span class="comment">     *  the former.</span>
02090 <span class="comment">     */</span>
02091     UserAssert(!(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a422">HANDLEF_INDESTROY</a>));
02092 
02093     <span class="comment">/*</span>
02094 <span class="comment">     * If the object wasn't freed, it must be marked as destroyed</span>
02095 <span class="comment">     *  and must have a lock count</span>
02096 <span class="comment">     */</span>
02097     UserAssert((phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>)
02098                 || ((phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a421">HANDLEF_DESTROY</a>) &amp;&amp; (phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>-&gt;<a class="code" href="../../d4/d5/struct__HEAD.html#o1">cLockObj</a> &gt; 0)));
02099 
02100     <a class="code" href="../../d4/d1/userk_8h.html#a163">ENDATOMICCHECK</a>();
02101 }
02102 
02103 
02104 <span class="comment">/***************************************************************************\</span>
02105 <span class="comment">* HMChangeOwnerThread</span>
02106 <span class="comment">*</span>
02107 <span class="comment">* Changes the owning thread of an object.</span>
02108 <span class="comment">*</span>
02109 <span class="comment">* 09-13-93 JimA         Created.</span>
02110 <span class="comment">\***************************************************************************/</span>
02111 
<a name="l02112"></a><a class="code" href="../../d4/d1/userk_8h.html#a980">02112</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> <a class="code" href="../../d4/d1/userk_8h.html#a980">HMChangeOwnerThread</a>(
02113     PVOID pobj,
02114     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> pti)
02115 {
02116     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> phe = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a446">HMPheFromObject</a>(pobj);
02117     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiOld = ((<a class="code" href="../../d1/d1/struct__THROBJHEAD.html">PTHROBJHEAD</a>)(pobj))-&gt;pti;
02118     <a class="code" href="../../d6/d9/structtagWND.html">PWND</a> pwnd;
02119     <a class="code" href="../../d7/d0/structtagCLS.html">PPCLS</a> ppcls;
02120     <a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a>   ppi;
02121 
02122     UserAssert(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a437">HMObjectFlags</a>(pobj) &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a>);
02123     UserAssert(pti != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02124 
02125     ((<a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a>)phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>)-&gt;ppi-&gt;UserHandleCount--;
02126 
02127     ((<a class="code" href="../../d1/d1/struct__THROBJHEAD.html">PTHROBJHEAD</a>)pobj)-&gt;pti = phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> = pti;
02128 
02129     ((<a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a>)phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>)-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o2">ppi</a>-&gt;UserHandleCount++;
02130 
02131     <a class="code" href="../../d4/d8/handtabl_8c.html#a2">DBGValidateHandleQuota</a>();
02132 
02133     <span class="comment">/*</span>
02134 <span class="comment">     * If this is a window, update the window counts.</span>
02135 <span class="comment">     */</span>
02136     <span class="keywordflow">switch</span> (phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>) {
02137     <span class="keywordflow">case</span> <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a237">TYPE_WINDOW</a>:
02138         <span class="comment">/*</span>
02139 <span class="comment">         * Desktop thread used to hit this assert in HYDRA</span>
02140 <span class="comment">         * because pti == ptiOld</span>
02141 <span class="comment">         */</span>
02142         UserAssert(ptiOld-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o49">cWindows</a> &gt; 0 || ptiOld == pti);
02143         pti-&gt;cWindows++;
02144         ptiOld-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o49">cWindows</a>--;
02145 
02146         pwnd = (<a class="code" href="../../d6/d9/structtagWND.html">PWND</a>)pobj;
02147 
02148         <span class="comment">/*</span>
02149 <span class="comment">         * Make sure thread visible window count is properly updated.</span>
02150 <span class="comment">         */</span>
02151         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a731">TestWF</a>(pwnd, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a652">WFVISIBLE</a>) &amp;&amp; <a class="code" href="../../d4/d1/userk_8h.html#a1625">FVisCountable</a>(pwnd)) {
02152             pti-&gt;cVisWindows++;
02153             ptiOld-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o50">cVisWindows</a>--;
02154         }
02155 
02156         <span class="comment">/*</span>
02157 <span class="comment">         * If the owning process is changing, fix up</span>
02158 <span class="comment">         * the window class.</span>
02159 <span class="comment">         */</span>
02160         <span class="keywordflow">if</span> (pti-&gt;ppi != ptiOld-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o2">ppi</a>) {
02161 
02162             ppcls = <a class="code" href="../../d4/d1/userk_8h.html#a1152">GetClassPtr</a>(pwnd-&gt;<a class="code" href="../../d6/d9/structtagWND.html#o9">pcls</a>-&gt;<a class="code" href="../../d7/d0/structtagCLS.html#o1">atomClassName</a>, pti-&gt;ppi, <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a273">hModuleWin</a>);
02163 
02164             <span class="keywordflow">if</span> (ppcls == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02165                 <span class="keywordflow">if</span> (pwnd-&gt;<a class="code" href="../../d6/d9/structtagWND.html#o0">head</a>.rpdesk)
02166                     ppi = pwnd-&gt;<a class="code" href="../../d6/d9/structtagWND.html#o0">head</a>.rpdesk-&gt;rpwinstaParent-&gt;pTerm-&gt;ptiDesktop-&gt;ppi;
02167                 <span class="keywordflow">else</span>
02168                     ppi = <a class="code" href="../../d4/d1/userk_8h.html#a16">PpiCurrent</a>();
02169                 ppcls = <a class="code" href="../../d4/d1/userk_8h.html#a1152">GetClassPtr</a>(<a class="code" href="../../d1/d8/clglobal_8c.html#a4">gpsi</a>-&gt;<a class="code" href="../../d2/d6/structtagSERVERINFO.html#o12">atomSysClass</a>[<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a79">ICLS_ICONTITLE</a>], ppi, <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a273">hModuleWin</a>);
02170             }
02171             UserAssert(ppcls);
02172 
02173             <span class="comment">/*</span>
02174 <span class="comment">             * The window is either destroyed or the desktop of the class is</span>
02175 <span class="comment">             * the same as the window's desktop</span>
02176 <span class="comment">             */</span>
02177             UserAssert((*ppcls)-&gt;rpdeskParent == pwnd-&gt;<a class="code" href="../../d6/d9/structtagWND.html#o0">head</a>.rpdesk ||
02178                        <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a731">TestWF</a>(pwnd, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a583">WFDESTROYED</a>));
02179 
02180             <a class="code" href="../../d4/d1/userk_8h.html#a1154">DereferenceClass</a>(pwnd);
02181             pwnd-&gt;<a class="code" href="../../d6/d9/structtagWND.html#o9">pcls</a> = *ppcls;
02182             pwnd-&gt;<a class="code" href="../../d6/d9/structtagWND.html#o9">pcls</a>-&gt;<a class="code" href="../../d7/d0/structtagCLS.html#o5">cWndReferenceCount</a>++;
02183         }
02184         <span class="keywordflow">break</span>;
02185 
02186     <span class="keywordflow">case</span> <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a241">TYPE_HOOK</a>:
02187         <span class="comment">/*</span>
02188 <span class="comment">         * If this is a global hook, remember this hook's desktop so we'll be</span>
02189 <span class="comment">         * able to unlink it later (gptiRit might switch to a different desktop</span>
02190 <span class="comment">         * at any time).</span>
02191 <span class="comment">         */</span>
02192         UserAssert(!!(((<a class="code" href="../../d5/d6/structtagHOOK.html">PHOOK</a>)pobj)-&gt;flags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a502">HF_GLOBAL</a>) ^ (((<a class="code" href="../../d5/d6/structtagHOOK.html">PHOOK</a>)pobj)-&gt;ptiHooked != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>));
02193         <span class="keywordflow">if</span> (((<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1063">PHOOK</a>)pobj)-&gt;flags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a502">HF_GLOBAL</a>) {
02194             UserAssert(pti == <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a175">gptiRit</a>);
02195             <a class="code" href="../../d4/d1/userk_8h.html#a126">LockDesktop</a>(&amp;((<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1063">PHOOK</a>)pobj)-&gt;rpdesk, ptiOld-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o6">rpdesk</a>, LDL_HOOK_DESK, 0);
02196         } <span class="keywordflow">else</span> {
02197             <span class="comment">/*</span>
02198 <span class="comment">             * This must be a hook on another thread or it was supposed to be</span>
02199 <span class="comment">             *  gone by now.</span>
02200 <span class="comment">             */</span>
02201             UserAssert(((<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a1063">PHOOK</a>)pobj)-&gt;ptiHooked != ptiOld);
02202         }
02203         <span class="keywordflow">break</span>;
02204 
02205     <span class="keywordflow">default</span>:
02206         <span class="keywordflow">break</span>;
02207     }
02208 }
02209 
02210 <span class="comment">/***************************************************************************\</span>
02211 <span class="comment">* HMChangeOwnerProcess</span>
02212 <span class="comment">*</span>
02213 <span class="comment">* Changes the owning process of an object.</span>
02214 <span class="comment">*</span>
02215 <span class="comment">* 04-15-97 JerrySh      Created.</span>
02216 <span class="comment">* 09-23-97 GerardoB     Changed parameters (and name) so HMDestroyUnlockedObject</span>
02217 <span class="comment">*                        could use this function (instead of duplicating the code there)</span>
02218 <span class="comment">\***************************************************************************/</span>
02219 
<a name="l02220"></a><a class="code" href="../../d4/d1/userk_8h.html#a981">02220</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> <a class="code" href="../../d4/d1/userk_8h.html#a981">HMChangeOwnerPheProcess</a>(
02221     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> phe,
02222     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> pti)
02223 {
02224     <a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a> ppiOwner = (<a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a>)(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>);
02225     PVOID pobj = phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>;
02226 
02227     UserAssert(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a437">HMObjectFlags</a>(pobj) &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a>);
02228     UserAssert(pti != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02229     <span class="comment">/*</span>
02230 <span class="comment">     * Dec current owner handle count</span>
02231 <span class="comment">     */</span>
02232     ppiOwner-&gt;UserHandleCount--;
02233     <span class="comment">/*</span>
02234 <span class="comment">     * hTaskWow</span>
02235 <span class="comment">     */</span>
02236     <span class="keywordflow">if</span> ((pti-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o9">TIF_flags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a796">TIF_16BIT</a>) &amp;&amp; (pti-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o22">ptdb</a>)) {
02237         ((<a class="code" href="../../d8/d0/struct__PROCOBJHEAD.html">PPROCOBJHEAD</a>)pobj)-&gt;hTaskWow = pti-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o22">ptdb</a>-&gt;<a class="code" href="../../d0/d8/structtagTDB.html#o5">hTaskWow</a>;
02238     } <span class="keywordflow">else</span> {
02239         ((<a class="code" href="../../d8/d0/struct__PROCOBJHEAD.html">PPROCOBJHEAD</a>)pobj)-&gt;hTaskWow = 0;
02240     }
02241     <span class="comment">/*</span>
02242 <span class="comment">     * ppi</span>
02243 <span class="comment">     */</span>
02244     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html#o2">bObjectCreateFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a415">OCF_MARKPROCESS</a>) {
02245         ((<a class="code" href="../../d7/d0/struct__PROCMARKHEAD.html">PPROCMARKHEAD</a>)pobj)-&gt;ppi = pti-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o2">ppi</a>;
02246     }
02247     <span class="comment">/*</span>
02248 <span class="comment">     * Set new owner in handle entry</span>
02249 <span class="comment">     */</span>
02250     phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> = pti-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o2">ppi</a>;
02251     <span class="comment">/*</span>
02252 <span class="comment">     * Inc new owner handle count</span>
02253 <span class="comment">     */</span>
02254     ((<a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a>)(phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>))-&gt;UserHandleCount++;
02255     <span class="comment">/*</span>
02256 <span class="comment">     * If the handle is a cursor, adjust GDI cursor handle count</span>
02257 <span class="comment">     */</span>
02258     <span class="keywordflow">if</span> (phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a239">TYPE_CURSOR</a>) {
02259         GreDecQuotaCount((PW32PROCESS)ppiOwner);
02260         GreIncQuotaCount((PW32PROCESS)phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>);
02261 
02262         <span class="keywordflow">if</span> (((<a class="code" href="../../d6/d1/structtagCURSOR.html">PCURSOR</a>)pobj)-&gt;hbmColor) {
02263             GreDecQuotaCount((PW32PROCESS)ppiOwner);
02264             GreIncQuotaCount((PW32PROCESS)phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>);
02265         }
02266     }
02267 
02268     <a class="code" href="../../d4/d8/handtabl_8c.html#a2">DBGValidateHandleQuota</a>();
02269 }
02270 
02271 <span class="comment">/***************************************************************************\</span>
02272 <span class="comment">* DestroyThreadsObjects</span>
02273 <span class="comment">*</span>
02274 <span class="comment">* Goes through the handle table list and destroy all objects owned by this</span>
02275 <span class="comment">* thread, because the thread is going away (either nicely, it faulted, or</span>
02276 <span class="comment">* was terminated). It is ok to destroy the objects in any order, because</span>
02277 <span class="comment">* object locking will ensure that they get destroyed in the right order.</span>
02278 <span class="comment">*</span>
02279 <span class="comment">* This routine gets called in the context of the thread that is exiting.</span>
02280 <span class="comment">*</span>
02281 <span class="comment">* 02-08-92 ScottLu      Created.</span>
02282 <span class="comment">\***************************************************************************/</span>
02283 
<a name="l02284"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a27">02284</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> <a class="code" href="../../d4/d8/handtabl_8c.html#a27">DestroyThreadsObjects</a>()
02285 {
02286     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent;
02287     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">HANDLEENTRY</a> <span class="keyword">volatile</span> * (*pphe);
02288     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> pheT;
02289     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> i;
02290 
02291     ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>();
02292     <a class="code" href="../../d4/d8/handtabl_8c.html#a2">DBGValidateHandleQuota</a>();
02293 
02294     <span class="comment">/*</span>
02295 <span class="comment">     * Before any window destruction occurs, we need to destroy any dcs</span>
02296 <span class="comment">     * in use in the dc cache. When a dc is checked out, it is marked owned,</span>
02297 <span class="comment">     * which makes gdi's process cleanup code delete it when a process</span>
02298 <span class="comment">     * goes away. We need to similarly destroy the cache entry of any dcs</span>
02299 <span class="comment">     * in use by the exiting process.</span>
02300 <span class="comment">     */</span>
02301     <a class="code" href="../../d4/d1/userk_8h.html#a1553">DestroyCacheDCEntries</a>(ptiCurrent);
02302 
02303     <span class="comment">/*</span>
02304 <span class="comment">     * Remove any thread locks that may exist for this thread.</span>
02305 <span class="comment">     */</span>
02306     <span class="keywordflow">while</span> (ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o1">ptl</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02307 
02308         UserAssert((ULONG_PTR)ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o1">ptl</a> &gt; (ULONG_PTR)&amp;i);
02309         UserAssert((ULONG_PTR)ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o1">ptl</a> &lt; (ULONG_PTR)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;StackBase);
02310         <a class="code" href="../../d6/d0/usercli_8h.html#a40">ThreadUnlock</a>(ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o1">ptl</a>);
02311     }
02312 
02313     <span class="comment">/*</span>
02314 <span class="comment">     * CleanupPool stuff must happen before handle table clean up (as it always has been).</span>
02315 <span class="comment">     * This is because SMWPs can be HM objects and still be locked in ptlPool.</span>
02316 <span class="comment">     * If the handle is destroyed first (and it's not locked) we would end up with a</span>
02317 <span class="comment">     *  bogus pointer in ptlPool. If ptlPool is cleaned up first, the handle will be freed</span>
02318 <span class="comment">     *  or properly preserved if locked.</span>
02319 <span class="comment">     */</span>
02320     CleanupW32ThreadLocks((PW32THREAD)ptiCurrent);
02321 
02322     <span class="comment">/*</span>
02323 <span class="comment">     * Eventhough HMDestroyUnlockedObject might call xxxDestroyWindow, the</span>
02324 <span class="comment">     *  following loop is not supposed to leave the critical section. We must</span>
02325 <span class="comment">     *  have called PatchThreadWindows before coming here.</span>
02326 <span class="comment">     */</span>
02327     <a class="code" href="../../d4/d1/userk_8h.html#a159">BEGINATOMICCHECK</a>();
02328 
02329     <span class="comment">/*</span>
02330 <span class="comment">     * Loop through the table destroying all objects created by the current</span>
02331 <span class="comment">     * thread. All objects will get destroyed in their proper order simply</span>
02332 <span class="comment">     * because of the object locking.</span>
02333 <span class="comment">     */</span>
02334     pphe = &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>;
02335     <span class="keywordflow">for</span> (i = 0; i &lt;= <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a308">giheLast</a>; i++) {
02336         <span class="comment">/*</span>
02337 <span class="comment">         * This pointer is done this way because it can change when we leave</span>
02338 <span class="comment">         * the critical section below.  The above volatile ensures that we</span>
02339 <span class="comment">         * always use the most current value</span>
02340 <span class="comment">         */</span>
02341         pheT = (<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a>)((*pphe) + i);
02342 
02343         <span class="comment">/*</span>
02344 <span class="comment">         * Check against free before we look at pti... because pq is stored</span>
02345 <span class="comment">         * in the object itself, which won't be there if TYPE_FREE.</span>
02346 <span class="comment">         */</span>
02347         <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>)
02348             <span class="keywordflow">continue</span>;
02349 
02350         <span class="comment">/*</span>
02351 <span class="comment">         * If a menu refererences a window owned by this thread, unlock</span>
02352 <span class="comment">         * the window.  This is done to prevent calling xxxDestroyWindow</span>
02353 <span class="comment">         * during process cleanup.</span>
02354 <span class="comment">         */</span>
02355         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html#o2">bObjectCreateFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a>) {
02356             <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a238">TYPE_MENU</a>) {
02357                 <a class="code" href="../../d6/d9/structtagWND.html">PWND</a> pwnd = ((<a class="code" href="../../d1/d1/structtagMENU.html">PMENU</a>)pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>)-&gt;spwndNotify;
02358 
02359                 <span class="keywordflow">if</span> (pwnd != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a455">GETPTI</a>(pwnd) == ptiCurrent)
02360                     <a class="code" href="../../d6/d0/usercli_8h.html#a42">Unlock</a>(&amp;((<a class="code" href="../../d1/d1/structtagMENU.html">PMENU</a>)pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>)-&gt;spwndNotify);
02361             }
02362             <span class="keywordflow">continue</span>;
02363         }
02364 
02365         <span class="comment">/*</span>
02366 <span class="comment">         * Destroy those objects created by this queue.</span>
02367 <span class="comment">         */</span>
02368         <span class="keywordflow">if</span> ((<a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a>)pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> != ptiCurrent)
02369             <span class="keywordflow">continue</span>;
02370 
02371         UserAssert(<a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].bObjectCreateFlags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a>);
02372 
02373         <span class="comment">/*</span>
02374 <span class="comment">         * Make sure this object isn't already marked to be destroyed - we'll</span>
02375 <span class="comment">         * do no good if we try to destroy it now since it is locked.</span>
02376 <span class="comment">         */</span>
02377         <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a421">HANDLEF_DESTROY</a>) {
02378             <span class="keywordflow">continue</span>;
02379         }
02380 
02381         <span class="comment">/*</span>
02382 <span class="comment">         * Destroy this object.</span>
02383 <span class="comment">         */</span>
02384         <a class="code" href="../../d4/d1/userk_8h.html#a977">HMDestroyUnlockedObject</a>(pheT);
02385     }
02386 
02387     <a class="code" href="../../d4/d1/userk_8h.html#a163">ENDATOMICCHECK</a>();
02388     <a class="code" href="../../d4/d8/handtabl_8c.html#a2">DBGValidateHandleQuota</a>();
02389 }
02390 
02391 <span class="preprocessor">#if DBG</span>
02392 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> <a class="code" href="../../d4/d8/handtabl_8c.html#a13">ShowLocks</a>(
02393     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> phe)
02394 {
02395     <a class="code" href="../../d1/d3/struct__LOCKRECORD.html">PLR</a> plr = phe-&gt;plr;
02396     <a class="code" href="../../d9/d5/ndismain_8h.html#a263">INT</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>;
02397 
02398     RIPMSG2(RIP_WARNING | RIP_THERESMORE,
02399             <span class="stringliteral">"Lock records for %s %#p:"</span>,
02400             gahti[phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].szObjectType, phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>-&gt;<a class="code" href="../../d4/d5/struct__HEAD.html#o0">h</a>);
02401     <span class="comment">/*</span>
02402 <span class="comment">     * We have the handle entry: 'head' and 'he' are both filled in. Dump</span>
02403 <span class="comment">     * the lock records. Remember the first record is the last transaction!!</span>
02404 <span class="comment">     */</span>
02405     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a> = 0;
02406     <span class="keywordflow">while</span> (plr != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02407         <span class="keywordtype">char</span> achPrint[80];
02408 
02409         <span class="keywordflow">if</span> (plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o2">ppobj</a> == <a class="code" href="../../d4/d1/userk_8h.html#a265">LOCKRECORD_MARKDESTROY</a>) {
02410             strcpy(achPrint, <span class="stringliteral">"Destroyed with"</span>);
02411         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o1">cLockObj</a> &lt;= 0) {
02412             strcpy(achPrint, <span class="stringliteral">"        Unlock"</span>);
02413         } <span class="keywordflow">else</span> {
02414             <span class="comment">/*</span>
02415 <span class="comment">             * Find corresponding unlock;</span>
02416 <span class="comment">             */</span>
02417             {
02418                <a class="code" href="../../d1/d3/struct__LOCKRECORD.html">PLR</a> plrUnlock;
02419                <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> cT;
02420                <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> cUnlock;
02421 
02422                plrUnlock = phe-&gt;plr;
02423                cT =  0;
02424                cUnlock = (<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>)-1;
02425 
02426                <span class="keywordflow">while</span> (plrUnlock != plr) {
02427                    <span class="keywordflow">if</span> (plrUnlock-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o2">ppobj</a> == plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o2">ppobj</a>) {
02428                        <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)plrUnlock-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o1">cLockObj</a> &lt;= 0) {
02429                            <span class="comment">// a matching unlock found</span>
02430                            cUnlock = cT;
02431                        } <span class="keywordflow">else</span> {
02432                            <span class="comment">// the unlock #cUnlock matches this lock #cT, thus</span>
02433                            <span class="comment">// #cUnlock is not the unlock we were looking for.</span>
02434                            cUnlock = (<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>)-1;
02435                        }
02436                    }
02437                    plrUnlock = plrUnlock-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o0">plrNext</a>;
02438                    cT++;
02439                }
02440                <span class="keywordflow">if</span> (cUnlock == (<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>)-1) {
02441                    <span class="comment">/*</span>
02442 <span class="comment">                    * Corresponding unlock not found!</span>
02443 <span class="comment">                    * This may not mean something is wrong: the structure</span>
02444 <span class="comment">                    * containing the pointer to the object may have moved</span>
02445 <span class="comment">                    * during a reallocation.  This can cause ppobj at Unlock</span>
02446 <span class="comment">                    * time to differ from that recorded at Lock time.</span>
02447 <span class="comment">                    * (Warning: moving structures like this may cause a Lock</span>
02448 <span class="comment">                    * and an Unlock to be misidentified as a pair, if by a</span>
02449 <span class="comment">                    * stroke of incredibly bad luck, the new location of a</span>
02450 <span class="comment">                    * pointer to an object is now where an old pointer to the</span>
02451 <span class="comment">                    * same object used to be)</span>
02452 <span class="comment">                    */</span>
02453                    <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(achPrint, <span class="stringliteral">"Unmatched Lock"</span>);
02454                } <span class="keywordflow">else</span> {
02455                    <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(achPrint, <span class="stringliteral">"lock   #%ld"</span>, cUnlock);
02456                }
02457             }
02458         }
02459 
02460         RIPMSG4(RIP_WARNING | RIP_NONAME | RIP_THERESMORE,
02461                 <span class="stringliteral">"        %s cLock=%d, pobj at %#p, code at %#p"</span>,
02462                 achPrint,
02463                 <a class="code" href="../../d4/d1/userk_8h.html#a259">abs</a>((<span class="keywordtype">int</span>)plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o1">cLockObj</a>),
02464                 plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o2">ppobj</a>,
02465                 plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o3">trace</a>[0]);
02466 
02467         plr = plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o0">plrNext</a>;
02468         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>++;
02469     }
02470 
02471     RIPMSG1(RIP_WARNING | RIP_NONAME, <span class="stringliteral">"        0x%lx records"</span>, c);
02472 }
02473 <span class="preprocessor">#endif</span>
02474 <span class="preprocessor"></span>
<a name="l02475"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a28">02475</a> <span class="keywordtype">void</span> <a class="code" href="../../d4/d8/handtabl_8c.html#a28">FixupCursor</a>(
02476     <a class="code" href="../../d6/d1/structtagCURSOR.html">PCURSOR</a>      pcur,
02477     <a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a> ppi)
02478 {
02479     <span class="keywordtype">int</span>   i;
02480     <a class="code" href="../../d1/d8/structtagACON.html">PACON</a> <a class="code" href="../../d4/d4/kernel_2acons_8c.html#a1">pacon</a> = (<a class="code" href="../../d1/d8/structtagACON.html">PACON</a>)pcur;
02481 
02482     <span class="keywordflow">if</span> (pcur-&gt;head.ppi == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02483         pcur-&gt;head.ppi = ppi;
02484     }
02485 
02486     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d4/kernel_2acons_8c.html#a1">pacon</a>-&gt;CURSORF_flags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a537">CURSORF_ACON</a>) {
02487         <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d4/d4/kernel_2acons_8c.html#a1">pacon</a>-&gt;cpcur; i++) {
02488 
02489             UserAssert(<a class="code" href="../../d4/d4/kernel_2acons_8c.html#a1">pacon</a>-&gt;aspcur[i]-&gt;CURSORF_flags &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a539">CURSORF_ACONFRAME</a>);
02490 
02491             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d4/kernel_2acons_8c.html#a1">pacon</a>-&gt;aspcur[i]-&gt;head.ppi == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02492                 <a class="code" href="../../d4/d4/kernel_2acons_8c.html#a1">pacon</a>-&gt;aspcur[i]-&gt;head.ppi = ppi;
02493             }
02494         }
02495     }
02496 }
02497 
02498 <span class="comment">/***************************************************************************\</span>
02499 <span class="comment">* DestroyProcessesObjects</span>
02500 <span class="comment">*</span>
02501 <span class="comment">* Goes through the handle table list and destroy all objects owned by this</span>
02502 <span class="comment">* process, because the process is going away (either nicely, it faulted, or</span>
02503 <span class="comment">* was terminated). It is ok to destroy the objects in any order, because</span>
02504 <span class="comment">* object locking will ensure that they get destroyed in the right order.</span>
02505 <span class="comment">*</span>
02506 <span class="comment">* This routine gets called in the context of the last thread in the process.</span>
02507 <span class="comment">*</span>
02508 <span class="comment">* 08-17-92 JimA         Created.</span>
02509 <span class="comment">\***************************************************************************/</span>
02510 
<a name="l02511"></a><a class="code" href="../../d6/d3/queue_8c.html#a16">02511</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> <a class="code" href="../../d6/d3/queue_8c.html#a16">DestroyProcessesObjects</a>(
02512     <a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a> ppi)
02513 {
02514     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a>  pheT, pheMax;
02515     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> bGlobal = (<a class="code" href="../../d1/d0/inc_2user_8h.html#a882">ISTS</a>() &amp;&amp; ppi-&gt;Process == <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a299">gpepCSRSS</a>);
02516 
02517     <span class="comment">/*</span>
02518 <span class="comment">     * Loop through the table destroying all objects created by the current</span>
02519 <span class="comment">     * process. All objects will get destroyed in their proper order simply</span>
02520 <span class="comment">     * because of the object locking.</span>
02521 <span class="comment">     */</span>
02522     <a class="code" href="../../d4/d8/handtabl_8c.html#a2">DBGValidateHandleQuota</a>();
02523     pheMax = &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a308">giheLast</a>];
02524 
02525     <span class="keywordflow">for</span> (pheT = <a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>; pheT &lt;= pheMax; pheT++) {
02526 
02527         <span class="comment">/*</span>
02528 <span class="comment">         * Check against free before we look at ppi... because pq is stored</span>
02529 <span class="comment">         * in the object itself, which won't be there if TYPE_FREE.</span>
02530 <span class="comment">         */</span>
02531         <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>)
02532             <span class="keywordflow">continue</span>;
02533 
02534         <span class="comment">/*</span>
02535 <span class="comment">         * Destroy those objects created by this queue.</span>
02536 <span class="comment">         */</span>
02537         <span class="keywordflow">if</span> (!(<a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html#o2">bObjectCreateFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a>) ||
02538                 (<a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a>)pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> != ppi)
02539             <span class="keywordflow">continue</span>;
02540 
02541         <span class="comment">/*</span>
02542 <span class="comment">         * Make sure this object isn't already marked to be destroyed - we'll</span>
02543 <span class="comment">         * do no good if we try to destroy it now since it is locked.</span>
02544 <span class="comment">         * Change the owner since the process is going away</span>
02545 <span class="comment">         */</span>
02546         <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a421">HANDLEF_DESTROY</a>) {
02547             <a class="code" href="../../d4/d1/userk_8h.html#a981">HMChangeOwnerPheProcess</a>(pheT, <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a175">gptiRit</a>);
02548             <span class="keywordflow">continue</span>;
02549         }
02550 
02551         <span class="keywordflow">if</span> (bGlobal) {
02552 
02553             <span class="comment">/*</span>
02554 <span class="comment">             * For global cursors set the ppi in the pcur</span>
02555 <span class="comment">             * to be CSRSS</span>
02556 <span class="comment">             */</span>
02557             <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a239">TYPE_CURSOR</a>) {
02558                 <a class="code" href="../../d4/d8/handtabl_8c.html#a28">FixupCursor</a>((<a class="code" href="../../d6/d1/structtagCURSOR.html">PCURSOR</a>)pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>, ppi);
02559             }
02560         }
02561 
02562         <span class="comment">/*</span>
02563 <span class="comment">         * Destroy this object.</span>
02564 <span class="comment">         */</span>
02565         <a class="code" href="../../d4/d1/userk_8h.html#a977">HMDestroyUnlockedObject</a>(pheT);
02566 
02567         <span class="comment">/*</span>
02568 <span class="comment">         * When the object is freed, the handle type is set to TYPE_FREE.</span>
02569 <span class="comment">         * Zombie this object, since its process is going away and it couldn't</span>
02570 <span class="comment">         * be freed. This may include unlinking it and resetting the owner.</span>
02571 <span class="comment">         */</span>
02572         <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> != <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>) {
02573             <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a239">TYPE_CURSOR</a>) {
02574                 RIPMSG1(RIP_WARNING, <span class="stringliteral">"About to zombie pcur %#p\n"</span>,
02575                         pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>);
02576 
02577                 <a class="code" href="../../d4/d1/userk_8h.html#a1108">ZombieCursor</a>((<a class="code" href="../../d6/d1/structtagCURSOR.html">PCURSOR</a>)pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>);
02578             } <span class="keywordflow">else</span> {
02579                 <a class="code" href="../../d4/d1/userk_8h.html#a981">HMChangeOwnerPheProcess</a>(pheT, <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a175">gptiRit</a>);
02580             }
02581         }
02582     } <span class="comment">/* for loop */</span>
02583     <a class="code" href="../../d4/d8/handtabl_8c.html#a2">DBGValidateHandleQuota</a>();
02584 }
02585 
02586 <span class="comment">/***************************************************************************\</span>
02587 <span class="comment">* MarkThreadsObjects</span>
02588 <span class="comment">*</span>
02589 <span class="comment">* This is called for the *final* exiting condition when a thread</span>
02590 <span class="comment">* may have objects still around... in which case their owner must</span>
02591 <span class="comment">* be changed to something "safe" that won't be going away.</span>
02592 <span class="comment">*</span>
02593 <span class="comment">* 03-02-92 ScottLu      Created.</span>
02594 <span class="comment">\***************************************************************************/</span>
<a name="l02595"></a><a class="code" href="../../d4/d1/userk_8h.html#a1547">02595</a> <span class="keywordtype">void</span> <a class="code" href="../../d4/d1/userk_8h.html#a1547">MarkThreadsObjects</a>(
02596     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> pti)
02597 {
02598     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> pheT, pheMax;
02599 
02600     pheMax = &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a308">giheLast</a>];
02601     <span class="keywordflow">for</span> (pheT = <a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>; pheT &lt;= pheMax; pheT++) {
02602         <span class="comment">/*</span>
02603 <span class="comment">         * Check against free before we look at pti... because pti is stored</span>
02604 <span class="comment">         * in the object itself, which won't be there if TYPE_FREE.</span>
02605 <span class="comment">         */</span>
02606         <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> == <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a236">TYPE_FREE</a>)
02607             <span class="keywordflow">continue</span>;
02608 
02609         <span class="comment">/*</span>
02610 <span class="comment">         * Change ownership!</span>
02611 <span class="comment">         */</span>
02612         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html#o2">bObjectCreateFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a> ||
02613                 (<a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a>)pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a> != pti)
02614             <span class="keywordflow">continue</span>;
02615 
02616 <span class="preprocessor">#if DBG</span>
02617 <span class="preprocessor"></span>        <span class="comment">/*</span>
02618 <span class="comment">         * This is just to make sure that RIT or DT never get here</span>
02619 <span class="comment">         */</span>
02620         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/inc_2user_8h.html#a882">ISTS</a>() &amp;&amp; (pti == <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a175">gptiRit</a> || pti == <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a239">gTermIO</a>.<a class="code" href="../../d1/d8/structtagTERMINAL.html#o2">ptiDesktop</a>)) {
02621             RIPMSG2(RIP_ERROR, <span class="stringliteral">"pti %#p is RIT or DT. phe %#p\n"</span>, pti, pheT);
02622         }
02623 <span class="preprocessor">#endif</span>
02624 <span class="preprocessor"></span>
02625         <a class="code" href="../../d4/d1/userk_8h.html#a980">HMChangeOwnerThread</a>(pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>, <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a175">gptiRit</a>);
02626 
02627 <span class="preprocessor">#if DEBUGTAGS</span>
02628 <span class="preprocessor"></span>
02629         <span class="keywordflow">if</span> (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
02630             <span class="comment">/*</span>
02631 <span class="comment">             * Object still around: print warning message.</span>
02632 <span class="comment">             */</span>
02633             <span class="keywordflow">if</span> (pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o3">bFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a421">HANDLEF_DESTROY</a>) {
02634                     TAGMSG2(DBGTAG_TrackLocks,
02635                           <span class="stringliteral">"Zombie %s %#p still locked"</span>,
02636                            <a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].szObjectType, pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>-&gt;<a class="code" href="../../d4/d5/struct__HEAD.html#o0">h</a>);
02637             } <span class="keywordflow">else</span> {
02638                 TAGMSG1(DBGTAG_TrackLocks,
02639                         <span class="stringliteral">"Thread object %#p not destroyed.\n"</span>,
02640                         pheT-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a>-&gt;<a class="code" href="../../d4/d5/struct__HEAD.html#o0">h</a>);
02641             }
02642 
02643             <a class="code" href="../../d4/d8/handtabl_8c.html#a13">ShowLocks</a>(pheT);
02644         }
02645 
02646 <span class="preprocessor">#endif // DEBUGTAGS</span>
02647 <span class="preprocessor"></span>    }
02648 }
02649 
02650 <span class="comment">/***************************************************************************\</span>
02651 <span class="comment">* HMRelocateLockRecord</span>
02652 <span class="comment">*</span>
02653 <span class="comment">* If a pointer to a locked object has been relocated, then this routine will</span>
02654 <span class="comment">* adjust the lock record accordingly.  Must be called after the relocation.</span>
02655 <span class="comment">*</span>
02656 <span class="comment">* The arguments are:</span>
02657 <span class="comment">*   ppobjNew - the address of the new pointer</span>
02658 <span class="comment">*              MUST already contain the pointer to the object!!</span>
02659 <span class="comment">*   cbDelta  - the amount by which this pointer was moved.</span>
02660 <span class="comment">*</span>
02661 <span class="comment">* Using this routine appropriately will prevent spurious "unmatched lock"</span>
02662 <span class="comment">* reports.  See mnchange.c for an example.</span>
02663 <span class="comment">*</span>
02664 <span class="comment">*</span>
02665 <span class="comment">* 03-18-93 IanJa        Created.</span>
02666 <span class="comment">\***************************************************************************/</span>
02667 
02668 <span class="preprocessor">#if DBG</span>
02669 <span class="preprocessor"></span>
02670 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> HMRelocateLockRecord(
02671     PVOID ppobjNew,
02672     LONG_PTR cbDelta)
02673 {
02674     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> phe;
02675     PVOID ppobjOld = (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)ppobjNew - cbDelta;
02676     <a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a> pobj;
02677     <a class="code" href="../../d1/d3/struct__LOCKRECORD.html">PLR</a> plr;
02678 
02679     <span class="keywordflow">if</span> (ppobjNew == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02680         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02681     }
02682 
02683     pobj = *(<a class="code" href="../../d4/d5/struct__HEAD.html">PHEAD</a> *)ppobjNew;
02684 
02685     <span class="keywordflow">if</span> (pobj == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02686         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02687     }
02688 
02689     phe = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a446">HMPheFromObject</a>(pobj);
02690     <span class="keywordflow">if</span> (phe-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o0">phead</a> != pobj) {
02691         RIPMSG3(RIP_WARNING,
02692                 <span class="stringliteral">"HmRelocateLockRecord(%#p, %lx) - %#p is bad pobj\n"</span>,
02693                 ppobjNew, cbDelta, pobj);
02694 
02695         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02696     }
02697 
02698     plr = phe-&gt;plr;
02699 
02700     <span class="keywordflow">while</span> (plr != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02701         <span class="keywordflow">if</span> (plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o2">ppobj</a> == ppobjOld) {
02702             (<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)(plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o2">ppobj</a>) += cbDelta;
02703             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02704         }
02705         plr = plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o0">plrNext</a>;
02706     }
02707 
02708     RIPMSG2(RIP_WARNING,
02709             <span class="stringliteral">"HmRelocateLockRecord(%#p, %lx) - couldn't find lock record\n"</span>,
02710             ppobjNew, cbDelta);
02711 
02712     <a class="code" href="../../d4/d8/handtabl_8c.html#a13">ShowLocks</a>(phe);
02713     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02714 }
02715 
02716 
02717 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d4/d8/handtabl_8c.html#a12">HMUnrecordLock</a>(
02718     PVOID ppobj,
02719     PVOID pobj)
02720 {
02721     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a> phe;
02722     <a class="code" href="../../d1/d3/struct__LOCKRECORD.html">PLR</a> plr;
02723     <a class="code" href="../../d1/d3/struct__LOCKRECORD.html">PLR</a> *pplr;
02724 
02725     phe = <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a446">HMPheFromObject</a>(pobj);
02726 
02727     pplr = &amp;(phe-&gt;plr);
02728     plr = *pplr;
02729 
02730     <span class="comment">/*</span>
02731 <span class="comment">     * Find corresponding lock;</span>
02732 <span class="comment">     */</span>
02733     <span class="keywordflow">while</span> (plr != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02734         <span class="keywordflow">if</span> (plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o2">ppobj</a> == ppobj) {
02735             <span class="comment">/*</span>
02736 <span class="comment">             * Remove the lock from the list...</span>
02737 <span class="comment">             */</span>
02738             *pplr = plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o0">plrNext</a>;   <span class="comment">// unlink it</span>
02739             plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o0">plrNext</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;    <span class="comment">// make the dead entry safe (?)</span>
02740 
02741             <span class="comment">/*</span>
02742 <span class="comment">             * ...and free it.</span>
02743 <span class="comment">             */</span>
02744             FreeLockRecord(plr);
02745             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02746         }
02747         pplr = &amp;(plr-&gt;<a class="code" href="../../d1/d3/struct__LOCKRECORD.html#o0">plrNext</a>);
02748         plr = *pplr;
02749     }
02750 
02751     RIPMSG2(RIP_WARNING, <span class="stringliteral">"Could not find lock for ppobj %#p pobj %#p"</span>,
02752             ppobj, pobj);
02753 
02754     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02755 }
02756 
02757 <span class="preprocessor">#endif // DBG</span>
02758 <span class="preprocessor"></span>
02759 <span class="comment">/***************************************************************************\</span>
02760 <span class="comment">* _QueryUserHandles</span>
02761 <span class="comment">*</span>
02762 <span class="comment">* This function retrieves the USER handle counters for all processes</span>
02763 <span class="comment">* specified by their client ID in the paPids array</span>
02764 <span class="comment">* Specify QUC_PID_TOTAL to retrieve totals for all processes in the system</span>
02765 <span class="comment">*</span>
02766 <span class="comment">* Parameters:</span>
02767 <span class="comment">*    paPids   - pointer to an array of pids (DWORDS) that we're interested in</span>
02768 <span class="comment">*    dwNumInstances - number of DWORDS in paPids</span>
02769 <span class="comment">*    pdwResult - will receive TYPES_CTYPESxdwNumInstances counters</span>
02770 <span class="comment">*</span>
02771 <span class="comment">* returns: none</span>
02772 <span class="comment">*</span>
02773 <span class="comment">* 07-25-97 mcostea        Created</span>
02774 <span class="comment">\***************************************************************************/</span>
02775 
<a name="l02776"></a><a class="code" href="../../d4/d8/handtabl_8c.html#a31">02776</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> <a class="code" href="../../d4/d1/userk_8h.html#a2084">_QueryUserHandles</a>(
02777     LPDWORD  paPids,
02778     DWORD    dwNumInstances,
02779     DWORD    dwResult[][TYPE_CTYPES])
02780 {
02781     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a>         pheCurPos;                 <span class="comment">// Current position in the table</span>
02782     <a class="code" href="../../d2/d4/struct__HANDLEENTRY.html">PHE</a>         pheMax;                    <span class="comment">// address of last table entry</span>
02783     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>       index;
02784     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>       pid;
02785     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>       dwTotalCounters[<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a254">TYPE_CTYPES</a>]; <span class="comment">// system wide counters</span>
02786 
02787     RtlZeroMemory(dwTotalCounters, <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a254">TYPE_CTYPES</a>*<span class="keyword">sizeof</span>(<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>));
02788     RtlZeroMemory(dwResult, dwNumInstances*<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a254">TYPE_CTYPES</a>*<span class="keyword">sizeof</span>(<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>));
02789     <span class="comment">/*</span>
02790 <span class="comment">     * Walk the handle table and update the counters</span>
02791 <span class="comment">     */</span>
02792     pheMax = &amp;<a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>[<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a308">giheLast</a>];
02793     <span class="keywordflow">for</span>(pheCurPos = <a class="code" href="../../d1/d8/clglobal_8c.html#a5">gSharedInfo</a>.<a class="code" href="../../d4/d6/structtagSHAREDINFO.html#o1">aheList</a>; pheCurPos &lt;= pheMax; pheCurPos++) {
02794 
02795         UserAssert(pheCurPos-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a> &lt; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a254">TYPE_CTYPES</a>);
02796 
02797         pid = 0;
02798 
02799         <span class="keywordflow">if</span> (pheCurPos-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>) {
02800 
02801             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[pheCurPos-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html#o2">bObjectCreateFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a414">OCF_PROCESSOWNED</a>) {
02802                 <span class="comment">/*</span>
02803 <span class="comment">                 * Object is owned by process</span>
02804 <span class="comment">                 * some objects may not have an owner</span>
02805 <span class="comment">                 */</span>
02806                     pid = HandleToUlong(((<a class="code" href="../../d7/d3/structtagPROCESSINFO.html">PPROCESSINFO</a>)pheCurPos-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>)-&gt;Process-&gt;UniqueProcessId);
02807                 }
02808             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d9/d6/ntuser_2kernel_2globals_8h.html#a241">gahti</a>[pheCurPos-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>].<a class="code" href="../../d1/d6/structtagHANDLETYPEINFO.html#o2">bObjectCreateFlags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a413">OCF_THREADOWNED</a>) {
02809                 <span class="comment">/*</span>
02810 <span class="comment">                 * Object owned by thread</span>
02811 <span class="comment">                 */</span>
02812                     pid = HandleToUlong(((<a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a>)pheCurPos-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o1">pOwner</a>)-&gt;pEThread-&gt;ThreadsProcess-&gt;UniqueProcessId);
02813                 }
02814         }
02815         <span class="comment">/*</span>
02816 <span class="comment">         * search to see if we are interested in this process</span>
02817 <span class="comment">         * unowned handles are reported for the "System" process whose pid is 0</span>
02818 <span class="comment">         */</span>
02819         <span class="keywordflow">for</span> (index = 0; index &lt; dwNumInstances; index++) {
02820 
02821             <span class="keywordflow">if</span> (paPids[index] == pid) {
02822                 dwResult[index][pheCurPos-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>]++;
02823             }
02824         }
02825         <span class="comment">/*</span>
02826 <span class="comment">         *  update the totals</span>
02827 <span class="comment">         */</span>
02828          dwTotalCounters[pheCurPos-&gt;<a class="code" href="../../d2/d4/struct__HANDLEENTRY.html#o2">bType</a>]++;
02829     }
02830 
02831     <span class="comment">/*</span>
02832 <span class="comment">     * search to see if we are interested in the totals</span>
02833 <span class="comment">     */</span>
02834     <span class="keywordflow">for</span> (index = 0; index &lt; dwNumInstances; index++) {
02835 
02836         <span class="keywordflow">if</span> (paPids[index] == <a class="code" href="../../d0/d5/perfuser_8c.html#a1">QUC_PID_TOTAL</a>) {
02837 
02838             RtlMoveMemory(dwResult[index], dwTotalCounters, <span class="keyword">sizeof</span>(dwTotalCounters));
02839         }
02840     }
02841 
02842 }
02843 
02844 <span class="comment">/***************************************************************************\</span>
02845 <span class="comment">* HMCleanupGrantedHandle</span>
02846 <span class="comment">*</span>
02847 <span class="comment">* This function is called to cleanup this handle from pW32Job-&gt;pgh arrays.</span>
02848 <span class="comment">* It walks the job list to find jobs that have the handle granted.</span>
02849 <span class="comment">*</span>
02850 <span class="comment">* HISTORY:</span>
02851 <span class="comment">* 22 Jul 97      CLupu            Created</span>
02852 <span class="comment">\***************************************************************************/</span>
<a name="l02853"></a><a class="code" href="../../d4/d1/userk_8h.html#a978">02853</a> <span class="keywordtype">void</span> <a class="code" href="../../d4/d1/userk_8h.html#a978">HMCleanupGrantedHandle</a>(
02854     HANDLE h)
02855 {
02856     <a class="code" href="../../d1/d9/structtagW32JOB.html">PW32JOB</a> pW32Job;
02857 
02858     pW32Job = <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a113">gpJobsList</a>;
02859 
02860     <span class="keywordflow">while</span> (pW32Job != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02861         PULONG_PTR pgh;
02862         <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>  dw;
02863 
02864         pgh = pW32Job-&gt;<a class="code" href="../../d1/d9/structtagW32JOB.html#o9">pgh</a>;
02865 
02866         <span class="comment">/*</span>
02867 <span class="comment">         * search for the handle in the array.</span>
02868 <span class="comment">         */</span>
02869         <span class="keywordflow">for</span> (dw = 0; dw &lt; pW32Job-&gt;<a class="code" href="../../d1/d9/structtagW32JOB.html#o7">ughCrt</a>; dw++) {
02870             <span class="keywordflow">if</span> (*(pgh + dw) == (ULONG_PTR)h) {
02871 
02872                 <span class="comment">/*</span>
02873 <span class="comment">                 * found the handle granted to this process</span>
02874 <span class="comment">                 */</span>
02875                 RtlMoveMemory(pgh + dw,
02876                               pgh + dw + 1,
02877                               (pW32Job-&gt;<a class="code" href="../../d1/d9/structtagW32JOB.html#o7">ughCrt</a> - dw - 1) * <span class="keyword">sizeof</span>(*pgh));
02878 
02879                 (pW32Job-&gt;<a class="code" href="../../d1/d9/structtagW32JOB.html#o7">ughCrt</a>)--;
02880 
02881                 <span class="comment">/*</span>
02882 <span class="comment">                 * we should shrink the array also</span>
02883 <span class="comment">                 */</span>
02884 
02885                 <span class="keywordflow">break</span>;
02886             }
02887         }
02888 
02889         pW32Job = pW32Job-&gt;<a class="code" href="../../d1/d9/structtagW32JOB.html#o0">pNext</a>;
02890     }
02891 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:14 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
