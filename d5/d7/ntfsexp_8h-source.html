<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: ntfsexp.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>ntfsexp.h</h1><a href="../../d4/d8/ntfsexp_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1995  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    NtfsExp.h</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module defines the exports from NtOfs.SYS for use exclusively by</span>
00012 <span class="comment">    Transactions and Encryption.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    *********************************</span>
00015 <span class="comment">    *No other clients are supported.*</span>
00016 <span class="comment">    *********************************</span>
00017 <span class="comment"></span>
00018 <span class="comment">Author:</span>
00019 <span class="comment"></span>
00020 <span class="comment">    Mark Zbikowski  [MarkZ]         7-Dec-1995</span>
00021 <span class="comment">    Jeff Havens     [JHavens]</span>
00022 <span class="comment">    Brian Andrew    [BrianAn]</span>
00023 <span class="comment">    Gary Kimura     [GaryKi]</span>
00024 <span class="comment">    Tom Miller      [TomM]</span>
00025 <span class="comment"></span>
00026 <span class="comment">Revision History:</span>
00027 <span class="comment"></span>
00028 <span class="comment"></span>
00029 <span class="comment">--*/</span>
00030 
00031 <span class="preprocessor">#ifndef _NTFS_</span>
00032 <span class="preprocessor"></span>
00033 <span class="comment">//</span>
00034 <span class="comment">//  The MFT Segment Reference is an address in the MFT tagged with</span>
00035 <span class="comment">//  a circularly reused sequence number set at the time that the MFT</span>
00036 <span class="comment">//  Segment Reference was valid.  Note that this format limits the</span>
00037 <span class="comment">//  size of the Master File Table to 2**48 segments.  So, for</span>
00038 <span class="comment">//  example, with a 1KB segment size the maximum size of the master</span>
00039 <span class="comment">//  file would be 2**58 bytes, or 2**28 gigabytes.</span>
00040 <span class="comment">//</span>
00041 
<a name="l00042"></a><a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">00042</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">_FILE_REFERENCE</a> {
00043 
00044     <span class="comment">//</span>
00045     <span class="comment">//  First a 48 bit segment number.</span>
00046     <span class="comment">//</span>
00047 
<a name="l00048"></a><a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html#o0">00048</a>     ULONG <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html#o0">SegmentNumberLowPart</a>;                                    <span class="comment">//  offset = 0x000</span>
<a name="l00049"></a><a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html#o1">00049</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html#o1">SegmentNumberHighPart</a>;                                  <span class="comment">//  offset = 0x004</span>
00050 
00051     <span class="comment">//</span>
00052     <span class="comment">//  Now a 16 bit nonzero sequence number.  A value of 0 is</span>
00053     <span class="comment">//  reserved to allow the possibility of a routine accepting</span>
00054     <span class="comment">//  0 as a sign that the sequence number check should be</span>
00055     <span class="comment">//  repressed.</span>
00056     <span class="comment">//</span>
00057 
<a name="l00058"></a><a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html#o2">00058</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html#o2">SequenceNumber</a>;                                          <span class="comment">//  offset = 0x006</span>
00059 
00060 } <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">FILE_REFERENCE</a>, *<a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">PFILE_REFERENCE</a>;                   <span class="comment">//  sizeof = 0x008</span>
00061 
00062 <span class="preprocessor">#endif</span>
00063 <span class="preprocessor"></span>
00064 <span class="comment">//</span>
00065 <span class="comment">//  Big picture view of the interaction between extensions and NtOfs:</span>
00066 <span class="comment">//</span>
00067 <span class="comment">//      NtOfs exports a number of interfaces that give abstract access to</span>
00068 <span class="comment">//      on-disk structures and attempt to hide, as much as possible, the</span>
00069 <span class="comment">//      implementation details.</span>
00070 <span class="comment">//</span>
00071 <span class="comment">//      V/Q/X are implemented as DLL's that link to NtOfs.Sys.  NtOfs can load</span>
00072 <span class="comment">//      and function in absence of these DLL's.</span>
00073 <span class="comment">//</span>
00074 <span class="comment">//      All communication between user-mode code and V/Q/X occurs via the</span>
00075 <span class="comment">//      Nt Io API which is routed through NtOfs.  Client code will open either</span>
00076 <span class="comment">//      an NtOfs Volume, Directory, or File and will issue NtIo calls to the</span>
00077 <span class="comment">//      resultant handle.</span>
00078 <span class="comment">//</span>
00079 <span class="comment">//      NtOfs will create an IrpContext, decode the file object appropriately,</span>
00080 <span class="comment">//      and call out to entry points in V/Q/X that are registered at load-time.</span>
00081 <span class="comment">//</span>
00082 <span class="comment">//      V/Q/X will perform whatever actions are necessary utilizing NtOfs exports</span>
00083 <span class="comment">//      and then return from the original call from NtOfs an NTSTATUS code.  NtOfs</span>
00084 <span class="comment">//      will perform the appropriate CompleteIrp calls, posting for STATUS_PENDING,</span>
00085 <span class="comment">//      etc.</span>
00086 <span class="comment">//</span>
00087 <span class="comment">//      No exceptions can be raised across the NtOfs export or NtOfs import</span>
00088 <span class="comment">//      interfaces.  All user-buffer access and validation will occur in the</span>
00089 <span class="comment">//      code that uses it.  Since user buffers may disappear at any time, any</span>
00090 <span class="comment">//      client of these buffers must wrap access to the buffers in an exception</span>
00091 <span class="comment">//      clause.</span>
00092 <span class="comment">//</span>
00093 <span class="comment">//      V/Q/X may perform activities in threads separate from the original</span>
00094 <span class="comment">//      requestor.  For these cases, NtOfs will provide a means where calls separate</span>
00095 <span class="comment">//      from a user-mode request can be accepted.  Typically, this means "cloning"</span>
00096 <span class="comment">//      an IrpContext.</span>
00097 <span class="comment">//</span>
00098 
00099 <span class="comment">//</span>
00100 <span class="comment">//  Opaque handle definitions.</span>
00101 <span class="comment">//</span>
00102 
00103 <span class="comment">//</span>
00104 <span class="comment">//  ISSUE:  Most NtOfs internal routines rely on having an IrpContext passed in</span>
00105 <span class="comment">//  along with FCB and SCB pointers.  Rather than exposing FCB and IrpContext</span>
00106 <span class="comment">//  as separate contexts, should we wrap these up into a separate structure and</span>
00107 <span class="comment">//  pass it along?</span>
00108 <span class="comment">//</span>
00109 
<a name="l00110"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a30">00110</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d9/struct__FCB.html">_FCB</a> *<a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a>;
<a name="l00111"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a31">00111</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>_SCB *<a class="code" href="../../d4/d8/ntfsexp_8h.html#a31">ATTRIBUTE_HANDLE</a>;
<a name="l00112"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a32">00112</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>_SCB *<a class="code" href="../../d4/d8/ntfsexp_8h.html#a32">INDEX_HANDLE</a>;
<a name="l00113"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a33">00113</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>_READ_CONTEXT *<a class="code" href="../../d4/d8/ntfsexp_8h.html#a33">PREAD_CONTEXT</a>;
<a name="l00114"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a34">00114</a> <span class="keyword">typedef</span> ULONG <a class="code" href="../../d4/d8/ntfsexp_8h.html#a34">SECURITY_ID</a>;
<a name="l00115"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a35">00115</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>_CI_CALL_BACK CI_CALL_BACK, *<a class="code" href="../../d4/d8/ntfsexp_8h.html#a35">PCI_CALL_BACK</a>;
<a name="l00116"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a36">00116</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>_VIEW_CALL_BACK VIEW_CALL_BACK, *<a class="code" href="../../d4/d8/ntfsexp_8h.html#a36">PVIEW_CALL_BACK</a>;
<a name="l00117"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a37">00117</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">_IRP_CONTEXT</a> *<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>;
00118 
00119 <span class="comment">//</span>
00120 <span class="comment">//  Map Handle.  This structure defines a byte range of the file which is mapped</span>
00121 <span class="comment">//  or pinned, and stores the Bcb returned from the Cache Manager.</span>
00122 <span class="comment">//</span>
00123 
<a name="l00124"></a><a class="code" href="../../d3/d6/struct__MAP__HANDLE.html">00124</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d3/d6/struct__MAP__HANDLE.html">_MAP_HANDLE</a> {
00125 
00126     <span class="comment">//</span>
00127     <span class="comment">//  Range being mapped or pinned</span>
00128     <span class="comment">//</span>
00129 
<a name="l00130"></a><a class="code" href="../../d3/d6/struct__MAP__HANDLE.html#o0">00130</a>     LONGLONG <a class="code" href="../../d3/d6/struct__MAP__HANDLE.html#o0">FileOffset</a>;
<a name="l00131"></a><a class="code" href="../../d3/d6/struct__MAP__HANDLE.html#o1">00131</a>     ULONG <a class="code" href="../../d3/d6/struct__MAP__HANDLE.html#o1">Length</a>;
00132 
00133     <span class="comment">//</span>
00134     <span class="comment">//  Virtual address corresponding to FileOffset</span>
00135     <span class="comment">//</span>
00136 
<a name="l00137"></a><a class="code" href="../../d3/d6/struct__MAP__HANDLE.html#o2">00137</a>     PVOID <a class="code" href="../../d3/d6/struct__MAP__HANDLE.html#o2">Buffer</a>;
00138 
00139     <span class="comment">//</span>
00140     <span class="comment">//  Bcb pointer returned from Cache Manager</span>
00141     <span class="comment">//</span>
00142 
<a name="l00143"></a><a class="code" href="../../d3/d6/struct__MAP__HANDLE.html#o3">00143</a>     PVOID <a class="code" href="../../d3/d6/struct__MAP__HANDLE.html#o3">Bcb</a>;
00144 
00145 } <a class="code" href="../../d3/d6/struct__MAP__HANDLE.html">MAP_HANDLE</a>, *<a class="code" href="../../d3/d6/struct__MAP__HANDLE.html">PMAP_HANDLE</a>;
00146 
00147 <span class="comment">//</span>
00148 <span class="comment">//  Quick Index Hint.  This is stream offset information returned by</span>
00149 <span class="comment">//  NtOfsFindRecord, and taken as input to NtOfsUpdateRecord, to allow</span>
00150 <span class="comment">//  quick updates to index records in the event that they have not</span>
00151 <span class="comment">//  moved.  This structure must always have the same size and alignment</span>
00152 <span class="comment">//  as QUICK_INDEX in ntfsstru.h.</span>
00153 <span class="comment">//</span>
00154 
<a name="l00155"></a><a class="code" href="../../d4/d2/struct__QUICK__INDEX__HINT.html">00155</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/d2/struct__QUICK__INDEX__HINT.html">_QUICK_INDEX_HINT</a> {
<a name="l00156"></a><a class="code" href="../../d4/d2/struct__QUICK__INDEX__HINT.html#o0">00156</a>     LONGLONG <a class="code" href="../../d4/d2/struct__QUICK__INDEX__HINT.html#o0">HintData</a>[3];
00157 } <a class="code" href="../../d4/d2/struct__QUICK__INDEX__HINT.html">QUICK_INDEX_HINT</a>, *<a class="code" href="../../d4/d2/struct__QUICK__INDEX__HINT.html">PQUICK_INDEX_HINT</a>;
00158 
00159 <span class="comment">//</span>
00160 <span class="comment">//  Index structures</span>
00161 <span class="comment">//</span>
00162 
<a name="l00163"></a><a class="code" href="../../d4/d7/structINDEX__KEY.html">00163</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00164"></a><a class="code" href="../../d4/d7/structINDEX__KEY.html#o0">00164</a>     ULONG KeyLength;
<a name="l00165"></a><a class="code" href="../../d4/d7/structINDEX__KEY.html#o1">00165</a>     PVOID <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
00166 } <a class="code" href="../../d4/d7/structINDEX__KEY.html">INDEX_KEY</a>, *<a class="code" href="../../d4/d8/ntfsexp_8h.html#a42">PINDEX_KEY</a>;
00167 
<a name="l00168"></a><a class="code" href="../../d3/d7/structINDEX__DATA.html">00168</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00169"></a><a class="code" href="../../d3/d7/structINDEX__DATA.html#o0">00169</a>     ULONG DataLength;
<a name="l00170"></a><a class="code" href="../../d3/d7/structINDEX__DATA.html#o1">00170</a>     PVOID Data;
00171 } <a class="code" href="../../d3/d7/structINDEX__DATA.html">INDEX_DATA</a>, *<a class="code" href="../../d4/d8/ntfsexp_8h.html#a43">PINDEX_DATA</a>;
00172 
<a name="l00173"></a><a class="code" href="../../d5/d7/structINDEX__ROW.html">00173</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00174"></a><a class="code" href="../../d5/d7/structINDEX__ROW.html#o0">00174</a>     <a class="code" href="../../d4/d7/structINDEX__KEY.html">INDEX_KEY</a> KeyPart;
<a name="l00175"></a><a class="code" href="../../d5/d7/structINDEX__ROW.html#o1">00175</a>     <a class="code" href="../../d3/d7/structINDEX__DATA.html">INDEX_DATA</a> DataPart;
00176 } <a class="code" href="../../d5/d7/structINDEX__ROW.html">INDEX_ROW</a>, *<a class="code" href="../../d4/d8/ntfsexp_8h.html#a44">PINDEX_ROW</a>;
00177 
00178 <span class="comment">//</span>
00179 <span class="comment">//  COLLATION_FUNCTION returns LessThan if Key1 precedes Key2</span>
00180 <span class="comment">//                             EqualTo if Key1 is identical to Key2</span>
00181 <span class="comment">//                             GreaterThan if Key1 follows Key2</span>
00182 <span class="comment">//</span>
00183 
<a name="l00184"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a45">00184</a> <span class="keyword">typedef</span> <a class="code" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a> (*<a class="code" href="../../d4/d8/ntfsexp_8h.html#a45">PCOLLATION_FUNCTION</a>) (
00185             IN <a class="code" href="../../d4/d8/ntfsexp_8h.html#a42">PINDEX_KEY</a> Key1,
00186             IN <a class="code" href="../../d4/d8/ntfsexp_8h.html#a42">PINDEX_KEY</a> Key2,
00187             IN PVOID CollationData
00188             );
00189 
<a name="l00190"></a><a class="code" href="../../d2/d4/struct__UPCASE__TABLE__AND__KEY.html">00190</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d4/struct__UPCASE__TABLE__AND__KEY.html">_UPCASE_TABLE_AND_KEY</a> {
00191 
00192     <span class="comment">//</span>
00193     <span class="comment">//  Pointer to a table of upcased unicode characters indexed by character to</span>
00194     <span class="comment">//  be upcased.</span>
00195     <span class="comment">//</span>
00196 
<a name="l00197"></a><a class="code" href="../../d2/d4/struct__UPCASE__TABLE__AND__KEY.html#o0">00197</a>     PWCH <a class="code" href="../../d2/d4/struct__UPCASE__TABLE__AND__KEY.html#o0">UpcaseTable</a>;
00198 
00199     <span class="comment">//</span>
00200     <span class="comment">//  Size of UpcaseTable in unicode characters</span>
00201     <span class="comment">//</span>
00202 
<a name="l00203"></a><a class="code" href="../../d2/d4/struct__UPCASE__TABLE__AND__KEY.html#o1">00203</a>     ULONG <a class="code" href="../../d2/d4/struct__UPCASE__TABLE__AND__KEY.html#o1">UpcaseTableSize</a>;
00204 
00205     <span class="comment">//</span>
00206     <span class="comment">//  Optional addtional pointer.</span>
00207     <span class="comment">//</span>
00208 
<a name="l00209"></a><a class="code" href="../../d2/d4/struct__UPCASE__TABLE__AND__KEY.html#o2">00209</a>     <a class="code" href="../../d4/d7/structINDEX__KEY.html">INDEX_KEY</a> <a class="code" href="../../d2/d4/struct__UPCASE__TABLE__AND__KEY.html#o2">Key</a>;
00210 
00211 } <a class="code" href="../../d2/d4/struct__UPCASE__TABLE__AND__KEY.html">UPCASE_TABLE_AND_KEY</a>, *<a class="code" href="../../d2/d4/struct__UPCASE__TABLE__AND__KEY.html">PUPCASE_TABLE_AND_KEY</a>;
00212 
00213 <span class="comment">//</span>
00214 <span class="comment">//  Wait for new length block used to synchronize a thread with FileSize</span>
00215 <span class="comment">//  exceeding the specified Length.</span>
00216 <span class="comment">//</span>
00217 
<a name="l00218"></a><a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html">00218</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html">_WAIT_FOR_NEW_LENGTH</a> {
00219 
00220     <span class="comment">//</span>
00221     <span class="comment">//  Link words for multiple waiters on the Scb.</span>
00222     <span class="comment">//</span>
00223 
<a name="l00224"></a><a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o0">00224</a>     LIST_ENTRY <a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o0">WaitList</a>;
00225 
00226     <span class="comment">//</span>
00227     <span class="comment">//  Set event when FileSize exceeds this length.</span>
00228     <span class="comment">//</span>
00229 
<a name="l00230"></a><a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o1">00230</a>     LONGLONG <a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o1">Length</a>;
00231 
00232     <span class="comment">//</span>
00233     <span class="comment">//  Event to set when new length achieved.</span>
00234     <span class="comment">//</span>
00235 
<a name="l00236"></a><a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o2">00236</a>     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o2">Event</a>;
00237 
00238     <span class="comment">//</span>
00239     <span class="comment">//  Irp to complete when new length achieved. (If Irp present, Event is</span>
00240     <span class="comment">//  ignored.)</span>
00241     <span class="comment">//</span>
00242 
<a name="l00243"></a><a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o3">00243</a>     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
00244 
00245     <span class="comment">//</span>
00246     <span class="comment">//  Stream we are waiting on.</span>
00247     <span class="comment">//</span>
00248 
<a name="l00249"></a><a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o4">00249</a>     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a31">ATTRIBUTE_HANDLE</a> <a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o4">Stream</a>;
00250 
00251     <span class="comment">//</span>
00252     <span class="comment">//  Status code for operation that caused the new length to be satisfied.</span>
00253     <span class="comment">//  It may be STATUS_CANCELLED, STATUS_TIMEOUT or STATUS_SUCCESS</span>
00254     <span class="comment">//  or a request specific status.</span>
00255     <span class="comment">//</span>
00256 
<a name="l00257"></a><a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o5">00257</a>     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o5">Status</a>;
00258 
00259     <span class="comment">//</span>
00260     <span class="comment">//  Flags.</span>
00261     <span class="comment">//</span>
00262 
<a name="l00263"></a><a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o6">00263</a>     ULONG <a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html#o6">Flags</a>;
00264 
00265 } <a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html">WAIT_FOR_NEW_LENGTH</a>, *<a class="code" href="../../d9/d7/struct__WAIT__FOR__NEW__LENGTH.html">PWAIT_FOR_NEW_LENGTH</a>;
00266 
<a name="l00267"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a0">00267</a> <span class="preprocessor">#define NTFS_WAIT_FLAG_ASYNC                    (0x00000001)</span>
00268 <span class="preprocessor"></span>
00269 <span class="comment">//</span>
00270 <span class="comment">//  Standard collation functions for simple indices</span>
00271 <span class="comment">//</span>
00272 
00273 <a class="code" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a>
00274 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a73">NtOfsCollateUlong</a> (             <span class="comment">//  Both must be single Ulong</span>
00275     IN PINDEX_KEY Key1,
00276     IN PINDEX_KEY Key2,
00277     IN PVOID CollationData      <span class="comment">//  Don't care, may be NULL</span>
00278     );
00279 
00280 <a class="code" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a>
00281 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a74">NtOfsCollateUlongs</a> (            <span class="comment">//  Lengths do not have to be equal</span>
00282     IN PINDEX_KEY Key1,
00283     IN PINDEX_KEY Key2,
00284     IN PVOID CollationData      <span class="comment">//  Don't care, may be NULL</span>
00285     );
00286 
00287 <a class="code" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a>
00288 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a75">NtOfsCollateSid</a> (
00289     IN PINDEX_KEY Key1,
00290     IN PINDEX_KEY Key2,
00291     IN PVOID CollationData      <span class="comment">//  Don't care, may be NULL</span>
00292     );
00293 
00294 <a class="code" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a>
00295 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a76">NtOfsCollateUnicode</a> (
00296     IN PINDEX_KEY Key1,
00297     IN PINDEX_KEY Key2,
00298     IN PVOID CollationData      <span class="comment">//  PUPCASE_TABLE_AND_KEY (with no key)</span>
00299     );
00300 
00301 <span class="comment">//</span>
00302 <span class="comment">//  Standard match functions for simple indices</span>
00303 <span class="comment">//</span>
00304 
00305 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00306 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a77">NtOfsMatchAll</a> (
00307     IN PINDEX_ROW IndexRow,
00308     IN OUT PVOID MatchData      <span class="comment">//  Don't care, may be NULL</span>
00309     );
00310 
00311 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00312 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a78">NtOfsMatchUlongExact</a> (
00313     IN PINDEX_ROW IndexRow,     <span class="comment">//  Both must be single Ulong</span>
00314     IN OUT PVOID MatchData      <span class="comment">//  PINDEX_KEY describing Ulong</span>
00315     );
00316 
00317 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00318 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a79">NtOfsMatchUlongsExact</a> (         <span class="comment">//  Lengths do not have to be equal</span>
00319     IN PINDEX_ROW IndexRow,
00320     IN OUT PVOID MatchData      <span class="comment">//  PINDEX_KEY describing Ulongs</span>
00321     );
00322 
00323 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00324 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a80">NtOfsMatchUnicodeExpression</a> (
00325     IN PINDEX_ROW IndexRow,
00326     IN OUT PVOID MatchData      <span class="comment">//  PUPCASE_TABLE_AND_KEY with Uni expression (must have wildcards)</span>
00327     );
00328 
00329 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00330 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a81">NtOfsMatchUnicodeString</a> (
00331     IN PINDEX_ROW IndexRow,
00332     IN OUT PVOID MatchData      <span class="comment">//  PUPCASE_TABLE_AND_KEY with Uni string (no wildcards)</span>
00333     );
00334 
00335 <span class="comment">//</span>
00336 <span class="comment">//  MATCH_FUNCTION returns</span>
00337 <span class="comment">//      STATUS_SUCCESS if the IndexRow matches</span>
00338 <span class="comment">//      STATUS_NO_MATCH if the IndexRow does not match, but the enumeration should</span>
00339 <span class="comment">//          continue</span>
00340 <span class="comment">//      STATUS_NO_MORE_MATCHES if the IndexRow does not match, and the enumeration</span>
00341 <span class="comment">//          should terminate</span>
00342 <span class="comment">//</span>
00343 
<a name="l00344"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a50">00344</a> <span class="keyword">typedef</span> <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> (*<a class="code" href="../../d4/d8/ntfsexp_8h.html#a50">PMATCH_FUNCTION</a>) (IN <a class="code" href="../../d4/d8/ntfsexp_8h.html#a44">PINDEX_ROW</a> IndexRow, IN OUT PVOID MatchData);
00345 
00346 <span class="comment">//</span>
00347 <span class="comment">//  CREATE_OPTIONS - common flags governing creation/opening of objects</span>
00348 <span class="comment">//</span>
00349 
<a name="l00350"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a141">00350</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d4/d8/ntfsexp_8h.html#a141">_CREATE_OPTIONS</a>
00351 {
00352     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a141a67">CREATE_NEW</a> = 0,
00353     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a141a68">CREATE_OR_OPEN</a> = 1,
00354     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a141a69">OPEN_EXISTING</a> = 2
00355 } <a class="code" href="../../d4/d8/ntfsexp_8h.html#a51">CREATE_OPTIONS</a>;
00356 
00357 
00358 <span class="comment">//</span>
00359 <span class="comment">//  EXCLUSION - Form of exclusion desired when opening an object</span>
00360 <span class="comment">//</span>
00361 
<a name="l00362"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a142">00362</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d4/d8/ntfsexp_8h.html#a142">_EXCLUSION</a>
00363 {
00364     <a class="code" href="../../d3/d5/range_8h.html#a6">SHARED</a> = 0,
00365     <a class="code" href="../../d5/d2/oplock_8c.html#a8">EXCLUSIVE</a>
00366 } <a class="code" href="../../d4/d8/ntfsexp_8h.html#a52">EXCLUSION</a>;
00367 
00368 
00369 
00370 <span class="comment">//</span>
00371 <span class="comment">//  Additional Dos Attribute indicating Content Index status of an object.</span>
00372 <span class="comment">//  If this is set on a document, it suppresses indexing.  It is inherited</span>
00373 <span class="comment">//  from a parent directory at create time.  This is stored in the</span>
00374 <span class="comment">//  DUPLICATED_INFORMATION structure.</span>
00375 <span class="comment">//</span>
00376 
<a name="l00377"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a1">00377</a> <span class="preprocessor">#define SUPPRESS_CONTENT_INDEX      (0x20000000)</span>
00378 <span class="preprocessor"></span>
00379 <span class="comment">//</span>
00380 <span class="comment">//  Define the size of the index buffer/bucket for view indexes, in bytes.</span>
00381 <span class="comment">//</span>
00382 
<a name="l00383"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a2">00383</a> <span class="preprocessor">#define NTOFS_VIEW_INDEX_BUFFER_SIZE    (0x1000)</span>
00384 <span class="preprocessor"></span>
00385 <span class="comment">//</span>
00386 <span class="comment">//  Exported constants.</span>
00387 <span class="comment">//</span>
00388 
00389 <span class="comment">//</span>
00390 <span class="comment">//  NtOfsContentIndexSystemFile is the repository for all CI related data on the</span>
00391 <span class="comment">//  disk.</span>
00392 
<a name="l00393"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a53">00393</a> <span class="keyword">extern</span> <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">FILE_REFERENCE</a> <a class="code" href="../../d4/d8/ntfsexp_8h.html#a53">NtOfsContentIndexSystemFile</a>;
00394 
00395 <span class="preprocessor">#if defined(_NTFSPROC_)</span>
00396 <span class="preprocessor"></span>
00397 <span class="preprocessor">#define NTFSAPI</span>
00398 <span class="preprocessor"></span>
00399 <span class="preprocessor">#else</span>
00400 <span class="preprocessor"></span>
<a name="l00401"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">00401</a> <span class="preprocessor">#define NTFSAPI DECLSPEC_IMPORT</span>
00402 <span class="preprocessor"></span>
00403 <span class="preprocessor">#endif</span>
00404 <span class="preprocessor"></span>
00405 
00406 
00407 <span class="comment">//</span>
00408 <span class="comment">//  Index API - These encapsulate the NtOfs BTree mechanisms.</span>
00409 <span class="comment">//</span>
00410 
00411 <span class="comment">//</span>
00412 <span class="comment">//  NtOfsCreateIndex creates or opens a named index attribute in an object.  The</span>
00413 <span class="comment">//  ObjectHandle has been acquired exclusive and the returned handle is not</span>
00414 <span class="comment">//  acquired.  The collation data is interpreted only by the CollationFunction.</span>
00415 <span class="comment">//</span>
00416 <span class="comment">//  IndexHandles retain a "seek" position where enumerations (NtOfsReadRecords)</span>
00417 <span class="comment">//  may continue.  This seek position may be updated by the routines as described</span>
00418 <span class="comment">//  below.</span>
00419 <span class="comment">//</span>
00420 <span class="comment">//  If DeleteCollationData is 1, ExFreePool will be called on CollationData, either</span>
00421 <span class="comment">//  immediately if the index already exists, or when the index is deleted some time</span>
00422 <span class="comment">//  after the final close.  If NtOfsCreateIndex returns an error, then CollationData</span>
00423 <span class="comment">//  must be deleted by the caller.  If specified as 0, then ColloationData will not</span>
00424 <span class="comment">//  be deleted.</span>
00425 <span class="comment">//</span>
00426 
00427 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00428 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00429 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a82">NtOfsCreateIndex</a> (
00430     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00431     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ObjectHandle,
00432     IN UNICODE_STRING Name,
00433     IN CREATE_OPTIONS CreateOptions,
00434     IN ULONG DeleteCollationData,
00435     IN ULONG CollationRule,
00436     IN PCOLLATION_FUNCTION CollationFunction,
00437     IN PVOID CollationData OPTIONAL,
00438     OUT INDEX_HANDLE *IndexHandle
00439     );
00440 
00441 
00442 <span class="comment">//</span>
00443 <span class="comment">//  NtOfsFindRecord finds a single record in an index stream for read-only access</span>
00444 <span class="comment">//  or in preparation for calling NtOfsUpdateRecord.</span>
00445 <span class="comment">//</span>
00446 
00447 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00448 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00449 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a83">NtOfsFindRecord</a> (
00450     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00451     IN INDEX_HANDLE IndexHandle,
00452     IN PINDEX_KEY IndexKey,
00453     OUT PINDEX_ROW IndexRow,
00454     OUT PMAP_HANDLE MapHandle,
00455     IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL
00456     );
00457 
00458 <span class="comment">//</span>
00459 <span class="comment">//  NtOfsFindRecord finds a single record in an index stream for read-only access</span>
00460 <span class="comment">//  or in preparation for calling NtOfsUpdateRecord.</span>
00461 <span class="comment">//</span>
00462 
00463 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00464 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00465 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a84">NtOfsFindLastRecord</a> (
00466     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00467     IN INDEX_HANDLE IndexHandle,
00468     IN PINDEX_KEY MaxIndexKey,
00469     OUT PINDEX_ROW IndexRow,
00470     OUT PMAP_HANDLE MapHandle
00471     );
00472 
00473 <span class="comment">//</span>
00474 <span class="comment">//  NtOfsAddRecords performs bulk, logged inserts into an index.  The index will</span>
00475 <span class="comment">//  be acquired exclusive for this call.  Each record added must have a unique</span>
00476 <span class="comment">//  (with regards to the collation function) key.  No maps are currently</span>
00477 <span class="comment">//  outstanding on this index.  If SequentialInsertMode is nonzero, this is a hint</span>
00478 <span class="comment">//  to the index package to keep all BTree buffers as full as possible, by splitting</span>
00479 <span class="comment">//  as close to the end of the buffer as possible.  If specified as zero, random</span>
00480 <span class="comment">//  inserts are assumed, and buffers are always split in the middle for better balance.</span>
00481 <span class="comment">//</span>
00482 <span class="comment">//  This call may update the IndexHandle seek position</span>
00483 <span class="comment">//</span>
00484 
00485 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00486 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00487 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a85">NtOfsAddRecords</a> (
00488     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00489     IN INDEX_HANDLE IndexHandle,
00490     IN ULONG Count,
00491     IN PINDEX_ROW IndexRow,
00492     IN ULONG SequentialInsertMode
00493     );
00494 
00495 <span class="comment">//</span>
00496 <span class="comment">//  NtOfsDeleteRecords performs bulk, logged deletion from an index.  The index</span>
00497 <span class="comment">//  will be acquired exclusive for this call.  No maps are currently outstanding</span>
00498 <span class="comment">//  on this index.</span>
00499 <span class="comment">//</span>
00500 <span class="comment">//  This call may update the IndexHandle seek position</span>
00501 <span class="comment">//</span>
00502 
00503 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00504 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00505 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a86">NtOfsDeleteRecords</a> (
00506     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00507     IN INDEX_HANDLE IndexHandle,
00508     IN ULONG Count,
00509     IN PINDEX_KEY IndexKey
00510     );
00511 
00512 <span class="comment">//</span>
00513 <span class="comment">//  NtOfsReadRecords applies a match function to a block of contiguous records in</span>
00514 <span class="comment">//  the BTree starting either at a given IndexKey or beginning where it last left</span>
00515 <span class="comment">//  off.</span>
00516 <span class="comment">//</span>
00517 <span class="comment">//  IndexKey is an optional point at which to begin the enumeration.  The</span>
00518 <span class="comment">//  seek position of IndexHandle is set to return the next logical record</span>
00519 <span class="comment">//  on the next NtOfsReadRecords call.</span>
00520 <span class="comment">//</span>
00521 <span class="comment">//  NtOfsReadRecords will seek to the appropriate point in the BTree (as defined</span>
00522 <span class="comment">//  by the IndexKey or saved position and the CollateFunction) and begin calling</span>
00523 <span class="comment">//  MatchFunction for each record.  It continues doing this while MatchFunction</span>
00524 <span class="comment">//  returns STATUS_SUCCESS.  If MatchFunction returns STATUS_NO_MORE_MATCHES,</span>
00525 <span class="comment">//  NtOfsReadRecords will cache this result and not call MatchFunction again until</span>
00526 <span class="comment">//  called with a non-NULL IndexKey.</span>
00527 <span class="comment">//</span>
00528 <span class="comment">//  NtOfsReadRecords returns the last status code returned by MatchFunction.</span>
00529 <span class="comment">//</span>
00530 <span class="comment">//  The IndexHandle does not have to be acquired as it is acquired shared for the</span>
00531 <span class="comment">//  duration of the call.  NtOfsReadRecords may</span>
00532 <span class="comment">//  return with STATUS_SUCCESS without filling the output buffer (say, every 10</span>
00533 <span class="comment">//  index pages) to reduce lock contention.</span>
00534 <span class="comment">//</span>
00535 <span class="comment">//  NtOfsReadRecords will read up to Count rows, comprising up to BufferLength</span>
00536 <span class="comment">//  bytes in total and will fill in the Rows[] array for each row returned.</span>
00537 <span class="comment">//</span>
00538 <span class="comment">//  Note that this call is self-synchronized, such that successive calls to</span>
00539 <span class="comment">//  the routine are guaranteed to make progress through the index and to return</span>
00540 <span class="comment">//  items in Collation order, in spite of Add and Delete record calls being</span>
00541 <span class="comment">//  interspersed with Read records calls.</span>
00542 <span class="comment">//</span>
00543 
00544 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00545 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00546 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a87">NtOfsReadRecords</a> (
00547         IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00548         IN INDEX_HANDLE IndexHandle,
00549         IN OUT PREAD_CONTEXT *ReadContext,
00550         IN OPTIONAL PINDEX_KEY IndexKey,
00551         IN PMATCH_FUNCTION MatchFunction,
00552         IN PVOID MatchData,
00553         IN OUT ULONG *Count,
00554         OUT PINDEX_ROW Rows,
00555         IN ULONG BufferLength,
00556         OUT PVOID Buffer
00557         );
00558 
00559 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00560 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00561 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a88">NtOfsFreeReadContext</a> (
00562         IN PREAD_CONTEXT ReadContext
00563         );
00564 
00565 <span class="comment">//</span>
00566 <span class="comment">//  NtOfsUpdateRecord updates a single record in place.  It is guaranteed that the</span>
00567 <span class="comment">//  length of the data/key portion of the record does not change.  The index will</span>
00568 <span class="comment">//  be acquired exclusive for this call.</span>
00569 <span class="comment">//</span>
00570 <span class="comment">//  This call may update the IndexHandle seek position</span>
00571 <span class="comment">//</span>
00572 
00573 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00574 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00575 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a89">NtOfsUpdateRecord</a> (
00576     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00577     IN INDEX_HANDLE IndexHandle,
00578     IN ULONG Count,
00579     IN PINDEX_ROW IndexRow,
00580     IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL,
00581     IN OUT PMAP_HANDLE MapHandle OPTIONAL
00582     );
00583 
00584 <span class="comment">//</span>
00585 <span class="comment">//  NtOfsCloseIndex closes an index handle.  The index must not be acquired for this</span>
00586 <span class="comment">//  call.  No outstanding maps are allowed.</span>
00587 <span class="comment">//</span>
00588 
00589 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00590 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00591 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a90">NtOfsCloseIndex</a> (
00592     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00593     IN INDEX_HANDLE IndexHandle
00594     );
00595 
00596 <span class="comment">//</span>
00597 <span class="comment">//  NtOfsDeleteIndex removes an index attribute from an object.  The object will be</span>
00598 <span class="comment">//  acquired exclusive for this call.</span>
00599 <span class="comment">//</span>
00600 
00601 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00602 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00603 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a91">NtOfsDeleteIndex</a> (
00604     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00605     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ObjectHandle,
00606     IN INDEX_HANDLE IndexHandle
00607     );
00608 
00609 
00610 
00611 <span class="comment">//</span>
00612 <span class="comment">//  Map API - These encapsulate the NtOfs/Cache manager interactions</span>
00613 <span class="comment">//</span>
00614 
00615 <span class="comment">//</span>
00616 <span class="comment">//  NtOfsInitializeMapHandle initializes a map handle so it can be safely</span>
00617 <span class="comment">//  released at any time.</span>
00618 <span class="comment">//</span>
00619 <span class="comment">//  NTFSAPI</span>
00620 <span class="comment">//  VOID</span>
00621 <span class="comment">//  NtOfsInitializeMapHandle (</span>
00622 <span class="comment">//      IN PMAP_HANDLE Map</span>
00623 <span class="comment">//      );</span>
00624 <span class="comment">//</span>
00625 
<a name="l00626"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a4">00626</a> <span class="preprocessor">#define NtOfsInitializeMapHandle( M ) { (M)-&gt;Bcb = NULL; }</span>
00627 <span class="preprocessor"></span>
00628 <span class="comment">//</span>
00629 <span class="comment">//  NtOfsMapAttribute maps a portion of the specified attribute and returns a pointer</span>
00630 <span class="comment">//  to the memory.  The memory mapped may not span a mapping window.  Multiple maps</span>
00631 <span class="comment">//  are allowed through different handles in different threads.  The data is not</span>
00632 <span class="comment">//  preread nor is the memory pinned.</span>
00633 <span class="comment">//</span>
00634 
00635 
00636 <span class="preprocessor">#ifndef _NTFSPROC_</span>
00637 <span class="preprocessor"></span><a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00638 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00639 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a92">NtOfsMapAttribute</a> (
00640     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00641     IN ATTRIBUTE_HANDLE Attribute,
00642     IN LONGLONG Offset,
00643     IN ULONG Length,
00644     OUT PVOID *Buffer,
00645     OUT PMAP_HANDLE MapHandle
00646     );
00647 
00648 <span class="preprocessor">#else</span>
00649 <span class="preprocessor"></span><span class="preprocessor">#ifdef MAPCOUNT_DBG</span>
00650 <span class="preprocessor"></span><span class="preprocessor">#define NtOfsMapAttribute(I,S,O,L,B,M) (                                             \</span>
00651 <span class="preprocessor">    CcMapData((S)-&gt;FileObject, (PLARGE_INTEGER)&amp;(O), (L), TRUE, &amp;(M)-&gt;Bcb, (B)),     \</span>
00652 <span class="preprocessor">    (I)-&gt;MapCount++,                                                                 \</span>
00653 <span class="preprocessor">    (M)-&gt;FileOffset = (O),                                                           \</span>
00654 <span class="preprocessor">    (M)-&gt;Length = (L),                                                               \</span>
00655 <span class="preprocessor">    (M)-&gt;Buffer = *(PVOID *)(B)                                                      \</span>
00656 <span class="preprocessor">)</span>
00657 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00658 <span class="preprocessor"></span><span class="preprocessor">#define NtOfsMapAttribute(I,S,O,L,B,M) (                                             \</span>
00659 <span class="preprocessor">    CcMapData((S)-&gt;FileObject, (PLARGE_INTEGER)&amp;(O), (L), TRUE, &amp;(M)-&gt;Bcb, (B)),     \</span>
00660 <span class="preprocessor">    (M)-&gt;FileOffset = (O),                                                           \</span>
00661 <span class="preprocessor">    (M)-&gt;Length = (L),                                                               \</span>
00662 <span class="preprocessor">    (M)-&gt;Buffer = *(PVOID *)(B)                                                      \</span>
00663 <span class="preprocessor">)</span>
00664 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00665 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00666 <span class="preprocessor"></span>
00667 <span class="comment">//</span>
00668 <span class="comment">//  NtOfsPreparePinWrite maps and pins a portion of the specified attribute and</span>
00669 <span class="comment">//  returns a pointer to the memory.  This is equivalent to doing a NtOfsMapAttribute</span>
00670 <span class="comment">//  followed by NtOfsPinRead and NtOfsDirty but is more efficient.</span>
00671 <span class="comment">//</span>
00672 
00673 <span class="preprocessor">#ifndef _NTFSPROC_</span>
00674 <span class="preprocessor"></span><a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00675 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00676 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a93">NtOfsPreparePinWrite</a> (
00677     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00678     IN ATTRIBUTE_HANDLE Attribute,
00679     IN LONGLONG Offset,
00680     IN ULONG Length,
00681     OUT PVOID *Buffer,
00682     OUT PMAP_HANDLE MapHandle
00683     );
00684 
00685 <span class="preprocessor">#else</span>
00686 <span class="preprocessor"></span><span class="preprocessor">#ifdef MAPCOUNT_DBG</span>
00687 <span class="preprocessor"></span><span class="preprocessor">#define NtOfsPreparePinWrite(I,S,O,L,B,M) {                                                     \</span>
00688 <span class="preprocessor">    if (((O) + (L)) &gt; (S)-&gt;Header.AllocationSize.QuadPart) {                                    \</span>
00689 <span class="preprocessor">        ExRaiseStatus(STATUS_END_OF_FILE);                                                      \</span>
00690 <span class="preprocessor">    }                                                                                           \</span>
00691 <span class="preprocessor">    CcPreparePinWrite((S)-&gt;FileObject, (PLARGE_INTEGER)&amp;(O), (L), FALSE, TRUE, &amp;(M)-&gt;Bcb, (B)); \</span>
00692 <span class="preprocessor">    (I)-&gt;MapCount++;                                                                            \</span>
00693 <span class="preprocessor">    (M)-&gt;FileOffset = (O);                                                                      \</span>
00694 <span class="preprocessor">    (M)-&gt;Length = (L);                                                                          \</span>
00695 <span class="preprocessor">    (M)-&gt;Buffer = (B);                                                                          \</span>
00696 <span class="preprocessor">}</span>
00697 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00698 <span class="preprocessor"></span><span class="preprocessor">#define NtOfsPreparePinWrite(I,S,O,L,B,M) {                                                     \</span>
00699 <span class="preprocessor">    if (((O) + (L)) &gt; (S)-&gt;Header.AllocationSize.QuadPart) {                                    \</span>
00700 <span class="preprocessor">        ExRaiseStatus(STATUS_END_OF_FILE);                                                      \</span>
00701 <span class="preprocessor">    }                                                                                           \</span>
00702 <span class="preprocessor">    CcPreparePinWrite((S)-&gt;FileObject, (PLARGE_INTEGER)&amp;(O), (L), FALSE, TRUE, &amp;(M)-&gt;Bcb, (B)); \</span>
00703 <span class="preprocessor">    (M)-&gt;FileOffset = (O);                                                                      \</span>
00704 <span class="preprocessor">    (M)-&gt;Length = (L);                                                                          \</span>
00705 <span class="preprocessor">    (M)-&gt;Buffer = (B);                                                                          \</span>
00706 <span class="preprocessor">}</span>
00707 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00708 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00709 <span class="preprocessor"></span>
00710 <span class="comment">//</span>
00711 <span class="comment">//  NtOfsPinRead pins a section of a map and read in all pages from the mapped</span>
00712 <span class="comment">//  attribute.  Offset and Length must describe a byte range which is equal to</span>
00713 <span class="comment">//  or included by the original mapped range.</span>
00714 <span class="comment">//</span>
00715 
00716 <span class="preprocessor">#ifndef _NTFSPROC_</span>
00717 <span class="preprocessor"></span><a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00718 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00719 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a94">NtOfsPinRead</a>(
00720     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00721     IN ATTRIBUTE_HANDLE Attribute,
00722     IN LONGLONG Offset,
00723     IN ULONG Length,
00724     OUT PMAP_HANDLE MapHandle
00725     );
00726 
00727 <span class="preprocessor">#else</span>
00728 <span class="preprocessor"></span><span class="preprocessor">#ifdef MAPCOUNT_DBG</span>
00729 <span class="preprocessor"></span><span class="preprocessor">#define NtOfsPinRead(I,S,O,L,M) {                                                           \</span>
00730 <span class="preprocessor">    ASSERT((M)-&gt;Bcb != NULL);                                                               \</span>
00731 <span class="preprocessor">    ASSERT(((O) &gt;= (M)-&gt;FileOffset) &amp;&amp; (((O) + (L)) &lt;= ((M)-&gt;FileOffset + (M)-&gt;Length)));   \</span>
00732 <span class="preprocessor">    CcPinMappedData((S)-&gt;FileObject, (PLARGE_INTEGER)&amp;(O), (L), TRUE, &amp;(M)-&gt;Bcb);           \</span>
00733 <span class="preprocessor">    (I)-&gt;MapCount++;                                                                        \</span>
00734 <span class="preprocessor">    (M)-&gt;FileOffset = (O);                                                                  \</span>
00735 <span class="preprocessor">    (M)-&gt;Length = (L);                                                                      \</span>
00736 <span class="preprocessor">}</span>
00737 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00738 <span class="preprocessor"></span><span class="preprocessor">#define NtOfsPinRead(I,S,O,L,M) {                                                           \</span>
00739 <span class="preprocessor">    ASSERT((M)-&gt;Bcb != NULL);                                                               \</span>
00740 <span class="preprocessor">    ASSERT(((O) &gt;= (M)-&gt;FileOffset) &amp;&amp; (((O) + (L)) &lt;= ((M)-&gt;FileOffset + (M)-&gt;Length)));   \</span>
00741 <span class="preprocessor">    CcPinMappedData((S)-&gt;FileObject, (PLARGE_INTEGER)&amp;(O), (L), TRUE, &amp;(M)-&gt;Bcb);           \</span>
00742 <span class="preprocessor">    (M)-&gt;FileOffset = (O);                                                                  \</span>
00743 <span class="preprocessor">    (M)-&gt;Length = (L);                                                                      \</span>
00744 <span class="preprocessor">}</span>
00745 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00746 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00747 <span class="preprocessor"></span>
00748 <span class="comment">//</span>
00749 <span class="comment">//  NtOfsDirty marks a map as being dirty (eligible for lazy writer access) and</span>
00750 <span class="comment">//  marks the pages with an optional LSN for coordination with LFS.  This call</span>
00751 <span class="comment">//  is invalid unless the map has been pinned.</span>
00752 <span class="comment">//</span>
00753 
00754 <span class="comment">//  NTFSAPI</span>
00755 <span class="comment">//  NtOfsDirty (</span>
00756 <span class="comment">//      IN PIRP_CONTEXT IrpContext,</span>
00757 <span class="comment">//      IN PMAP_HANDLE MapHandle,</span>
00758 <span class="comment">//      PLSN Lsn OPTIONAL</span>
00759 <span class="comment">//      );</span>
00760 
<a name="l00761"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a5">00761</a> <span class="preprocessor">#define NtOfsDirty(I,M,L) {CcSetDirtyPinnedData((M)-&gt;Bcb,(L));}</span>
00762 <span class="preprocessor"></span>
00763 <span class="comment">//</span>
00764 <span class="comment">//  NtOfsReleaseMap unmaps/unpins a mapped portion of an attribute.</span>
00765 <span class="comment">//</span>
00766 
00767 
00768 <span class="preprocessor">#ifndef _NTFSPROC_</span>
00769 <span class="preprocessor"></span><a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00770 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00771 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a95">NtOfsReleaseMap</a> (
00772     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00773     IN PMAP_HANDLE MapHandle
00774     );
00775 
00776 <span class="preprocessor">#else</span>
00777 <span class="preprocessor"></span>
00778 <span class="preprocessor">#ifdef MAPCOUNT_DBG</span>
00779 <span class="preprocessor"></span><span class="preprocessor">#define NtOfsReleaseMap(IC,M) {                             \</span>
00780 <span class="preprocessor">    if ((M)-&gt;Bcb != NULL) {                                 \</span>
00781 <span class="preprocessor">        CcUnpinData((M)-&gt;Bcb);                              \</span>
00782 <span class="preprocessor">        (IC)-&gt;MapCount--;                                   \</span>
00783 <span class="preprocessor">        (M)-&gt;Bcb = NULL;                                    \</span>
00784 <span class="preprocessor">    }                                                       \</span>
00785 <span class="preprocessor">}</span>
00786 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00787 <span class="preprocessor"></span><span class="preprocessor">#define NtOfsReleaseMap(IC,M) {                             \</span>
00788 <span class="preprocessor">    if ((M)-&gt;Bcb != NULL) {                                 \</span>
00789 <span class="preprocessor">        CcUnpinData((M)-&gt;Bcb);                              \</span>
00790 <span class="preprocessor">        (M)-&gt;Bcb = NULL;                                    \</span>
00791 <span class="preprocessor">    }                                                       \</span>
00792 <span class="preprocessor">}</span>
00793 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00794 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00795 <span class="preprocessor"></span>
00796 <span class="comment">//</span>
00797 <span class="comment">//  NtOfsPutData writes data into an attribute in a recoverable fashion.  The</span>
00798 <span class="comment">//  caller must have opened the attribute with LogNonresidentToo.</span>
00799 <span class="comment">//</span>
00800 <span class="comment">//  NtOfsPutData will write the data atomically and update the mapped image,</span>
00801 <span class="comment">//  subject to the normal lazy commit of the transaction.</span>
00802 <span class="comment">//</span>
00803 
00804 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00805 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00806 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a96">NtOfsPutData</a> (
00807     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00808     IN ATTRIBUTE_HANDLE Attribute,
00809     IN LONGLONG Offset,
00810     IN ULONG Length,
00811     IN PVOID Data OPTIONAL
00812     );
00813 
00814 
00815 
00816 
00817 <span class="comment">//</span>
00818 <span class="comment">//  Attribute API - These encapsulate access to attributes on files/directories</span>
00819 <span class="comment">//  and summary catalogs</span>
00820 <span class="comment">//</span>
00821 
00822 <span class="comment">//</span>
00823 <span class="comment">//  NtOfsCreateAttribute will create or open a data attribute and return a handle</span>
00824 <span class="comment">//  that will allow mapping operations.</span>
00825 <span class="comment">//</span>
00826 <span class="comment">//  For attributes that wish to have logging behavior, LogNonresidentToo must be</span>
00827 <span class="comment">//  set to true.  See the discussion on NtOfsPutData (in the mapping section</span>
00828 <span class="comment">//  above).</span>
00829 <span class="comment">//</span>
00830 
00831 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00832 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00833 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a97">NtOfsCreateAttribute</a> (
00834     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00835     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ObjectHandle,
00836     IN UNICODE_STRING Name,
00837     IN CREATE_OPTIONS CreateOptions,
00838     IN ULONG LogNonresidentToo,
00839     OUT ATTRIBUTE_HANDLE *AttributeHandle
00840     );
00841 
00842 <span class="comment">//</span>
00843 <span class="comment">//  NtOfsCreateAttributeEx will create or open an attribute and return a handle</span>
00844 <span class="comment">//  that will allow mapping operations.  If a standard data attribute is to be</span>
00845 <span class="comment">//  used, call NtOfsCreateAttribute instead.  This function is here for callers</span>
00846 <span class="comment">//  who need to use a different attribute type code.</span>
00847 <span class="comment">//</span>
00848 <span class="comment">//  For attributes that wish to have logging behavior, LogNonresidentToo must be</span>
00849 <span class="comment">//  set to true.  See the discussion on NtOfsPutData (in the mapping section</span>
00850 <span class="comment">//  above).</span>
00851 <span class="comment">//</span>
00852 
00853 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00854 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00855 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a98">NtOfsCreateAttributeEx</a> (
00856     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00857     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ObjectHandle,
00858     IN UNICODE_STRING Name,
00859     IN ULONG AttributeTypeCode,
00860     IN CREATE_OPTIONS CreateOptions,
00861     IN ULONG LogNonresidentToo,
00862     OUT ATTRIBUTE_HANDLE *AttributeHandle
00863     );
00864 
00865 <span class="comment">//</span>
00866 <span class="comment">//  Valid AttributeTypeCode values for NtOfsCreateAttributeEx:</span>
00867 <span class="comment">//</span>
00868 
<a name="l00869"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a6">00869</a> <span class="preprocessor">#define $LOGGED_UTILITY_STREAM           (0x100)</span>
00870 <span class="preprocessor"></span>
00871 
00872 <span class="comment">//</span>
00873 <span class="comment">//  NtOfsCloseAttribute releases the attribute.  The attribute is not acquired.  No</span>
00874 <span class="comment">//  outstanding maps are active.</span>
00875 <span class="comment">//</span>
00876 
00877 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00878 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00879 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a99">NtOfsCloseAttribute</a> (
00880     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00881     IN ATTRIBUTE_HANDLE AttributeHandle
00882     );
00883 
00884 <span class="comment">//</span>
00885 <span class="comment">//  NtOfsDeleteAttribute releases all storage associated with the attribute.  The</span>
00886 <span class="comment">//  object will be acquired exclusive.  The attribute will be acquired exclusive.</span>
00887 <span class="comment">//  No outstanding maps are active.</span>
00888 <span class="comment">//</span>
00889 
00890 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00891 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00892 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a100">NtOfsDeleteAttribute</a> (
00893     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00894     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ObjectHandle,
00895     IN ATTRIBUTE_HANDLE AttributeHandle
00896     );
00897 
00898 <span class="comment">//</span>
00899 <span class="comment">//  NtOfsQueryLength returns the current length of user data within the attribute.</span>
00900 <span class="comment">//  The attribute may be mapped.  The attribute may be acquired.</span>
00901 <span class="comment">//</span>
00902 
00903 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00904 LONGLONG
00905 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a101">NtOfsQueryLength</a> (
00906     IN ATTRIBUTE_HANDLE AttributeHandle
00907     );
00908 
00909 <span class="comment">//</span>
00910 <span class="comment">//  NtOfsSetLength sets the current EOF on the given attribute.  The attribute</span>
00911 <span class="comment">//  may not be mapped to the view containing Length, or any subsequent view.</span>
00912 <span class="comment">//  The attribute will be acquired exclusive.</span>
00913 <span class="comment">//</span>
00914 
00915 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00916 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00917 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a102">NtOfsSetLength</a> (
00918     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00919     IN ATTRIBUTE_HANDLE Attribute,
00920     IN LONGLONG Length
00921     );
00922 <span class="comment">//</span>
00923 <span class="comment">//  NtOfsWaitForNewLength allows the caller to wait for the specified length to</span>
00924 <span class="comment">//  be exceeded, or optionally timeout, if the specified Irp has not been cancelled.</span>
00925 <span class="comment">//</span>
00926 
00927 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00928 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00929 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a103">NtOfsWaitForNewLength</a> (
00930     IN ATTRIBUTE_HANDLE Attribute,
00931     IN LONGLONG Length,
00932     IN ULONG Async,
00933     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00934     IN PDRIVER_CANCEL CancelRoutine,
00935     IN PLARGE_INTEGER Timeout OPTIONAL
00936     );
00937 
00938 <span class="comment">//</span>
00939 <span class="comment">//  This routine may be called any time FileSize has changed to wake any threads</span>
00940 <span class="comment">//  waiting for a particular FileSize change.  Or specify WakeAll to unconditionally</span>
00941 <span class="comment">//  wake all waiters.</span>
00942 <span class="comment">//</span>
00943 
00944 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00945 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a104">NtOfsPostNewLength</a> (
00946     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext OPTIONAL,
00947     IN ATTRIBUTE_HANDLE Attribute,
00948     IN BOOLEAN WakeAll
00949     );
00950 
00951 <span class="comment">//</span>
00952 <span class="comment">//  NtOfsDecommit releases storage associated with a range of the attribute.  It does</span>
00953 <span class="comment">//  not change the EOF marker nor does it change the logical position of data within</span>
00954 <span class="comment">//  the attribute.  The range of the attribute being released may be mapped or</span>
00955 <span class="comment">//  pinned.</span>
00956 <span class="comment">//</span>
00957 <span class="comment">//  Reads from decommitted ranges should return zero (although Query will never read</span>
00958 <span class="comment">//  from these ranges).</span>
00959 <span class="comment">//</span>
00960 <span class="comment">//  Writes to decommitted pages should fail or be nooped (although Query will never</span>
00961 <span class="comment">//  write to these ranges).</span>
00962 <span class="comment">//</span>
00963 <span class="comment">//  This call will purge, so none of the views overlapping the specified range may</span>
00964 <span class="comment">//  be mapped.</span>
00965 <span class="comment">//</span>
00966 
00967 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00968 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00969 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a105">NtOfsDecommit</a> (
00970     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00971     IN ATTRIBUTE_HANDLE Attribute,
00972     IN LONGLONG Offset,
00973     IN LONGLONG Length
00974     );
00975 
00976 <span class="comment">//</span>
00977 <span class="comment">//  NtOfsFlushAttribute flushes all cached data to the disk and returns upon</span>
00978 <span class="comment">//  completion.  If the attribute is LogNonresidentToo, then only the log file</span>
00979 <span class="comment">//  is flushed.  Optionally, the range may be purged as well.  If the attribute</span>
00980 <span class="comment">//  is purged, then there can be no mapped views.</span>
00981 <span class="comment">//</span>
00982 
00983 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00984 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00985 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a106">NtOfsFlushAttribute</a> (
00986     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00987     IN ATTRIBUTE_HANDLE Attribute,
00988     IN ULONG Purge
00989     );
00990 
00991 <span class="comment">//</span>
00992 <span class="comment">//  NtOfsQueryAttributeSecurityId returns the security ID for the attribute if</span>
00993 <span class="comment">//  present.</span>
00994 <span class="comment">//</span>
00995 
00996 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
00997 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00998 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a107">NtOfsQueryAttributeSecurityId</a> (
00999     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01000     IN ATTRIBUTE_HANDLE Attribute,
01001     OUT SECURITY_ID *SecurityId
01002     );
01003 
01004 
01005 
01006 <span class="comment">//</span>
01007 <span class="comment">//  Concurrency control API</span>
01008 <span class="comment">//</span>
01009 <span class="comment">//  As a rule, these routines are not required.  All NtOfs routines are</span>
01010 <span class="comment">//  self-synchronized as atomic actions, or as parts of a top-level action when</span>
01011 <span class="comment">//  called within a top-level action routine.</span>
01012 <span class="comment">//</span>
01013 <span class="comment">//  ISSUE:  In particular, supporting the exclusive access call is an implementation</span>
01014 <span class="comment">//          problem for Ntfs.  Wrapping top-level actions is the best way to preserve</span>
01015 <span class="comment">//          exclusive access across calls.</span>
01016 <span class="comment">//</span>
01017 
01018 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01019 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a108">NtOfsAcquireObjectShared</a> (
01020     HANDLE ObjectHandle
01021     );
01022 
01023 <span class="comment">//  VOID</span>
01024 <span class="comment">//  NtOfsAcquireObjectExclusive (</span>
01025 <span class="comment">//      HANDLE ObjectHandle</span>
01026 <span class="comment">//      );</span>
01027 
01028 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01029 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a109">NtOfsReleaseObject</a> (
01030     HANDLE ObjectHandle
01031     );
01032 
01033 <span class="comment">//  Debugging routines</span>
01034 BOOLEAN
01035 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a110">NtOfsIsObjectAcquiredExclusive</a> (
01036     HANDLE ObjectHandle
01037     );
01038 
01039 BOOLEAN
01040 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a111">NtOfsIsObjectAcquiredShared</a> (
01041     HANDLE ObjectHandle
01042     );
01043 
01044 
01045 
01046 
01047 <span class="comment">//</span>
01048 <span class="comment">//  File/Directory/Etc API</span>
01049 <span class="comment">//</span>
01050 
01051 <span class="comment">//</span>
01052 <span class="comment">//  NtOfsOpenByFileReference opens an object given a file reference.  The file is</span>
01053 <span class="comment">//  assumed to exist; this call cannot be used to create a file.  The returned</span>
01054 <span class="comment">//  handle is acquired according to the input exclusion.</span>
01055 <span class="comment">//</span>
01056 
01057 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01058 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01059 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a112">NtOfsOpenByFileReference</a> (
01060     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01061     IN <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">FILE_REFERENCE</a> FileReference,
01062     IN EXCLUSION Exclusion,
01063     OUT <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> *ObjectHandle
01064     );
01065 
01066 <span class="comment">//</span>
01067 <span class="comment">//  NtOfsCreateRelativeObject opens or creates an object relative to a specified</span>
01068 <span class="comment">//  parent object.  The parent will be acquired exclusive.  The child is opened</span>
01069 <span class="comment">//  acquired according to the input exclusion.</span>
01070 <span class="comment">//</span>
01071 <span class="comment">//  ISSUE:  When creating an object, is the transaction committed before this</span>
01072 <span class="comment">//  call returns?</span>
01073 <span class="comment">//</span>
01074 
01075 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01076 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01077 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a113">NtOfsCreateRelativeObject</a> (
01078     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01079     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ParentObjectHandle,
01080     IN UNICODE_STRING Name,
01081     IN CREATE_OPTIONS CreateOptions,
01082     IN EXCLUSION Exclusion,
01083     OUT <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> *ObjectHandle
01084     );
01085 
01086 <span class="comment">//</span>
01087 <span class="comment">//  NtOfsCloseObject releases the object handle.</span>
01088 <span class="comment">//</span>
01089 
01090 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01091 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01092 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a114">NtOfsCloseObject</a> (
01093     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01094     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ObjectHandle
01095     );
01096 
01097 <span class="comment">//</span>
01098 <span class="comment">//  NtOfsDeleteObject deletes the object.  No user-mode handle is attached to</span>
01099 <span class="comment">//  the object.  No attributes are currently open.  The object is acquired</span>
01100 <span class="comment">//  exclusive.</span>
01101 <span class="comment">//</span>
01102 
01103 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01104 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01105 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a115">NtOfsDeleteObject</a> (
01106     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01107     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ObjectHandle
01108     );
01109 
01110 <span class="comment">//</span>
01111 <span class="comment">//  NtOfsDeleteAllAttributes deletes all attributes of the object.  No attribute</span>
01112 <span class="comment">//  is open.  The object is acquired exclusive.</span>
01113 <span class="comment">//</span>
01114 
01115 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01116 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01117 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a116">NtOfsDeleteAllAttributes</a> (
01118     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01119     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ObjectHandle
01120     );
01121 
01122 <span class="comment">//</span>
01123 <span class="comment">//  NtOfsQueryPathFromRoot returns *A* path from the root to a node.  In the</span>
01124 <span class="comment">//  presence of hard links, several paths may exist, however, only one needs</span>
01125 <span class="comment">//  to be returned.  Memory for the file name is provided by the caller.</span>
01126 <span class="comment">//</span>
01127 
01128 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01129 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01130 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a117">NtOfsQueryPathFromRoot</a> (
01131     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01132     IN <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">FILE_REFERENCE</a> FileReference,
01133     OUT UNICODE_STRING *PathName
01134     );
01135 
01136 <span class="comment">//</span>
01137 <span class="comment">//  NtOfsQueryFileName returns the final component in the path name into a</span>
01138 <span class="comment">//  caller-supplied buffer.  In the presence of hard links, several names</span>
01139 <span class="comment">//  may exist, however, only one needs to be returned.</span>
01140 <span class="comment">//</span>
01141 
01142 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01143 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01144 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a118">NtOfsQueryFileName</a> (
01145     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01146     IN <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">FILE_REFERENCE</a> FileReference,
01147     OUT UNICODE_STRING *FileName
01148     );
01149 
01150 <span class="comment">//</span>
01151 <span class="comment">//  NtOfsQueryFileReferenceFromName returns the file reference named by the path</span>
01152 <span class="comment">//</span>
01153 
01154 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01155 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01156 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a119">NtOfsQueryFileReferenceFromName</a> (
01157     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01158     IN UNICODE_STRING Name,
01159     OUT <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">FILE_REFERENCE</a> *FileReference
01160     );
01161 
01162 <span class="comment">//</span>
01163 <span class="comment">//  This call must be very fast;  it is a very common call made by CI/Query.</span>
01164 <span class="comment">//</span>
01165 
01166 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01167 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01168 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a120">NtOfsQueryFileReferenceFromHandle</a> (
01169     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> Object,
01170     OUT <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">FILE_REFERENCE</a> *FileReference
01171     );
01172 
01173 <span class="comment">//</span>
01174 <span class="comment">//  NtOfsQueryObjectSecurityId returns the security Id associated with an object.</span>
01175 <span class="comment">//  The object is acquired shared or exclusive.  This call must be very fast</span>
01176 <span class="comment">//</span>
01177 
01178 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01179 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01180 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a121">NtOfsQueryObjectSecurityId</a> (
01181     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01182     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ObjectHandle,
01183     OUT SECURITY_ID *SecurityId
01184     );
01185 
01186 
01187 
01188 
01189 <span class="comment">//</span>
01190 <span class="comment">//  Scope API</span>
01191 <span class="comment">//</span>
01192 
01193 <span class="comment">//</span>
01194 <span class="comment">//  NtOfsIsAncestorOf must quickly tell if one file is an ancestor of the given</span>
01195 <span class="comment">//  child.  In the presence of hard links, we may pick a "preferred" path (i.e.</span>
01196 <span class="comment">//  we don't have to travel to all ancestors).  This call must be reasonably fast</span>
01197 <span class="comment">//  since this is a very frequent call from Query.</span>
01198 <span class="comment">//</span>
01199 
01200 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01201 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01202 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a122">NtOfsIsAncestorOf</a> (
01203     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01204     IN <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">FILE_REFERENCE</a> Ancestor,
01205     IN <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">FILE_REFERENCE</a> Child
01206     );
01207 
01208 <span class="comment">//</span>
01209 <span class="comment">//  NtOfsGetParentFileReferenceFromHandle is used to retrieve the FileReference</span>
01210 <span class="comment">//  of the parent of the named object.  With hard links the "first" parent may</span>
01211 <span class="comment">//  be chosen.  This call needs to be reasonably efficient.</span>
01212 <span class="comment">//</span>
01213 
01214 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01215 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01216 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a123">NtOfsGetParentFileReferenceFromHandle</a> (
01217     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01218     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ChildObject,
01219     OUT <a class="code" href="../../d0/d2/struct__FILE__REFERENCE.html">FILE_REFERENCE</a> *ParentFileReference
01220     );
01221 
01222 
01223 
01224 
01225 <span class="comment">//</span>
01226 <span class="comment">//  Security API</span>
01227 <span class="comment">//</span>
01228 <span class="comment">//  NtOfs maintains a "per-IrpContext" cache that speeds up security validation.</span>
01229 <span class="comment">//  Clients clear the cache (at the beginning of a query, say) and then do</span>
01230 <span class="comment">//  successive probes which may populate the cache.</span>
01231 <span class="comment">//</span>
01232 
01233 <span class="comment">//</span>
01234 <span class="comment">//  NtOfsClearSecurityCache clears the cache.</span>
01235 <span class="comment">//</span>
01236 
01237 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01238 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01239 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a124">NtOfsClearSecurityCache</a> (
01240     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext
01241     );
01242 
01243 <span class="comment">//</span>
01244 <span class="comment">//  NtOfsIsAccessGranted uses the Se routines to validate access and caches the</span>
01245 <span class="comment">//  result for the specified SecurityId and DesiredAccess.  The cache is first</span>
01246 <span class="comment">//  probed to see if the access can be granted immediately.  If the SecurityId is</span>
01247 <span class="comment">//  not found, the corresponding ACL is retrieved and tested with the supplied</span>
01248 <span class="comment">//  access state and DesiredAccess.  The result of this test is cached and</span>
01249 <span class="comment">//  returned.</span>
01250 <span class="comment">//</span>
01251 
01252 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01253 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01254 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a125">NtOfsIsAccessGranted</a> (
01255     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01256     IN SECURITY_ID SecurityId,
01257     IN ACCESS_MASK DesiredAccess,
01258     IN <a class="code" href="../../d2/d5/struct__ACCESS__STATE.html">ACCESS_STATE</a> *SecurityAccessState
01259     );
01260 
01261 
01262 
01263 
01264 <span class="comment">//</span>
01265 <span class="comment">//  Worker thread stuff.  Worker threads are needed for building new indexes</span>
01266 <span class="comment">//</span>
01267 
01268 
01269 
01270 
01271 <span class="comment">//</span>
01272 <span class="comment">//  Miscellaneous information query/set</span>
01273 <span class="comment">//</span>
01274 
01275 <span class="comment">//</span>
01276 <span class="comment">//  Content Index may need to mark the volume as dirty to allow garbage collection</span>
01277 <span class="comment">//  of orphan objects by CHKDSK.</span>
01278 <span class="comment">//</span>
01279 
01280 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01281 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01282 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a126">NtOfsMarkVolumeCorrupt</a> (
01283     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01284     IN ULONG NewState,
01285     IN ULONG StateMask,
01286     OUT ULONG *OldState
01287     );
01288 
01289 <span class="comment">//</span>
01290 <span class="comment">//  NtOfsQueryVolumeStatistics returns the current capacity and free space on a</span>
01291 <span class="comment">//  volume.  Ci uses this for heuristics to decide on when to trigger master merge,</span>
01292 <span class="comment">//  when to suppress master merge, etc.</span>
01293 <span class="comment">//</span>
01294 
01295 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01296 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01297 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a127">NtOfsQueryVolumeStatistics</a> (
01298     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01299     OUT LONGLONG *TotalClusters,
01300     OUT LONGLONG *FreeClusters
01301     );
01302 
01303 <span class="comment">//</span>
01304 <span class="comment">//  Query needs to retain some state in the NtOfs Ccb.</span>
01305 <span class="comment">//</span>
01306 
01307 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01308 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01309 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a128">NtOfsQueryHandleState</a> (
01310     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01311     OUT VOID *OldData
01312     );
01313 
01314 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01315 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01316 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a129">NtOfsSetHandleState</a> (
01317     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01318     IN VOID *Data
01319     );
01320 
01321 <span class="comment">//</span>
01322 <span class="comment">//  Generic unwrapping routines that get access to SCB/IRPC and FCB/IRPC</span>
01323 <span class="comment">//  pairs.</span>
01324 <span class="comment">//</span>
01325 
01326 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01327 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01328 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a130">NtOfsQueryAttributeHandle</a> (
01329     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01330     OUT ATTRIBUTE_HANDLE *AttributeHandle
01331     );
01332 
01333 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01334 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01335 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a131">NtOfsQueryObjectHandle</a> (
01336     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01337     OUT <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> *ObjectHandle
01338     );
01339 
01340 <span class="comment">//</span>
01341 <span class="comment">//  Create a context in which the caller can perform I/O in separate.</span>
01342 <span class="comment">//  threads.  This means creating an IRP/IRP_CONTEXT.  Each IrpContext corresponds</span>
01343 <span class="comment">//  to one I/O activity at a time.  Multiple IrpContexts may be active in a thread</span>
01344 <span class="comment">//  at a single time.</span>
01345 <span class="comment">//</span>
01346 
01347 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01348 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01349 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a132">NtOfsCloneIrpContext</a> (
01350     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01351     OUT <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> *NewIrpContext
01352     );
01353 
01354 <span class="comment">//</span>
01355 <span class="comment">//  NtOfsCompleteRequest completes an IrpContext that has been previously cloned.</span>
01356 <span class="comment">//  All other FsCtl Irps are completed by Ntfs.</span>
01357 <span class="comment">//</span>
01358 
01359 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01360 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01361 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a133">NtOfsCompleteRequest</a> (
01362     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01363     NTSTATUS Status
01364     );
01365 
01366 
01367 
01368 
01369 <span class="comment">//</span>
01370 <span class="comment">//  Iterators.  While each iterator is created through a separate API, each one</span>
01371 <span class="comment">//  must support two operations:</span>
01372 <span class="comment">//      Next - this fills a buffer with as many records as possible</span>
01373 <span class="comment">//      Close - this releases the iterator.</span>
01374 <span class="comment">//</span>
01375 
<a name="l01376"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a54">01376</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>_BASE_FILE_SEGMENT_ITERATOR <a class="code" href="../../d4/d8/ntfsexp_8h.html#a54">BASE_FILE_SEGMENT_ITERATOR</a>;
01377 
<a name="l01378"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a55">01378</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>_USN_ITERATOR <a class="code" href="../../d4/d8/ntfsexp_8h.html#a55">USN_ITERATOR</a>;
01379 
01380 <span class="comment">//</span>
01381 <span class="comment">//  The types of iterators are:</span>
01382 <span class="comment">//</span>
01383 <span class="comment">//      Scope            iterate over a directory (optionally RECURSIVE)</span>
01384 <span class="comment">//                       (implemented in Query)</span>
01385 <span class="comment">//      View             iterate over the rows in a view with a partial key match</span>
01386 <span class="comment">//                       (implemented in View)</span>
01387 <span class="comment">//      BaseFileSegment  iterate over all base file record segments</span>
01388 <span class="comment">//                       (implemented in NtOfs)</span>
01389 <span class="comment">//      SummaryCatalog   iterate over all rows in a summary catalog</span>
01390 <span class="comment">//      Usn              iterate over all objects with Usn's in a specific range</span>
01391 <span class="comment">//                       (implmented in NtOfs)</span>
01392 <span class="comment">//</span>
01393 <span class="comment">//  Each iteration is passed a buffer which is filled (as much as possible) with</span>
01394 <span class="comment">//  a packed array of:</span>
01395 <span class="comment">//      FILE_REFERENCE</span>
01396 <span class="comment">//      DUPLICATED_INFORMATION</span>
01397 <span class="comment">//      STAT_INFORMATION</span>
01398 <span class="comment">//  for each enumerated object.  The output length is the length in bytes that</span>
01399 <span class="comment">//  was filled in with the enumeration request.</span>
01400 
01401 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01402 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01403 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a134">NtOfsCreateBaseFileSegmentIterator</a> (
01404     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01405     OUT BASE_FILE_SEGMENT_ITERATOR *Iterator
01406     );
01407 
01408 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01409 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01410 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a135">NtOfsNextBaseFileSegmentIteration</a> (
01411     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01412     IN BASE_FILE_SEGMENT_ITERATOR *Iterator,
01413     IN OUT ULONG *BufferLength,
01414     IN OUT PVOID Buffer
01415     );
01416 
01417 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01418 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01419 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a136">NtOfsCloseBaseFileSegmentIterator</a> (
01420     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01421     IN BASE_FILE_SEGMENT_ITERATOR *Iterator
01422     );
01423 
01424 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01425 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01426 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a137">NtOfsCreateUsnIterator</a> (
01427     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01428     IN USN BeginningUsn,
01429     IN USN EndingUsn,
01430     OUT USN_ITERATOR *Iterator
01431     );
01432 
01433 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01434 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01435 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a138">NtOfsNextUsnIteration</a> (
01436     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01437     IN USN_ITERATOR *Iterator,
01438     IN OUT ULONG *BufferLength,
01439     IN OUT PVOID Buffer
01440     );
01441 
01442 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01443 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01444 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a139">NtOfsCloseUsnIterator</a> (
01445     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01446     IN USN_ITERATOR *Iterator
01447     );
01448 
01449 
01450 
01451 
01452 <span class="comment">//</span>
01453 <span class="comment">//  Infrastructure support.</span>
01454 <span class="comment">//</span>
01455 <span class="comment">//  V/C/X register callbacks with NtOfs when they are loaded.  Until they are loaded</span>
01456 <span class="comment">//  NtOfs will call default routines (that do nothing).</span>
01457 <span class="comment">//</span>
01458 
<a name="l01459"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a143">01459</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d4/d8/ntfsexp_8h.html#a143">_NTFS_ADDON_TYPES</a> {
01460     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a143a72">Encryption</a> = 3
01461 } <a class="code" href="../../d4/d8/ntfsexp_8h.html#a56">NTFS_ADDON_TYPES</a>;
01462 
01463 
01464 
01465 
01466 <span class="comment">//</span>
01467 <span class="comment">//  Encryption</span>
01468 <span class="comment">//</span>
01469 
01470 <span class="comment">//</span>
01471 <span class="comment">//  Stream Create Status       for FileDirFlag</span>
01472 <span class="comment">//</span>
01473 
<a name="l01474"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a7">01474</a> <span class="preprocessor">#define STREAM_NEW_OR_EXIST_MASK  0x000f0000</span>
<a name="l01475"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a8">01475</a> <span class="preprocessor"></span><span class="preprocessor">#define FILE_DIR_TYPE_MASK        0x000000ff</span>
01476 <span class="preprocessor"></span>
<a name="l01477"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a9">01477</a> <span class="preprocessor">#define FILE_NEW                  0x00000001</span>
<a name="l01478"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a10">01478</a> <span class="preprocessor"></span><span class="preprocessor">#define FILE_EXISTING             0x00000002</span>
<a name="l01479"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a11">01479</a> <span class="preprocessor"></span><span class="preprocessor">#define DIRECTORY_NEW             0x00000004</span>
<a name="l01480"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a12">01480</a> <span class="preprocessor"></span><span class="preprocessor">#define DIRECTORY_EXISTING        0x00000008</span>
<a name="l01481"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a13">01481</a> <span class="preprocessor"></span><span class="preprocessor">#define EXISTING_FILE_ENCRYPTED   0x00000010</span>
<a name="l01482"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a14">01482</a> <span class="preprocessor"></span><span class="preprocessor">#define STREAM_NEW                0x00010000</span>
<a name="l01483"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a15">01483</a> <span class="preprocessor"></span><span class="preprocessor">#define STREAM_EXISTING           0x00020000</span>
01484 <span class="preprocessor"></span>
01485 <span class="comment">//</span>
01486 <span class="comment">//  Encryption flag         for EncryptionFlag</span>
01487 <span class="comment">//</span>
01488 
<a name="l01489"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a16">01489</a> <span class="preprocessor">#define STREAM_ENCRYPTED          0x00000001</span>
<a name="l01490"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a17">01490</a> <span class="preprocessor"></span><span class="preprocessor">#define FILE_ENCRYPTED            0x00000002</span>
01491 <span class="preprocessor"></span>
01492 <span class="comment">//</span>
01493 <span class="comment">//  Access flags</span>
01494 <span class="comment">//</span>
01495 <span class="comment">//  NB -- These values are NOT arbitrary.  Notice also that they are not</span>
01496 <span class="comment">//        in value order, they are grouped according to their meaning.</span>
01497 <span class="comment">//        Their values correspond to FILE_READ_DATA, etc. and</span>
01498 <span class="comment">//        TOKEN_HAS_BACKUP_PRIVILEGE, etc.</span>
01499 <span class="comment">//</span>
01500 
<a name="l01501"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a18">01501</a> <span class="preprocessor">#define READ_DATA_ACCESS          0x01</span>
<a name="l01502"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a19">01502</a> <span class="preprocessor"></span><span class="preprocessor">#define WRITE_DATA_ACCESS         0x02</span>
<a name="l01503"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a20">01503</a> <span class="preprocessor"></span><span class="preprocessor">#define APPEND_DATA_ACCESS        0x04</span>
<a name="l01504"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a21">01504</a> <span class="preprocessor"></span><span class="preprocessor">#define EXECUTE_ACCESS            0x20</span>
01505 <span class="preprocessor"></span>
<a name="l01506"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a22">01506</a> <span class="preprocessor">#define BACKUP_ACCESS             0x08</span>
<a name="l01507"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a23">01507</a> <span class="preprocessor"></span><span class="preprocessor">#define RESTORE_ACCESS            0x10</span>
<a name="l01508"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a24">01508</a> <span class="preprocessor"></span><span class="preprocessor">#define TRAVERSE_ACCESS           0x40</span>
01509 <span class="preprocessor"></span>
01510 <span class="keyword">typedef</span> <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01511"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a57">01511</a> (*ENCRYPTED_FILE_CREATE) (
01512     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> FileHdl,
01513     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> ParentDir OPTIONAL,
01514     IN <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp,
01515     IN ULONG FileDirFlag,
01516     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01517     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> VolDo,
01518     IN PVOID FileKeyContext,
01519     IN OUT PVOID *PKeyContext,
01520     IN OUT ULONG *ContextLength,
01521     IN OUT PVOID *PCreateContext,
01522     IN OUT PBOOLEAN Reserved
01523     );
01524 
01525 <span class="keyword">typedef</span> <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01526"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a58">01526</a> (*ENCRYPTED_FILE_PRE_CREATE) (
01527     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> VolDo,
01528     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
01529     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
01530     );
01531 
01532 <span class="keyword">typedef</span> <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01533"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a59">01533</a> (*ENCRYPTED_FILE_POST_CREATE) (
01534     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> VolDo,
01535     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
01536     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01537     IN <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
01538     IN OUT PVOID *PCreateContext
01539     );
01540 
01541 <span class="keyword">typedef</span> <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01542"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a60">01542</a> (*ENCRYPTED_FILE_SYSTEM_CONTROL) (
01543     IN PVOID PInputBuffer OPTIONAL,
01544     IN ULONG InputDataLength,
01545     OUT PVOID OutputBuffer OPTIONAL,
01546     IN OUT ULONG *OutputBufferLength OPTIONAL,
01547     IN ULONG EncryptionFlag,
01548     IN ULONG AccessFlag,
01549     IN ULONG FsControlCode,
01550     IN <a class="code" href="../../d7/d9/struct__FCB.html">OBJECT_HANDLE</a> FileHdl,
01551     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01552     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> VolDo,
01553     IN <a class="code" href="../../d4/d8/ntfsexp_8h.html#a31">ATTRIBUTE_HANDLE</a> Attribute,
01554     IN OUT PVOID *PContext OPTIONAL,
01555     IN OUT ULONG *ContextLength OPTIONAL
01556     );
01557 
01558 <span class="keyword">typedef</span> <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01559"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a61">01559</a> (*ENCRYPTED_FILE_PRE_FILE_SYSTEM_CONTROL) (
01560     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> VolDo,
01561     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
01562     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
01563     );
01564 
01565 <span class="keyword">typedef</span> <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01566"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a62">01566</a> (*ENCRYPTED_FILE_READ)(
01567     IN OUT PUCHAR InOutBuffer,
01568     IN PLARGE_INTEGER <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
01569     IN ULONG <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>,
01570     IN PVOID Context
01571     );
01572 
01573 <span class="keyword">typedef</span> <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01574"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a63">01574</a> (*ENCRYPTED_FILE_WRITE)(
01575     IN PUCHAR InBuffer,
01576     OUT PUCHAR OutBuffer,
01577     IN PLARGE_INTEGER <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
01578     IN ULONG <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>,
01579     IN PUCHAR Context
01580     );
01581 
01582 <span class="keyword">typedef</span> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01583"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a64">01583</a> (*ENCRYPTED_FILE_CLEANUP)(
01584     IN OUT PVOID *Context
01585     );
01586 
<a name="l01587"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a25">01587</a> <span class="preprocessor">#define ENCRYPTION_CURRENT_INTERFACE_VERSION 3</span>
01588 <span class="preprocessor"></span>
<a name="l01589"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a26">01589</a> <span class="preprocessor">#define ENCRYPTION_ALL_STREAMS       0x00000001</span>
<a name="l01590"></a><a class="code" href="../../d4/d8/ntfsexp_8h.html#a27">01590</a> <span class="preprocessor"></span><span class="preprocessor">#define ENCRYPTION_ALLOW_COMPRESSION 0x00000002</span>
01591 <span class="preprocessor"></span>
<a name="l01592"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html">01592</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html">_ENCRYPTION_CALL_BACK</a> {
<a name="l01593"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o0">01593</a>     ULONG <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o0">InterfaceVersion</a>;
<a name="l01594"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o1">01594</a>     ULONG <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o1">ImplementationFlags</a>;
<a name="l01595"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o2">01595</a>     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a57">ENCRYPTED_FILE_CREATE</a> <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o2">FileCreate</a>;
<a name="l01596"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o3">01596</a>     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a58">ENCRYPTED_FILE_PRE_CREATE</a> <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o3">PreCreate</a>;
<a name="l01597"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o4">01597</a>     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a59">ENCRYPTED_FILE_POST_CREATE</a> <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o4">PostCreate</a>;
<a name="l01598"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o5">01598</a>     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a60">ENCRYPTED_FILE_SYSTEM_CONTROL</a> <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o5">FileSystemControl_1</a>;
<a name="l01599"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o6">01599</a>     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a60">ENCRYPTED_FILE_SYSTEM_CONTROL</a> <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o6">FileSystemControl_2</a>;
<a name="l01600"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o7">01600</a>     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a61">ENCRYPTED_FILE_PRE_FILE_SYSTEM_CONTROL</a> <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o7">PreFileSystemControl</a>;
<a name="l01601"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o8">01601</a>     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a62">ENCRYPTED_FILE_READ</a> <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o8">AfterReadProcess</a>;
<a name="l01602"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o9">01602</a>     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a63">ENCRYPTED_FILE_WRITE</a> <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o9">BeforeWriteProcess</a>;
<a name="l01603"></a><a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o10">01603</a>     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a64">ENCRYPTED_FILE_CLEANUP</a> <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html#o10">CleanUp</a>;
01604 } <a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html">ENCRYPTION_CALL_BACK</a>, *<a class="code" href="../../d3/d3/struct__ENCRYPTION__CALL__BACK.html">PENCRYPTION_CALL_BACK</a>;
01605 
01606 <span class="comment">//</span>
01607 <span class="comment">//  NtOfsRegisterCallBacks supplies a call table to NtOfs.  Each table has an</span>
01608 <span class="comment">//  interface version number.  If the interface version does not exactly match</span>
01609 <span class="comment">//  what NtOfs expects, the call will fail.</span>
01610 <span class="comment">//</span>
01611 
01612 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a3">NTFSAPI</a>
01613 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01614 <a class="code" href="../../d4/d8/ntfsexp_8h.html#a140">NtOfsRegisterCallBacks</a> (
01615     NTFS_ADDON_TYPES NtfsAddonType,
01616     PVOID CallBackTable
01617     );
01618 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:00 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
