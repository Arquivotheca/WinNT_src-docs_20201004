<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: copysup.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>copysup.c File Reference</h1><code>#include "<a class="el" href="../../d6/d4/cc_8h-source.html">cc.h</a>"</code><br>

<p>
<a href="../../d6/d6/copysup_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d7/copysup_8c.html#a0">me</a>&nbsp;&nbsp;&nbsp;0x00000004</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d7/copysup_8c.html#a1">CcCopyRead</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, IN BOOLEAN Wait, OUT PVOID <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>, OUT PIO_STATUS_BLOCK IoStatus)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d7/copysup_8c.html#a2">CcFastCopyRead</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN ULONG FileOffset, IN ULONG Length, IN ULONG PageCount, OUT PVOID <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>, OUT PIO_STATUS_BLOCK IoStatus)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d7/copysup_8c.html#a3">CcCopyWrite</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN PLARGE_INTEGER FileOffset, IN ULONG Length, IN BOOLEAN Wait, IN PVOID <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d7/copysup_8c.html#a4">CcFastCopyWrite</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN ULONG FileOffset, IN ULONG Length, IN PVOID <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>LONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a> (IN PEXCEPTION_POINTERS ExceptionPointer, IN PNTSTATUS ExceptionCode)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d7/copysup_8c.html#a6">CcCanIWrite</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN ULONG BytesToWrite, IN BOOLEAN Wait, IN UCHAR Retrying)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d7/copysup_8c.html#a7">CcDeferWrite</a> (IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject, IN <a class="el" href="../../d4/d2/cache_8h.html#a56">PCC_POST_DEFERRED_WRITE</a> PostRoutine, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a107">Context1</a>, IN PVOID <a class="el" href="../../d3/d1/threads_8h.html#a108">Context2</a>, IN ULONG BytesToWrite, IN BOOLEAN Retrying)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d7/copysup_8c.html#a8">CcPostDeferredWrites</a> ()</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a0" doxytag="copysup.c::me" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define me&nbsp;&nbsp;&nbsp;0x00000004          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l00027">27</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a6" doxytag="copysup.c::CcCanIWrite" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN CcCanIWrite           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BytesToWrite</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Wait</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN UCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>Retrying</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l01790">1790</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00501">BooleanFlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01400">_DEFERRED_WRITE::BytesToWrite</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00156">CACHE_NTC_DEFERRED_WRITE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00096">CcDeferredWrites</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00095">CcDeferredWriteSpinLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00097">CcDirtyPageThreshold</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00066">CcIdleDelay</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00064">CcNoDelay</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l02099">CcPostDeferredWrites()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00103">CcTotalDirtyPages</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01406">_DEFERRED_WRITE::DeferredWriteLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00846">_SHARED_CACHE_MAP::DirtyPages</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00930">_SHARED_CACHE_MAP::DirtyPageThreshold</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01414">_DEFERRED_WRITE::Event</a>, <a class="el" href="../../d9/d8/client_2ntstubs_8c-source.html#l00086">Event()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d5/d8/ex_8h.html#a237">ExInterlockedInsertHeadList()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a238">ExInterlockedInsertTailList()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01394">_DEFERRED_WRITE::FileObject</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00211">FSRTL_FLAG_LIMIT_MODIFIED_PAGES</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d4/d1/timerobj_8c-source.html#l00243">KeSetTimer()</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01424">_DEFERRED_WRITE::LimitModifiedPages</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01123">MmEnoughMemoryForWrite</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01388">_DEFERRED_WRITE::NodeByteSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01387">_DEFERRED_WRITE::NodeTypeCode</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01457">_LAZY_WRITER::ScanDpc</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01458">_LAZY_WRITER::ScanTimer</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01472">_SECTION_OBJECT_POINTERS::SharedCacheMap</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l00280">WRITE_CHARGE_THRESHOLD</a>.
<p>
<pre class="fragment"><div>01799                    :
01800 
01801     This routine tests whether <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> ok to <span class="keywordflow">do</span> a write to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache
01802     or not, according to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Thresholds of dirty bytes and available
01803     pages.  The first time <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called <span class="keywordflow">for</span> a request (Retrying
01804     FALSE), we automatically make <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> request queue <span class="keywordflow">if</span> there are other
01805     requests in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> queue.
01806 
01807     Note that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> ListEmpty test <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> important to prevent small requests from sneaking
01808     in and starving large requests.
01809 
01810 Arguments:
01811 
01812     FileObject - <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> to be written
01813 
01814     BytesToWrite - Number of bytes caller wishes to write to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache.
01815 
01816     Wait - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller owns no resources, and can block inside <span class="keyword">this</span> routine
01817            until <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> ok to write.
01818 
01819     Retrying - Specified as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> when <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> request <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> first received, and
01820                otherwise specified as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <span class="keyword">this</span> write has already entered
01821                <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> queue.  Special non-zero value of MAXUCHAR indicates that
01822                we were called within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache manager with a MasterSpinLock held,
01823                so <span class="keywordflow">do</span> not attempt to acquire <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> here.  MAXUCHAR - 1 means we
01824                were called within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a> with some other spinlock
01825                held.  For either of these two special values, we <span class="keywordflow">do</span> not touch
01826                <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> FsRtl header.
01827 
01828 Return Value:
01829 
01830     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> ok to write.
01831     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller should defer <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> write via a call to <a class="code" href="../../d5/d7/copysup_8c.html#a7">CcDeferWrite</a>.
01832 
01833 --*/
01834 
01835 {
01836     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01837     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
01838     KIRQL OldIrql;
01839     ULONG PagesToWrite;
01840     BOOLEAN ExceededPerFileThreshold;
01841     <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a> DeferredWrite;
01842     <a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointers;
01843 
01844     <span class="comment">//</span>
01845     <span class="comment">//  Do a special test here for file objects that keep track of dirty</span>
01846     <span class="comment">//  pages on a per-file basis.  This is used mainly for slow links.</span>
01847     <span class="comment">//</span>
01848 
01849     ExceededPerFileThreshold = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01850 
01851     PagesToWrite = ((BytesToWrite &lt; <a class="code" href="../../d5/d5/cc_8h.html#a34">WRITE_CHARGE_THRESHOLD</a> ?
01852                      BytesToWrite : <a class="code" href="../../d5/d5/cc_8h.html#a34">WRITE_CHARGE_THRESHOLD</a>) + (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
01853 
01854     <span class="comment">//</span>
01855     <span class="comment">//  Don't dereference the FsContext field if we were called while holding</span>
01856     <span class="comment">//  a spinlock.</span>
01857     <span class="comment">//</span>
01858 
01859     <span class="keywordflow">if</span> ((Retrying &gt;= MAXUCHAR - 1) ||
01860 
01861         <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(FileObject-&gt;FsContext))-&gt;Flags,
01862                FSRTL_FLAG_LIMIT_MODIFIED_PAGES)) {
01863 
01864         <span class="keywordflow">if</span> (Retrying != MAXUCHAR) {
01865             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01866         }
01867 
01868         <span class="keywordflow">if</span> (((SectionObjectPointers = FileObject-&gt;SectionObjectPointer) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01869             ((SharedCacheMap = SectionObjectPointers-&gt;<a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html#o1">SharedCacheMap</a>) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01870             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o32">DirtyPageThreshold</a> != 0) &amp;&amp;
01871             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> != 0) &amp;&amp;
01872             ((PagesToWrite + SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a>) &gt;
01873               SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o32">DirtyPageThreshold</a>)) {
01874 
01875             ExceededPerFileThreshold = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01876         }
01877 
01878         <span class="keywordflow">if</span> (Retrying != MAXUCHAR) {
01879             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01880         }
01881     }
01882 
01883     <span class="comment">//</span>
01884     <span class="comment">//  See if it is ok to do the write right now</span>
01885     <span class="comment">//</span>
01886 
01887     <span class="keywordflow">if</span> ((Retrying || IsListEmpty(&amp;CcDeferredWrites))
01888 
01889                 &amp;&amp;
01890 
01891         (<a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> + PagesToWrite &lt; <a class="code" href="../../d5/d2/cachedat_8c.html#a30">CcDirtyPageThreshold</a>)
01892 
01893                 &amp;&amp;
01894 
01895         <a class="code" href="../../d2/d1/mm_8h.html#a23">MmEnoughMemoryForWrite</a>()
01896 
01897                 &amp;&amp;
01898 
01899         !ExceededPerFileThreshold) {
01900 
01901         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01902     }
01903 
01904     <span class="comment">//</span>
01905     <span class="comment">//  Otherwise, if our caller is synchronous, we will just wait here.</span>
01906     <span class="comment">//</span>
01907 
01908     <span class="keywordflow">if</span> (IsListEmpty(&amp;CcDeferredWrites) ) {
01909 
01910         <span class="comment">//</span>
01911         <span class="comment">// Get a write scan to occur NOW</span>
01912         <span class="comment">//</span>
01913 
01914         <a class="code" href="../../d3/d2/timerobj_8c.html#a6">KeSetTimer</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o4">ScanTimer</a>, CcNoDelay, &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o3">ScanDpc</a> );
01915     }
01916 
01917     <span class="keywordflow">if</span> (Wait) {
01918 
01919         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;Event, NotificationEvent, FALSE );
01920 
01921         <span class="comment">//</span>
01922         <span class="comment">//  Fill in the block.  Note that we can access the Fsrtl Common Header</span>
01923         <span class="comment">//  even if it's paged because Wait will be FALSE if called from</span>
01924         <span class="comment">//  within the cache.</span>
01925         <span class="comment">//</span>
01926 
01927         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a15">CACHE_NTC_DEFERRED_WRITE</a>;
01928         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a>);
01929         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o2">FileObject</a> = FileObject;
01930         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a> = BytesToWrite;
01931         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o5">Event</a> = &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
01932         DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o9">LimitModifiedPages</a> = <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(FileObject-&gt;FsContext))-&gt;Flags,
01933                                                          FSRTL_FLAG_LIMIT_MODIFIED_PAGES);
01934 
01935         <span class="comment">//</span>
01936         <span class="comment">//  Now insert at the appropriate end of the list</span>
01937         <span class="comment">//</span>
01938 
01939         <span class="keywordflow">if</span> (Retrying) {
01940             <a class="code" href="../../d5/d8/ex_8h.html#a237">ExInterlockedInsertHeadList</a>( &amp;CcDeferredWrites,
01941                                          &amp;DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a>,
01942                                          &amp;CcDeferredWriteSpinLock );
01943         } <span class="keywordflow">else</span> {
01944             <a class="code" href="../../d5/d8/ex_8h.html#a238">ExInterlockedInsertTailList</a>( &amp;CcDeferredWrites,
01945                                          &amp;DeferredWrite.<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a>,
01946                                          &amp;CcDeferredWriteSpinLock );
01947         }
01948 
01949         <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01950 
01951             <span class="comment">//</span>
01952             <span class="comment">//  Now since we really didn't synchronize anything but the insertion,</span>
01953             <span class="comment">//  we call the post routine to make sure that in some wierd case we</span>
01954             <span class="comment">//  do not leave anyone hanging with no dirty bytes for the Lazy Writer.</span>
01955             <span class="comment">//</span>
01956 
01957             <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
01958 
01959             <span class="comment">//</span>
01960             <span class="comment">//  Finally wait until the event is signalled and we can write</span>
01961             <span class="comment">//  and return to tell the guy he can write.</span>
01962             <span class="comment">//</span>
01963 
01964             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Event,
01965                                        Executive,
01966                                        KernelMode,
01967                                        FALSE,
01968                                        &amp;CcIdleDelay ) == STATUS_SUCCESS) {
01969 
01970 
01971                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01972             }
01973         }
01974 
01975     } <span class="keywordflow">else</span> {
01976         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01977     }
01978 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="copysup.c::CcCopyRead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN CcCopyRead           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Wait</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PIO_STATUS_BLOCK&nbsp;</td>
          <td class="mdname" nowrap> <em>IoStatus</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">31</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00583">_VACB::BaseAddress</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00662">_PRIVATE_CACHE_MAP::BeyondLastByte1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00665">_PRIVATE_CACHE_MAP::BeyondLastByte2</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01747">CcCopyReadExceptionFilter()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00188">CcCopyReadNoWait</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00190">CcCopyReadNoWaitMiss</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00189">CcCopyReadWait</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00191">CcCopyReadWaitMiss</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">CcFreeVirtualAddress()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">CcGetVirtualAddress()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00206">CcMissCounter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01253">CcScheduleReadAhead()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00160">CcThrowAway</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00974">CcUnpinFileData()</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00221">COMPUTE_PAGES_SPANNED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00661">_PRIVATE_CACHE_MAP::FileOffset1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00664">_PRIVATE_CACHE_MAP::FileOffset2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00752">_SHARED_CACHE_MAP::FileSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01510">FO_RANDOM_ACCESS</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01577">GetActiveVacb</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00385">HOT_STATISTIC</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d2/d4/mapcache_8c-source.html#l01016">MmCheckCachedPageState()</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01053">MmResetPageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00983">MmSavePageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01018">MmSetPageFaultReadAhead</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00713">_PRIVATE_CACHE_MAP::ReadAheadEnabled</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00677">_PRIVATE_CACHE_MAP::ReadAheadLength</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00117">ROUND_TO_PAGES</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01619">SetActiveVacb</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>, and <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00054">FsRtlCopyRead()</a>, and <a class="el" href="../../d8/d4/udfs_2read_8c-source.html#l00068">UdfCommonRead()</a>.
<p>
<pre class="fragment"><div>00042                    :
00043 
00044     This routine attempts to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache
00045     into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> output buffer, and deliver <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct I/O status.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> *not*
00046     safe to call <span class="keyword">this</span> routine from Dpc level.
00047 
00048     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller does not want to block (such as <span class="keywordflow">for</span> disk I/O), then
00049     Wait should be supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  If Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and
00050     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> currently impossible to supply all of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> requested data without
00051     blocking, then <span class="keyword">this</span> routine will <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  However, <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00052     data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache and no blocking <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00053     required, <span class="keyword">this</span> routine copies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data and returns <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
00054 
00055     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller supplies Wait as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, then <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> guaranteed
00056     to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data and <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately
00057     accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache, then no blocking will occur.  Otherwise,
00058     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data transfer from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache will be initiated,
00059     and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller will be blocked until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data can be returned.
00060 
00061     <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> system Fsd's should typically supply Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> they are
00062     processing a synchronous I/O requests, or Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> they are
00063     processing an asynchronous request.
00064 
00065     <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> system or <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a22">Server</a> Fsp threads should supply Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
00066 
00067 Arguments:
00068 
00069     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00070                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00071                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00072 
00073     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <span class="keywordflow">for</span> desired data.
00074 
00075     Length - Length of desired data in bytes.
00076 
00077     Wait - <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> caller may not block, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> otherwise (see description
00078            above)
00079 
00080     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Pointer to output buffer to which data should be copied.
00081 
00082     IoStatus - Pointer to standard I/O status block to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status
00083                <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> transfer.  (STATUS_SUCCESS guaranteed <span class="keywordflow">for</span> cache
00084                hits, otherwise <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual I/O status <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.)
00085 
00086                Note that even <span class="keywordflow">if</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> IoStatus.Information
00087                field will <span class="keywordflow">return</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> count of any bytes successfully
00088                transferred before a blocking condition occured.  The caller
00089                may either choose to ignore <span class="keyword">this</span> information, or resume
00090                <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> copy later accounting <span class="keywordflow">for</span> bytes transferred.
00091 
00092 Return Value:
00093 
00094     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> - <span class="keywordflow">if</span> Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data was not delivered
00095 
00096     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being delivered
00097 
00098 --*/
00099 
00100 {
00101     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00102     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
00103     PVOID CacheBuffer;
00104     LARGE_INTEGER FOffset;
00105     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
00106     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
00107     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
00108     ULONG ActivePage;
00109     ULONG PageIsDirty;
00110     ULONG SavedState;
00111     ULONG PagesToGo;
00112     ULONG MoveLength;
00113     ULONG LengthToGo;
00114     KIRQL OldIrql;
00115     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00116     ULONG OriginalLength = Length;
00117     ULONG PageCount = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>((ULongToPtr(FileOffset-&gt;LowPart)), Length);
00118     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00119     ULONG GotAMiss = 0;
00120 
00121     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcCopyRead\n"</span>, 0 );
00122 
00123     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
00124 
00125     <span class="comment">//</span>
00126     <span class="comment">//  Get pointer to shared and private cache maps</span>
00127     <span class="comment">//</span>
00128 
00129     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00130     PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
00131 
00132     <span class="comment">//</span>
00133     <span class="comment">//  Check for read past file size, the caller must filter this case out.</span>
00134     <span class="comment">//</span>
00135 
00136     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ( FileOffset-&gt;QuadPart + (LONGLONG)Length) &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart );
00137 
00138     <span class="comment">//</span>
00139     <span class="comment">//  If read ahead is enabled, then do the read ahead here so it</span>
00140     <span class="comment">//  overlaps with the copy (otherwise we will do it below).</span>
00141     <span class="comment">//  Note that we are assuming that we will not get ahead of our</span>
00142     <span class="comment">//  current transfer - if read ahead is working it should either</span>
00143     <span class="comment">//  already be in memory or else underway.</span>
00144     <span class="comment">//</span>
00145 
00146     <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> &amp;&amp; (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] == 0)) {
00147         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, FileOffset, Length );
00148     }
00149 
00150     FOffset = *FileOffset;
00151 
00152     <span class="comment">//</span>
00153     <span class="comment">//  Increment performance counters</span>
00154     <span class="comment">//</span>
00155 
00156     <span class="keywordflow">if</span> (Wait) {
00157         <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(CcCopyReadWait) += 1;
00158 
00159         <span class="comment">//</span>
00160         <span class="comment">//  This is not an exact solution, but when IoPageRead gets a miss,</span>
00161         <span class="comment">//  it cannot tell whether it was CcCopyRead or CcMdlRead, but since</span>
00162         <span class="comment">//  the miss should occur very soon, by loading the pointer here</span>
00163         <span class="comment">//  probably the right counter will get incremented, and in any case,</span>
00164         <span class="comment">//  we hope the errrors average out!</span>
00165         <span class="comment">//</span>
00166 
00167         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a64">CcCopyReadWaitMiss</a>;
00168 
00169     } <span class="keywordflow">else</span> {
00170         <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(CcCopyReadNoWait) += 1;
00171     }
00172 
00173     <span class="comment">//</span>
00174     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
00175     <span class="comment">//</span>
00176 
00177     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00178 
00179     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00180 
00181         <span class="keywordflow">if</span> ((ULONG)(FOffset.QuadPart &gt;&gt; <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a>) == (ActivePage &gt;&gt; (<a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>))) {
00182 
00183             ULONG LengthToCopy = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - (FOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1));
00184 
00185             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00186                 <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, NULL, 0, FALSE );
00187             }
00188 
00189             <span class="comment">//</span>
00190             <span class="comment">//  Get the starting point in the view.</span>
00191             <span class="comment">//</span>
00192 
00193             CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
00194                                           (FOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
00195 
00196             <span class="comment">//</span>
00197             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
00198             <span class="comment">//</span>
00199 
00200             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
00201                 LengthToCopy = Length;
00202             }
00203 
00204             <span class="comment">//</span>
00205             <span class="comment">//  Like the logic for the normal case below, we want to spin around</span>
00206             <span class="comment">//  making sure Mm only reads the pages we will need.</span>
00207             <span class="comment">//</span>
00208             
00209             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00210                                                LengthToCopy ) - 1;
00211 
00212             <span class="comment">//</span>
00213             <span class="comment">//  Copy the data to the user buffer.</span>
00214             <span class="comment">//</span>
00215 
00216             <span class="keywordflow">try</span> {
00217 
00218                 <span class="keywordflow">if</span> (PagesToGo != 0) {
00219     
00220                     LengthToGo = LengthToCopy;
00221     
00222                     <span class="keywordflow">while</span> (LengthToGo != 0) {
00223     
00224                         MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00225                                      (PCHAR)CacheBuffer);
00226     
00227                         <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00228                             MoveLength = LengthToGo;
00229                         }
00230     
00231                         <span class="comment">//</span>
00232                         <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00233                         <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00234                         <span class="comment">//  we are after before doing the move.</span>
00235                         <span class="comment">//</span>
00236     
00237                         <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00238                         GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00239     
00240                         RtlCopyBytes( Buffer, CacheBuffer, MoveLength );
00241     
00242                         PagesToGo -= 1;
00243     
00244                         LengthToGo -= MoveLength;
00245                         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00246                         CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00247                     }
00248     
00249                 <span class="comment">//</span>
00250                 <span class="comment">//  Handle the read here that stays on a single page.</span>
00251                 <span class="comment">//</span>
00252     
00253                 } <span class="keywordflow">else</span> {
00254     
00255                     <span class="comment">//</span>
00256                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00257                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00258                     <span class="comment">//  we are after before doing the move.</span>
00259                     <span class="comment">//</span>
00260     
00261                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00262                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00263     
00264                     RtlCopyBytes( Buffer, CacheBuffer, LengthToCopy );
00265     
00266                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy;
00267                 }
00268                 
00269             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00270                                                  &amp;Status ) ) {
00271 
00272                 <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00273 
00274                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00275 
00276                 <span class="comment">//</span>
00277                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
00278                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00279                 <span class="comment">//  to bring the data in.</span>
00280                 <span class="comment">//</span>
00281 
00282                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00283                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00284                 }
00285                 <span class="keywordflow">else</span> {
00286                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
00287                                                            STATUS_UNEXPECTED_IO_ERROR ));
00288                 }
00289             }
00290 
00291             <span class="comment">//</span>
00292             <span class="comment">//  Now adjust FOffset and Length by what we copied.</span>
00293             <span class="comment">//</span>
00294 
00295             FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)LengthToCopy;
00296             Length -= LengthToCopy;
00297 
00298         }
00299 
00300         <span class="comment">//</span>
00301         <span class="comment">//  If that was all the data, then remember the Vacb</span>
00302         <span class="comment">//</span>
00303 
00304         <span class="keywordflow">if</span> (Length == 0) {
00305 
00306             <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00307 
00308         <span class="comment">//</span>
00309         <span class="comment">//  Otherwise we must free it because we will map other vacbs below.</span>
00310         <span class="comment">//</span>
00311 
00312         } <span class="keywordflow">else</span> {
00313 
00314             <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
00315         }
00316     }
00317 
00318     <span class="comment">//</span>
00319     <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
00320     <span class="comment">//  until the entire transfer is complete.</span>
00321     <span class="comment">//</span>
00322 
00323     <span class="keywordflow">while</span> (Length != 0) {
00324 
00325         ULONG ReceivedLength;
00326         LARGE_INTEGER BeyondLastByte;
00327 
00328         <span class="comment">//</span>
00329         <span class="comment">//  Call local routine to Map or Access the file data, then move the data,</span>
00330         <span class="comment">//  then call another local routine to free the data.  If we cannot map</span>
00331         <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00332         <span class="comment">//</span>
00333         <span class="comment">//  Note that this call may result in an exception, however, if it</span>
00334         <span class="comment">//  does no Bcb is returned and this routine has absolutely no</span>
00335         <span class="comment">//  cleanup to perform.  Therefore, we do not have a try-finally</span>
00336         <span class="comment">//  and we allow the possibility that we will simply be unwound</span>
00337         <span class="comment">//  without notice.</span>
00338         <span class="comment">//</span>
00339 
00340         <span class="keywordflow">if</span> (Wait) {
00341 
00342             CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00343                                                FOffset,
00344                                                &amp;Vacb,
00345                                                &amp;ReceivedLength );
00346 
00347             BeyondLastByte.QuadPart = FOffset.QuadPart + (LONGLONG)ReceivedLength;
00348 
00349         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
00350                                    &amp;FOffset,
00351                                    Length,
00352                                    TRUE,
00353                                    FALSE,
00354                                    FALSE,
00355                                    &amp;Bcb,
00356                                    &amp;CacheBuffer,
00357                                    &amp;BeyondLastByte )) {
00358 
00359             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcCopyRead -&gt; FALSE\n"</span>, 0 );
00360 
00361             <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(CcCopyReadNoWaitMiss) += 1;
00362 
00363             <span class="comment">//</span>
00364             <span class="comment">//  Enable ReadAhead if we missed.</span>
00365             <span class="comment">//</span>
00366 
00367             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00368 
00369             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00370 
00371         } <span class="keywordflow">else</span> {
00372 
00373             <span class="comment">//</span>
00374             <span class="comment">//  Calculate how much data is described by Bcb starting at our desired</span>
00375             <span class="comment">//  file offset.</span>
00376             <span class="comment">//</span>
00377 
00378             ReceivedLength = (ULONG)(BeyondLastByte.QuadPart - FOffset.QuadPart);
00379         }
00380 
00381         <span class="comment">//</span>
00382         <span class="comment">//  If we got more than we need, make sure to only transfer</span>
00383         <span class="comment">//  the right amount.</span>
00384         <span class="comment">//</span>
00385 
00386         <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
00387             ReceivedLength = Length;
00388         }
00389 
00390         <span class="comment">//</span>
00391         <span class="comment">//  It is possible for the user buffer to become no longer accessible</span>
00392         <span class="comment">//  since it was last checked by the I/O system.  If we fail to access</span>
00393         <span class="comment">//  the buffer we must raise a status that the caller's exception</span>
00394         <span class="comment">//  filter considers as "expected".  Also we unmap the Bcb here, since</span>
00395         <span class="comment">//  we otherwise would have no other reason to put a try-finally around</span>
00396         <span class="comment">//  this loop.</span>
00397         <span class="comment">//</span>
00398 
00399         <span class="keywordflow">try</span> {
00400 
00401             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00402                                                ReceivedLength ) - 1;
00403 
00404             <span class="comment">//</span>
00405             <span class="comment">//  We know exactly how much we want to read here, and we do not</span>
00406             <span class="comment">//  want to read any more in case the caller is doing random access.</span>
00407             <span class="comment">//  Our read ahead logic takes care of detecting sequential reads,</span>
00408             <span class="comment">//  and tends to do large asynchronous read aheads.  So far we have</span>
00409             <span class="comment">//  only mapped the data and we have not forced any in.  What we</span>
00410             <span class="comment">//  do now is get into a loop where we copy a page at a time and</span>
00411             <span class="comment">//  just prior to each move, we tell MM how many additional pages</span>
00412             <span class="comment">//  we would like to have read in, in the event that we take a</span>
00413             <span class="comment">//  fault.  With this strategy, for cache hits we never make a single</span>
00414             <span class="comment">//  expensive call to MM to guarantee that the data is in, yet if we</span>
00415             <span class="comment">//  do take a fault, we are guaranteed to only take one fault because</span>
00416             <span class="comment">//  we will read all of the data in for the rest of the transfer.</span>
00417             <span class="comment">//</span>
00418             <span class="comment">//  We test first for the multiple page case, to keep the small</span>
00419             <span class="comment">//  reads faster.</span>
00420             <span class="comment">//</span>
00421 
00422             <span class="keywordflow">if</span> (PagesToGo != 0) {
00423 
00424                 LengthToGo = ReceivedLength;
00425 
00426                 <span class="keywordflow">while</span> (LengthToGo != 0) {
00427 
00428                     MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00429                                  (PCHAR)CacheBuffer);
00430 
00431                     <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00432                         MoveLength = LengthToGo;
00433                     }
00434 
00435                     <span class="comment">//</span>
00436                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00437                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00438                     <span class="comment">//  we are after before doing the move.</span>
00439                     <span class="comment">//</span>
00440 
00441                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00442                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00443 
00444                     RtlCopyBytes( Buffer, CacheBuffer, MoveLength );
00445 
00446                     PagesToGo -= 1;
00447 
00448                     LengthToGo -= MoveLength;
00449                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00450                     CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00451                 }
00452 
00453             <span class="comment">//</span>
00454             <span class="comment">//  Handle the read here that stays on a single page.</span>
00455             <span class="comment">//</span>
00456 
00457             } <span class="keywordflow">else</span> {
00458 
00459                 <span class="comment">//</span>
00460                 <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00461                 <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00462                 <span class="comment">//  we are after before doing the move.</span>
00463                 <span class="comment">//</span>
00464 
00465                 <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00466                 GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00467 
00468                 RtlCopyBytes( Buffer, CacheBuffer, ReceivedLength );
00469 
00470                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + ReceivedLength;
00471             }
00472 
00473         }
00474         except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00475                                            &amp;Status ) ) {
00476 
00477             <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00478 
00479             <span class="comment">//</span>
00480             <span class="comment">//  If we get an exception, then we have to renable page fault</span>
00481             <span class="comment">//  clustering and unmap on the way out.</span>
00482             <span class="comment">//</span>
00483 
00484             <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00485 
00486 
00487             <span class="keywordflow">if</span> (Wait) {
00488                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00489             } <span class="keywordflow">else</span> {
00490                 <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, TRUE, UNPIN );
00491             }
00492 
00493             <span class="comment">//</span>
00494             <span class="comment">//  If we got an access violation, then the user buffer went</span>
00495             <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00496             <span class="comment">//  to bring the data in.</span>
00497             <span class="comment">//</span>
00498 
00499             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00500                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00501             }
00502             <span class="keywordflow">else</span> {
00503                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
00504                                                        STATUS_UNEXPECTED_IO_ERROR ));
00505             }
00506         }
00507 
00508         <span class="comment">//</span>
00509         <span class="comment">//  Update number of bytes transferred.</span>
00510         <span class="comment">//</span>
00511 
00512         Length -= ReceivedLength;
00513 
00514         <span class="comment">//</span>
00515         <span class="comment">//  Unmap the data now, and calculate length left to transfer.</span>
00516         <span class="comment">//</span>
00517 
00518         <span class="keywordflow">if</span> (Wait) {
00519 
00520             <span class="comment">//</span>
00521             <span class="comment">//  If there is more to go, just free this vacb.</span>
00522             <span class="comment">//</span>
00523 
00524             <span class="keywordflow">if</span> (Length != 0) {
00525 
00526                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00527 
00528             <span class="comment">//</span>
00529             <span class="comment">//  Otherwise save it for the next time through.</span>
00530             <span class="comment">//</span>
00531 
00532             } <span class="keywordflow">else</span> {
00533 
00534                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, Vacb, (ULONG)(FOffset.QuadPart &gt;&gt; PAGE_SHIFT), 0 );
00535                 <span class="keywordflow">break</span>;
00536             }
00537 
00538         } <span class="keywordflow">else</span> {
00539             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, TRUE, UNPIN );
00540         }
00541 
00542         <span class="comment">//</span>
00543         <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
00544         <span class="comment">//  to the end of the returned data.</span>
00545         <span class="comment">//</span>
00546 
00547         FOffset = BeyondLastByte;
00548     }
00549 
00550     <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00551 
00552     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00553 
00554     <span class="comment">//</span>
00555     <span class="comment">//  Now enable read ahead if it looks like we got any misses, and do</span>
00556     <span class="comment">//  the first one.</span>
00557     <span class="comment">//</span>
00558 
00559     <span class="keywordflow">if</span> (GotAMiss &amp;&amp;
00560         !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, FO_RANDOM_ACCESS ) &amp;&amp;
00561         !PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a>) {
00562 
00563         PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00564         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, FileOffset, OriginalLength );
00565     }
00566 
00567     <span class="comment">//</span>
00568     <span class="comment">//  Now that we have described our desired read ahead, let's</span>
00569     <span class="comment">//  shift the read history down.</span>
00570     <span class="comment">//</span>
00571 
00572     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">FileOffset1</a> = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>;
00573     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a> = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>;
00574     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a> = *FileOffset;
00575     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.QuadPart =
00576                                 FileOffset-&gt;QuadPart + (LONGLONG)OriginalLength;
00577 
00578     IoStatus-&gt;Status = STATUS_SUCCESS;
00579     IoStatus-&gt;Information = OriginalLength;
00580 
00581     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcCopyRead -&gt; TRUE\n"</span>, 0 );
00582 
00583     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00584 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="copysup.c::CcCopyReadExceptionFilter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> LONG CcCopyReadExceptionFilter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PEXCEPTION_POINTERS&nbsp;</td>
          <td class="mdname" nowrap> <em>ExceptionPointer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PNTSTATUS&nbsp;</td>
          <td class="mdname" nowrap> <em>ExceptionCode</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l01747">1747</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, and <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l00031">CcCopyRead()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01075">CcCopyWrite()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">CcFastCopyRead()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01482">CcFastCopyWrite()</a>, and <a class="el" href="../../d7/d1/cachesub_8c-source.html#l06024">CcMapAndCopy()</a>.
<p>
<pre class="fragment"><div>01754                    :
01755 
01756     This routine serves as a exception filter and has <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> special job of
01757     extracting <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="stringliteral">"real"</span> I/O error when Mm raises STATUS_IN_PAGE_ERROR
01758     beneath us.
01759 
01760 Arguments:
01761 
01762     ExceptionPointer - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception record that contains
01763                        <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> real Io <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>.
01764 
01765     ExceptionCode - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to an <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> real
01766                     status.
01767 
01768 Return Value:
01769 
01770     <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>
01771 
01772 --*/
01773 
01774 {
01775     *ExceptionCode = ExceptionPointer-&gt;ExceptionRecord-&gt;ExceptionCode;
01776 
01777     <span class="keywordflow">if</span> ( (*ExceptionCode == STATUS_IN_PAGE_ERROR) &amp;&amp;
01778          (ExceptionPointer-&gt;ExceptionRecord-&gt;NumberParameters &gt;= 3) ) {
01779 
01780         *ExceptionCode = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>) ExceptionPointer-&gt;ExceptionRecord-&gt;ExceptionInformation[2];
01781     }
01782 
01783     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(*ExceptionCode) );
01784 
01785     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>;
01786 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="copysup.c::CcCopyWrite" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN CcCopyWrite           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Wait</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l01075">1075</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l01065">ACTIVE_PAGE_IS_DIRTY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00816">_SHARED_CACHE_MAP::ActiveVacbSpinLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00583">_VACB::BaseAddress</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00501">BooleanFlagOn</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01747">CcCopyReadExceptionFilter()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l06024">CcMapAndCopy()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00116">CcPinFileData()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l02560">CcSetDirtyPinnedData()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00974">CcUnpinFileData()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01494">FO_WRITE_THROUGH</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00236">FSRTL_FLAG_ADVANCED_HEADER</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01577">GetActiveVacb</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00957">_SHARED_CACHE_MAP::NeedToZeroVacb</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00202">PFSRTL_ADVANCED_FCB_HEADER</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01619">SetActiveVacb</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01798">ZERO_FIRST_PAGE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01800">ZERO_LAST_PAGE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01799">ZERO_MIDDLE_PAGES</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00330">FsRtlCopyWrite()</a>.
<p>
<pre class="fragment"><div>01085                    :
01086 
01087     This routine attempts to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
01088     buffer into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache, and deliver <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct I/O status.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> *not*
01089     safe to call <span class="keyword">this</span> routine from Dpc level.
01090 
01091     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller does not want to block (such as <span class="keywordflow">for</span> disk I/O), then
01092     Wait should be supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  If Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and
01093     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> currently impossible to receive all of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> requested data without
01094     blocking, then <span class="keyword">this</span> routine will <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.  However, <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01095     correct space <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache and no blocking <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01096     required, <span class="keyword">this</span> routine copies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data and returns <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
01097 
01098     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller supplies Wait as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, then <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> guaranteed
01099     to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data and <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct space <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> immediately
01100     accessible in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache, then no blocking will occur.  Otherwise,
01101     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> necessary work will be initiated to read and/or free cache data,
01102     and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller will be blocked until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data can be received.
01103 
01104     <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> system Fsd's should typically supply Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> they are
01105     processing a synchronous I/O requests, or Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> they are
01106     processing an asynchronous request.
01107 
01108     <a class="code" href="../../d1/d9/icmui_8def.html#a0">File</a> system or <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a22">Server</a> Fsp threads should supply Wait = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
01109 
01110 Arguments:
01111 
01112     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
01113                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
01114                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
01115 
01116     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data.
01117 
01118     Length - Length of data in bytes.
01119 
01120     Wait - <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> caller may not block, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> otherwise (see description
01121            above)
01122 
01123     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Pointer to input buffer from which data should be copied.
01124 
01125 Return Value:
01126 
01127     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> - <span class="keywordflow">if</span> Wait was supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data was not copied.
01128 
01129     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> - <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data has been copied.
01130 
01131 Raises:
01132 
01133     STATUS_INSUFFICIENT_RESOURCES - If a <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> allocation <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a> occurs.
01134         This can <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> occur <span class="keywordflow">if</span> Wait was specified as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  (If Wait <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01135         specified as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, and an allocation <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a> occurs, <span class="keyword">this</span>
01136         routine simply returns <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.)
01137 
01138 --*/
01139 
01140 {
01141     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01142     <a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">PFSRTL_ADVANCED_FCB_HEADER</a> FcbHeader;
01143     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
01144     ULONG ActivePage;
01145     PVOID ActiveAddress;
01146     ULONG PageIsDirty;
01147     KIRQL OldIrql;
01148     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01149     PVOID CacheBuffer;
01150     LARGE_INTEGER FOffset;
01151     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
01152     ULONG ZeroFlags;
01153     LARGE_INTEGER Temp;
01154 
01155     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcCopyWrite\n"</span>, 0 );
01156 
01157     <span class="comment">//</span>
01158     <span class="comment">//  If the caller specified Wait == FALSE, but the FileObject is WriteThrough,</span>
01159     <span class="comment">//  then we need to just get out.</span>
01160     <span class="comment">//</span>
01161 
01162     <span class="keywordflow">if</span> ((FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>) &amp;&amp; !Wait) {
01163 
01164         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcCopyWrite-&gt;FALSE (WriteThrough &amp;&amp; !Wait)\n"</span>, 0 );
01165 
01166         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01167     }
01168 
01169     <span class="comment">//</span>
01170     <span class="comment">//  Get pointer to shared cache map</span>
01171     <span class="comment">//</span>
01172 
01173     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
01174     FOffset = *FileOffset;
01175 
01176     <span class="comment">//</span>
01177     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
01178     <span class="comment">//</span>
01179 
01180     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
01181 
01182     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01183 
01184         <span class="comment">//</span>
01185         <span class="comment">//  See if the request starts in the ActivePage.  WriteThrough requests must</span>
01186         <span class="comment">//  go the longer route through CcMapAndCopy, where WriteThrough flushes are</span>
01187         <span class="comment">//  implemented.</span>
01188         <span class="comment">//</span>
01189 
01190         <span class="keywordflow">if</span> (((ULONG)(FOffset.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) == ActivePage) &amp;&amp; (Length != 0) &amp;&amp;
01191             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, FO_WRITE_THROUGH )) {
01192 
01193             ULONG LengthToCopy = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - (FOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
01194 
01195             <span class="comment">//</span>
01196             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
01197             <span class="comment">//</span>
01198 
01199             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
01200                 LengthToCopy = Length;
01201             }
01202 
01203             <span class="comment">//</span>
01204             <span class="comment">//  Copy the data to the user buffer.</span>
01205             <span class="comment">//</span>
01206 
01207             <span class="keywordflow">try</span> {
01208 
01209                 <span class="comment">//</span>
01210                 <span class="comment">//  If we are copying to a page that is locked down, then</span>
01211                 <span class="comment">//  we have to do it under our spinlock, and update the</span>
01212                 <span class="comment">//  NeedToZero field.</span>
01213                 <span class="comment">//</span>
01214 
01215                 OldIrql = 0xFF;
01216 
01217                 CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
01218                                       (FOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
01219 
01220                 <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01221 
01222                     <span class="comment">//</span>
01223                     <span class="comment">//  The FastLock may not write our "flag".</span>
01224                     <span class="comment">//</span>
01225 
01226                     OldIrql = 0;
01227 
01228                     ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, &amp;OldIrql );
01229 
01230                     <span class="comment">//</span>
01231                     <span class="comment">//  Note that the NeedToZero could be cleared, since we</span>
01232                     <span class="comment">//  tested it without the spinlock.</span>
01233                     <span class="comment">//</span>
01234 
01235                     ActiveAddress = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a>;
01236                     <span class="keywordflow">if</span> ((ActiveAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01237                         (ActiveVacb == SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o35">NeedToZeroVacb</a>) &amp;&amp;
01238                         (((PCHAR)CacheBuffer + LengthToCopy) &gt; (PCHAR)ActiveAddress)) {
01239 
01240                         <span class="comment">//</span>
01241                         <span class="comment">//  If we are skipping some bytes in the page, then we need</span>
01242                         <span class="comment">//  to zero them.</span>
01243                         <span class="comment">//</span>
01244 
01245                         <span class="keywordflow">if</span> ((PCHAR)CacheBuffer &gt; (PCHAR)ActiveAddress) {
01246 
01247                             RtlZeroMemory( ActiveAddress, (PCHAR)CacheBuffer - (PCHAR)ActiveAddress );
01248                         }
01249                         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> = (PVOID)((PCHAR)CacheBuffer + LengthToCopy);
01250                     }
01251 
01252                     ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, OldIrql );
01253                 }
01254 
01255                 RtlCopyBytes( CacheBuffer, Buffer, LengthToCopy );
01256 
01257             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
01258                                                  &amp;Status ) ) {
01259 
01260                 <span class="comment">//</span>
01261                 <span class="comment">//  If we failed to overwrite the uninitialized data,</span>
01262                 <span class="comment">//  zero it now (we cannot safely restore NeedToZero).</span>
01263                 <span class="comment">//</span>
01264 
01265                 <span class="keywordflow">if</span> (OldIrql != 0xFF) {
01266                     RtlZeroBytes( CacheBuffer, LengthToCopy );
01267                 }
01268 
01269                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );
01270 
01271                 <span class="comment">//</span>
01272                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
01273                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
01274                 <span class="comment">//  to bring the data in.</span>
01275                 <span class="comment">//</span>
01276 
01277                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
01278                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
01279                 }
01280                 <span class="keywordflow">else</span> {
01281                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
01282                                                            STATUS_UNEXPECTED_IO_ERROR ));
01283                 }
01284             }
01285 
01286             <span class="comment">//</span>
01287             <span class="comment">//  Now adjust FOffset and Length by what we copied.</span>
01288             <span class="comment">//</span>
01289 
01290             <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PVOID)((PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy);
01291             FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)LengthToCopy;
01292             Length -= LengthToCopy;
01293 
01294             <span class="comment">//</span>
01295             <span class="comment">//  If that was all the data, then get outski...</span>
01296             <span class="comment">//</span>
01297 
01298             <span class="keywordflow">if</span> (Length == 0) {
01299 
01300                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );
01301                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01302             }
01303 
01304             <span class="comment">//</span>
01305             <span class="comment">//  Remember that the page is dirty now.</span>
01306             <span class="comment">//</span>
01307 
01308             PageIsDirty |= <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a>;
01309         }
01310 
01311         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
01312 
01313     <span class="comment">//</span>
01314     <span class="comment">//  Else someone else could have the active page, and may want to zero</span>
01315     <span class="comment">//  the range we plan to write!</span>
01316     <span class="comment">//</span>
01317 
01318     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01319 
01320         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, NULL, 0, FALSE );
01321     }
01322 
01323     <span class="comment">//</span>
01324     <span class="comment">//  At this point we can calculate the ZeroFlags.</span>
01325     <span class="comment">//</span>
01326 
01327     <span class="comment">//</span>
01328     <span class="comment">//  We can always zero middle pages, if any.</span>
01329     <span class="comment">//</span>
01330 
01331     ZeroFlags = <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a>;
01332 
01333     <span class="keywordflow">if</span> (((FOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) &amp;&amp;
01334         (Length &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
01335         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
01336     }
01337 
01338     <span class="keywordflow">if</span> (((FOffset.LowPart + Length) &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) {
01339         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01340     }
01341 
01342     Temp = FOffset;
01343     Temp.LowPart &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> -1);
01344 
01345     <span class="comment">//</span>
01346     <span class="comment">//  If there is an advanced header, then we can acquire the FastMutex to</span>
01347     <span class="comment">//  make capturing ValidDataLength atomic.  Currently our other file systems</span>
01348     <span class="comment">//  are either RO or do not really support 64-bits.</span>
01349     <span class="comment">//</span>
01350 
01351     FcbHeader = (<a class="code" href="../../d9/d0/struct__FSRTL__ADVANCED__FCB__HEADER.html">PFSRTL_ADVANCED_FCB_HEADER</a>)FileObject-&gt;FsContext;
01352     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FcbHeader-&gt;Flags, FSRTL_FLAG_ADVANCED_HEADER)) {
01353         ExAcquireFastMutex( FcbHeader-&gt;FastMutex );
01354         Temp.QuadPart = ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.QuadPart -
01355                         Temp.QuadPart;
01356         ExReleaseFastMutex( FcbHeader-&gt;FastMutex );
01357     } <span class="keywordflow">else</span> {
01358         Temp.QuadPart = ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.QuadPart -
01359                         Temp.QuadPart;
01360     }
01361 
01362     <span class="keywordflow">if</span> (Temp.QuadPart &lt;= 0) {
01363         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a> | <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01364     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Temp.HighPart == 0) &amp;&amp; (Temp.LowPart &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
01365         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01366     }
01367 
01368     <span class="comment">//</span>
01369     <span class="comment">//  Call a routine to map and copy the data in Mm and get out.</span>
01370     <span class="comment">//</span>
01371 
01372     <span class="keywordflow">if</span> (Wait) {
01373 
01374         <a class="code" href="../../d5/d5/cc_8h.html#a183">CcMapAndCopy</a>( SharedCacheMap,
01375                       Buffer,
01376                       &amp;FOffset,
01377                       Length,
01378                       ZeroFlags,
01379                       <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>( FileObject-&gt;Flags, FO_WRITE_THROUGH ));
01380 
01381         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01382     }
01383 
01384     <span class="comment">//</span>
01385     <span class="comment">//  The rest of this routine is the Wait == FALSE case.</span>
01386     <span class="comment">//</span>
01387     <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
01388     <span class="comment">//  until the entire transfer is complete.</span>
01389     <span class="comment">//</span>
01390 
01391     <span class="keywordflow">while</span> (Length != 0) {
01392 
01393         ULONG ReceivedLength;
01394         LARGE_INTEGER BeyondLastByte;
01395 
01396         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
01397                             &amp;FOffset,
01398                             Length,
01399                             FALSE,
01400                             TRUE,
01401                             FALSE,
01402                             &amp;Bcb,
01403                             &amp;CacheBuffer,
01404                             &amp;BeyondLastByte )) {
01405 
01406             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcCopyWrite -&gt; FALSE\n"</span>, 0 );
01407 
01408             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01409 
01410         } <span class="keywordflow">else</span> {
01411 
01412             <span class="comment">//</span>
01413             <span class="comment">//  Calculate how much data is described by Bcb starting at our desired</span>
01414             <span class="comment">//  file offset.</span>
01415             <span class="comment">//</span>
01416 
01417             ReceivedLength = (ULONG)(BeyondLastByte.QuadPart - FOffset.QuadPart);
01418 
01419             <span class="comment">//</span>
01420             <span class="comment">//  If we got more than we need, make sure to only transfer</span>
01421             <span class="comment">//  the right amount.</span>
01422             <span class="comment">//</span>
01423 
01424             <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
01425                 ReceivedLength = Length;
01426             }
01427         }
01428 
01429         <span class="comment">//</span>
01430         <span class="comment">//  It is possible for the user buffer to become no longer accessible</span>
01431         <span class="comment">//  since it was last checked by the I/O system.  If we fail to access</span>
01432         <span class="comment">//  the buffer we must raise a status that the caller's exception</span>
01433         <span class="comment">//  filter considers as "expected".  Also we unmap the Bcb here, since</span>
01434         <span class="comment">//  we otherwise would have no other reason to put a try-finally around</span>
01435         <span class="comment">//  this loop.</span>
01436         <span class="comment">//</span>
01437 
01438         <span class="keywordflow">try</span> {
01439 
01440             RtlCopyBytes( CacheBuffer, Buffer, ReceivedLength );
01441 
01442             <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a>( Bcb, NULL );
01443             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, FALSE, UNPIN );
01444         }
01445         except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
01446                                            &amp;Status ) ) {
01447 
01448             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, TRUE, UNPIN );
01449 
01450             <span class="comment">//</span>
01451             <span class="comment">//  If we got an access violation, then the user buffer went</span>
01452             <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
01453             <span class="comment">//  to bring the data in.</span>
01454             <span class="comment">//</span>
01455 
01456             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
01457                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
01458             }
01459             <span class="keywordflow">else</span> {
01460 
01461                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(<a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status, STATUS_UNEXPECTED_IO_ERROR ));
01462             }
01463         }
01464 
01465         <span class="comment">//</span>
01466         <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
01467         <span class="comment">//  to the end of the returned data and adjust the Buffer and Length.</span>
01468         <span class="comment">//</span>
01469 
01470         FOffset = BeyondLastByte;
01471         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + ReceivedLength;
01472         Length -= ReceivedLength;
01473     }
01474 
01475     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcCopyWrite -&gt; TRUE\n"</span>, 0 );
01476 
01477     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01478 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="copysup.c::CcDeferWrite" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcDeferWrite           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d4/d2/cache_8h.html#a56">PCC_POST_DEFERRED_WRITE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>PostRoutine</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Context1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Context2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>BytesToWrite</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Retrying</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l01982">1982</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l00501">BooleanFlagOn</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01400">_DEFERRED_WRITE::BytesToWrite</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00156">CACHE_NTC_DEFERRED_WRITE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00064">CcAcquireMasterLock</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00096">CcDeferredWrites</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00095">CcDeferredWriteSpinLock</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l02099">CcPostDeferredWrites()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00067">CcReleaseMasterLock</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00049">CcScheduleLazyWriteScan()</a>, <a class="el" href="../../d4/d0/threads_8h-source.html#l00266">Context1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01421">_DEFERRED_WRITE::Context1</a>, <a class="el" href="../../d4/d0/threads_8h-source.html#l00266">Context2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01422">_DEFERRED_WRITE::Context2</a>, <a class="el" href="../../d5/d5/cc_8h.html#a113">DEFERRED_WRITE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01406">_DEFERRED_WRITE::DeferredWriteLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01414">_DEFERRED_WRITE::Event</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d5/d8/ex_8h.html#a237">ExInterlockedInsertHeadList()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a238">ExInterlockedInsertTailList()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01394">_DEFERRED_WRITE::FileObject</a>, <a class="el" href="../../d2/d7/fsrtl_8h-source.html#l00211">FSRTL_FLAG_LIMIT_MODIFIED_PAGES</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00129">LazyWriter</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01424">_DEFERRED_WRITE::LimitModifiedPages</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01388">_DEFERRED_WRITE::NodeByteSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01387">_DEFERRED_WRITE::NodeTypeCode</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01420">_DEFERRED_WRITE::PostRoutine</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01464">_LAZY_WRITER::ScanActive</a>.
<p>
<pre class="fragment"><div>01993                    :
01994 
01995     This routine may be called to have <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a> defer posting
01996     of a write until <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Lazy <a class="code" href="../../d4/d0/tex_8c.html#a44">Writer</a> makes some progress writing, or
01997     there are more available pages.  <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system would normally call
01998     <span class="keyword">this</span> routine after receiving <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> from <a class="code" href="../../d5/d7/copysup_8c.html#a6">CcCanIWrite</a>, and preparing
01999     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> request to be posted.
02000 
02001 Arguments:
02002 
02003     FileObject - <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> to be written
02004 
02005     PostRoutine - Address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PostRoutine that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a79">Manager</a> can
02006                   call to post <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> request when conditions are right.  Note
02007                   that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> possible that <span class="keyword">this</span> routine will be called
02008                   immediately from <span class="keyword">this</span> routine.
02009 
02010     <a class="code" href="../../d3/d1/threads_8h.html#a107">Context1</a> - First context parameter <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> post routine.
02011 
02012     <a class="code" href="../../d3/d1/threads_8h.html#a108">Context2</a> - Secont parameter <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> post routine.
02013 
02014     BytesToWrite - Number of bytes that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> request <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> trying to write
02015                    to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache.
02016 
02017     Retrying - Supplied as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> request <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being posted <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02018                first time, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> otherwise.
02019 
02020 Return Value:
02021 
02022     None
02023 
02024 --*/
02025 
02026 {
02027     <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">PDEFERRED_WRITE</a> DeferredWrite;
02028     KIRQL OldIrql;
02029 
02030     <span class="comment">//</span>
02031     <span class="comment">//  Attempt to allocate a deferred write block, and if we do not get</span>
02032     <span class="comment">//  one, just post it immediately rather than gobbling up must succeed</span>
02033     <span class="comment">//  pool.</span>
02034     <span class="comment">//</span>
02035 
02036     DeferredWrite = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a>), 'wDcC' );
02037 
02038     <span class="keywordflow">if</span> (DeferredWrite == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02039         (*PostRoutine)( <a class="code" href="../../d3/d1/threads_8h.html#a107">Context1</a>, <a class="code" href="../../d3/d1/threads_8h.html#a108">Context2</a> );
02040         <span class="keywordflow">return</span>;
02041     }
02042 
02043     <span class="comment">//</span>
02044     <span class="comment">//  Fill in the block.</span>
02045     <span class="comment">//</span>
02046 
02047     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a15">CACHE_NTC_DEFERRED_WRITE</a>;
02048     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a>);
02049     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o2">FileObject</a> = FileObject;
02050     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a> = BytesToWrite;
02051     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o5">Event</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02052     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o6">PostRoutine</a> = PostRoutine;
02053     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o7">Context1</a> = <a class="code" href="../../d3/d1/threads_8h.html#a107">Context1</a>;
02054     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o8">Context2</a> = <a class="code" href="../../d3/d1/threads_8h.html#a108">Context2</a>;
02055     DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o9">LimitModifiedPages</a> = <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(FileObject-&gt;FsContext))-&gt;Flags,
02056                                                       FSRTL_FLAG_LIMIT_MODIFIED_PAGES);
02057 
02058     <span class="comment">//</span>
02059     <span class="comment">//  Now insert at the appropriate end of the list</span>
02060     <span class="comment">//</span>
02061 
02062     <span class="keywordflow">if</span> (Retrying) {
02063         <a class="code" href="../../d5/d8/ex_8h.html#a237">ExInterlockedInsertHeadList</a>( &amp;CcDeferredWrites,
02064                                      &amp;DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a>,
02065                                      &amp;CcDeferredWriteSpinLock );
02066     } <span class="keywordflow">else</span> {
02067         <a class="code" href="../../d5/d8/ex_8h.html#a238">ExInterlockedInsertTailList</a>( &amp;CcDeferredWrites,
02068                                      &amp;DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a>,
02069                                      &amp;CcDeferredWriteSpinLock );
02070     }
02071 
02072     <span class="comment">//</span>
02073     <span class="comment">//  Now since we really didn't synchronize anything but the insertion,</span>
02074     <span class="comment">//  we call the post routine to make sure that in some wierd case we</span>
02075     <span class="comment">//  do not leave anyone hanging with no dirty bytes for the Lazy Writer.</span>
02076     <span class="comment">//</span>
02077 
02078     <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
02079 
02080     <span class="comment">//</span>
02081     <span class="comment">//  Schedule the lazy writer in case the reason we're blocking</span>
02082     <span class="comment">//  is that we're waiting for Mm (or some other external flag)</span>
02083     <span class="comment">//  to lower and let this write happen.  He will be the one to</span>
02084     <span class="comment">//  keep coming back and checking if this can proceed, even if</span>
02085     <span class="comment">//  there are no cache manager pages to write.</span>
02086     <span class="comment">//</span>
02087             
02088     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql);
02089             
02090     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02091         <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02092     }
02093 
02094     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql);
02095 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="copysup.c::CcFastCopyRead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcFastCopyRead           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>PageCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PIO_STATUS_BLOCK&nbsp;</td>
          <td class="mdname" nowrap> <em>IoStatus</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l00588">588</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00583">_VACB::BaseAddress</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00662">_PRIVATE_CACHE_MAP::BeyondLastByte1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00665">_PRIVATE_CACHE_MAP::BeyondLastByte2</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01747">CcCopyReadExceptionFilter()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00189">CcCopyReadWait</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00191">CcCopyReadWaitMiss</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00862">CcFreeVirtualAddress()</a>, <a class="el" href="../../d6/d2/vacbsup_8c-source.html#l00310">CcGetVirtualAddress()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00206">CcMissCounter</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l01253">CcScheduleReadAhead()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00160">CcThrowAway</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00221">COMPUTE_PAGES_SPANNED</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00661">_PRIVATE_CACHE_MAP::FileOffset1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00664">_PRIVATE_CACHE_MAP::FileOffset2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00752">_SHARED_CACHE_MAP::FileSize</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01510">FO_RANDOM_ACCESS</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01577">GetActiveVacb</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00385">HOT_STATISTIC</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d2/d4/mapcache_8c-source.html#l01016">MmCheckCachedPageState()</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01053">MmResetPageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00983">MmSavePageFaultReadAhead</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01018">MmSetPageFaultReadAhead</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00713">_PRIVATE_CACHE_MAP::ReadAheadEnabled</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00677">_PRIVATE_CACHE_MAP::ReadAheadLength</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00117">ROUND_TO_PAGES</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01619">SetActiveVacb</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>, and <a class="el" href="../../d5/d1/cache_8h-source.html#l00031">VACB_OFFSET_SHIFT</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00054">FsRtlCopyRead()</a>.
<p>
<pre class="fragment"><div>00599                    :
00600 
00601     This routine attempts to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cache
00602     into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> output buffer, and deliver <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct I/O status.
00603 
00604     This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a faster version of <a class="code" href="../../d5/d7/copysup_8c.html#a1">CcCopyRead</a> which <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> supports 32-bit <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>
00605     offsets and synchronicity (Wait = TRUE).
00606 
00607 Arguments:
00608 
00609     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
00610                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
00611                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
00612 
00613     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <span class="keywordflow">for</span> desired data.
00614 
00615     Length - Length of desired data in bytes.
00616 
00617     PageCount - Number of pages spanned by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> read.
00618 
00619     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Pointer to output buffer to which data should be copied.
00620 
00621     IoStatus - Pointer to standard I/O status block to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status
00622                <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> transfer.  (STATUS_SUCCESS guaranteed <span class="keywordflow">for</span> cache
00623                hits, otherwise <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual I/O status <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.)
00624 
00625                Note that even <span class="keywordflow">if</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> IoStatus.Information
00626                field will <span class="keywordflow">return</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> count of any bytes successfully
00627                transferred before a blocking condition occured.  The caller
00628                may either choose to ignore <span class="keyword">this</span> information, or resume
00629                <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> copy later accounting <span class="keywordflow">for</span> bytes transferred.
00630 
00631 Return Value:
00632 
00633     None
00634 
00635 --*/
00636 
00637 {
00638     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00639     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
00640     PVOID CacheBuffer;
00641     LARGE_INTEGER FOffset;
00642     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
00643     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
00644     ULONG ActivePage;
00645     ULONG PageIsDirty;
00646     ULONG SavedState;
00647     ULONG PagesToGo;
00648     ULONG MoveLength;
00649     ULONG LengthToGo;
00650     KIRQL OldIrql;
00651     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00652     LARGE_INTEGER OriginalOffset;
00653     ULONG OriginalLength = Length;
00654     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00655     ULONG GotAMiss = 0;
00656 
00657     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcFastCopyRead\n"</span>, 0 );
00658 
00659     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
00660 
00661     <span class="comment">//</span>
00662     <span class="comment">//  Get pointer to shared and private cache maps</span>
00663     <span class="comment">//</span>
00664 
00665     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00666     PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
00667 
00668     <span class="comment">//</span>
00669     <span class="comment">//  Check for read past file size, the caller must filter this case out.</span>
00670     <span class="comment">//</span>
00671 
00672     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (FileOffset + Length) &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.LowPart );
00673 
00674     <span class="comment">//</span>
00675     <span class="comment">//  If read ahead is enabled, then do the read ahead here so it</span>
00676     <span class="comment">//  overlaps with the copy (otherwise we will do it below).</span>
00677     <span class="comment">//  Note that we are assuming that we will not get ahead of our</span>
00678     <span class="comment">//  current transfer - if read ahead is working it should either</span>
00679     <span class="comment">//  already be in memory or else underway.</span>
00680     <span class="comment">//</span>
00681 
00682     OriginalOffset.LowPart = FileOffset;
00683     OriginalOffset.HighPart = 0;
00684 
00685     <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> &amp;&amp; (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] == 0)) {
00686         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, &amp;OriginalOffset, Length );
00687     }
00688 
00689     <span class="comment">//</span>
00690     <span class="comment">//  This is not an exact solution, but when IoPageRead gets a miss,</span>
00691     <span class="comment">//  it cannot tell whether it was CcCopyRead or CcMdlRead, but since</span>
00692     <span class="comment">//  the miss should occur very soon, by loading the pointer here</span>
00693     <span class="comment">//  probably the right counter will get incremented, and in any case,</span>
00694     <span class="comment">//  we hope the errrors average out!</span>
00695     <span class="comment">//</span>
00696 
00697     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a64">CcCopyReadWaitMiss</a>;
00698 
00699     <span class="comment">//</span>
00700     <span class="comment">//  Increment performance counters</span>
00701     <span class="comment">//</span>
00702 
00703     <a class="code" href="../../d0/d9/ntosdef_8h.html#a11">HOT_STATISTIC</a>(CcCopyReadWait) += 1;
00704 
00705     <span class="comment">//</span>
00706     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
00707     <span class="comment">//</span>
00708 
00709     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00710 
00711     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00712 
00713         <span class="keywordflow">if</span> ((FileOffset &gt;&gt; <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a>) == (ActivePage &gt;&gt; (<a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>))) {
00714 
00715             ULONG LengthToCopy = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - (FileOffset &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1));
00716 
00717             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00718                 <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, NULL, 0, FALSE );
00719             }
00720 
00721             <span class="comment">//</span>
00722             <span class="comment">//  Get the starting point in the view.</span>
00723             <span class="comment">//</span>
00724 
00725             CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
00726                                           (FileOffset &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
00727 
00728             <span class="comment">//</span>
00729             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
00730             <span class="comment">//</span>
00731 
00732             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
00733                 LengthToCopy = Length;
00734             }
00735 
00736             <span class="comment">//</span>
00737             <span class="comment">//  Like the logic for the normal case below, we want to spin around</span>
00738             <span class="comment">//  making sure Mm only reads the pages we will need.</span>
00739             <span class="comment">//</span>
00740             
00741             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00742                                                LengthToCopy ) - 1;
00743 
00744             <span class="comment">//</span>
00745             <span class="comment">//  Copy the data to the user buffer.</span>
00746             <span class="comment">//</span>
00747 
00748             <span class="keywordflow">try</span> {
00749 
00750                 <span class="keywordflow">if</span> (PagesToGo != 0) {
00751     
00752                     LengthToGo = LengthToCopy;
00753     
00754                     <span class="keywordflow">while</span> (LengthToGo != 0) {
00755     
00756                         MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00757                                      (PCHAR)CacheBuffer);
00758     
00759                         <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00760                             MoveLength = LengthToGo;
00761                         }
00762     
00763                         <span class="comment">//</span>
00764                         <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00765                         <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00766                         <span class="comment">//  we are after before doing the move.</span>
00767                         <span class="comment">//</span>
00768     
00769                         <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00770                         GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00771     
00772                         RtlCopyBytes( Buffer, CacheBuffer, MoveLength );
00773     
00774                         PagesToGo -= 1;
00775     
00776                         LengthToGo -= MoveLength;
00777                         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00778                         CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00779                     }
00780     
00781                 <span class="comment">//</span>
00782                 <span class="comment">//  Handle the read here that stays on a single page.</span>
00783                 <span class="comment">//</span>
00784     
00785                 } <span class="keywordflow">else</span> {
00786     
00787                     <span class="comment">//</span>
00788                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00789                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00790                     <span class="comment">//  we are after before doing the move.</span>
00791                     <span class="comment">//</span>
00792     
00793                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00794                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00795     
00796                     RtlCopyBytes( Buffer, CacheBuffer, LengthToCopy );
00797     
00798                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy;
00799                 }
00800                 
00801             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00802                                                  &amp;Status ) ) {
00803 
00804                 <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00805 
00806 
00807                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00808 
00809                 <span class="comment">//</span>
00810                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
00811                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00812                 <span class="comment">//  to bring the data in.</span>
00813                 <span class="comment">//</span>
00814 
00815                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00816                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00817                 }
00818                 <span class="keywordflow">else</span> {
00819                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
00820                                                            STATUS_UNEXPECTED_IO_ERROR ));
00821                 }
00822             }
00823 
00824             <span class="comment">//</span>
00825             <span class="comment">//  Now adjust FileOffset and Length by what we copied.</span>
00826             <span class="comment">//</span>
00827 
00828             FileOffset += LengthToCopy;
00829             Length -= LengthToCopy;
00830         }
00831 
00832         <span class="comment">//</span>
00833         <span class="comment">//  If that was all the data, then remember the Vacb</span>
00834         <span class="comment">//</span>
00835 
00836         <span class="keywordflow">if</span> (Length == 0) {
00837 
00838             <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00839 
00840         <span class="comment">//</span>
00841         <span class="comment">//  Otherwise we must free it because we will map other vacbs below.</span>
00842         <span class="comment">//</span>
00843 
00844         } <span class="keywordflow">else</span> {
00845 
00846             <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
00847         }
00848     }
00849 
00850     <span class="comment">//</span>
00851     <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
00852     <span class="comment">//  until the entire transfer is complete.</span>
00853     <span class="comment">//</span>
00854 
00855     FOffset.HighPart = 0;
00856     FOffset.LowPart = FileOffset;
00857 
00858     <span class="keywordflow">while</span> (Length != 0) {
00859 
00860         ULONG ReceivedLength;
00861         ULONG BeyondLastByte;
00862 
00863         <span class="comment">//</span>
00864         <span class="comment">//  Call local routine to Map or Access the file data, then move the data,</span>
00865         <span class="comment">//  then call another local routine to free the data.  If we cannot map</span>
00866         <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00867         <span class="comment">//</span>
00868         <span class="comment">//  Note that this call may result in an exception, however, if it</span>
00869         <span class="comment">//  does no Bcb is returned and this routine has absolutely no</span>
00870         <span class="comment">//  cleanup to perform.  Therefore, we do not have a try-finally</span>
00871         <span class="comment">//  and we allow the possibility that we will simply be unwound</span>
00872         <span class="comment">//  without notice.</span>
00873         <span class="comment">//</span>
00874 
00875         CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00876                                            FOffset,
00877                                            &amp;Vacb,
00878                                            &amp;ReceivedLength );
00879 
00880         BeyondLastByte = FOffset.LowPart + ReceivedLength;
00881 
00882         <span class="comment">//</span>
00883         <span class="comment">//  If we got more than we need, make sure to only transfer</span>
00884         <span class="comment">//  the right amount.</span>
00885         <span class="comment">//</span>
00886 
00887         <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
00888             ReceivedLength = Length;
00889         }
00890 
00891         <span class="comment">//</span>
00892         <span class="comment">//  It is possible for the user buffer to become no longer accessible</span>
00893         <span class="comment">//  since it was last checked by the I/O system.  If we fail to access</span>
00894         <span class="comment">//  the buffer we must raise a status that the caller's exception</span>
00895         <span class="comment">//  filter considers as "expected".  Also we unmap the Bcb here, since</span>
00896         <span class="comment">//  we otherwise would have no other reason to put a try-finally around</span>
00897         <span class="comment">//  this loop.</span>
00898         <span class="comment">//</span>
00899 
00900         <span class="keywordflow">try</span> {
00901 
00902             PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
00903                                                ReceivedLength ) - 1;
00904 
00905             <span class="comment">//</span>
00906             <span class="comment">//  We know exactly how much we want to read here, and we do not</span>
00907             <span class="comment">//  want to read any more in case the caller is doing random access.</span>
00908             <span class="comment">//  Our read ahead logic takes care of detecting sequential reads,</span>
00909             <span class="comment">//  and tends to do large asynchronous read aheads.  So far we have</span>
00910             <span class="comment">//  only mapped the data and we have not forced any in.  What we</span>
00911             <span class="comment">//  do now is get into a loop where we copy a page at a time and</span>
00912             <span class="comment">//  just prior to each move, we tell MM how many additional pages</span>
00913             <span class="comment">//  we would like to have read in, in the event that we take a</span>
00914             <span class="comment">//  fault.  With this strategy, for cache hits we never make a single</span>
00915             <span class="comment">//  expensive call to MM to guarantee that the data is in, yet if we</span>
00916             <span class="comment">//  do take a fault, we are guaranteed to only take one fault because</span>
00917             <span class="comment">//  we will read all of the data in for the rest of the transfer.</span>
00918             <span class="comment">//</span>
00919             <span class="comment">//  We test first for the multiple page case, to keep the small</span>
00920             <span class="comment">//  reads faster.</span>
00921             <span class="comment">//</span>
00922 
00923             <span class="keywordflow">if</span> (PagesToGo != 0) {
00924 
00925                 LengthToGo = ReceivedLength;
00926 
00927                 <span class="keywordflow">while</span> (LengthToGo != 0) {
00928 
00929                     MoveLength = (ULONG)((PCHAR)(<a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(((PCHAR)CacheBuffer + 1))) -
00930                                  (PCHAR)CacheBuffer);
00931 
00932                     <span class="keywordflow">if</span> (MoveLength &gt; LengthToGo) {
00933                         MoveLength = LengthToGo;
00934                     }
00935 
00936                     <span class="comment">//</span>
00937                     <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00938                     <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00939                     <span class="comment">//  we are after before doing the move.</span>
00940                     <span class="comment">//</span>
00941 
00942                     <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PagesToGo );
00943                     GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00944 
00945                     RtlCopyBytes( Buffer, CacheBuffer, MoveLength );
00946 
00947                     PagesToGo -= 1;
00948 
00949                     LengthToGo -= MoveLength;
00950                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + MoveLength;
00951                     CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
00952                 }
00953 
00954             <span class="comment">//</span>
00955             <span class="comment">//  Handle the read here that stays on a single page.</span>
00956             <span class="comment">//</span>
00957 
00958             } <span class="keywordflow">else</span> {
00959 
00960                 <span class="comment">//</span>
00961                 <span class="comment">//  Here's hoping that it is cheaper to call Mm to see if</span>
00962                 <span class="comment">//  the page is valid.  If not let Mm know how many pages</span>
00963                 <span class="comment">//  we are after before doing the move.</span>
00964                 <span class="comment">//</span>
00965 
00966                 <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, 0 );
00967                 GotAMiss |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>( CacheBuffer, FALSE );
00968 
00969                 RtlCopyBytes( Buffer, CacheBuffer, ReceivedLength );
00970 
00971                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + ReceivedLength;
00972             }
00973         }
00974         except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
00975                                            &amp;Status ) ) {
00976 
00977             <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00978 
00979             <span class="comment">//</span>
00980             <span class="comment">//  If we get an exception, then we have to renable page fault</span>
00981             <span class="comment">//  clustering and unmap on the way out.</span>
00982             <span class="comment">//</span>
00983 
00984             <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00985 
00986 
00987             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00988 
00989             <span class="comment">//</span>
00990             <span class="comment">//  If we got an access violation, then the user buffer went</span>
00991             <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
00992             <span class="comment">//  to bring the data in.</span>
00993             <span class="comment">//</span>
00994 
00995             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
00996                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
00997             }
00998             <span class="keywordflow">else</span> {
00999                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
01000                                                        STATUS_UNEXPECTED_IO_ERROR ));
01001             }
01002         }
01003 
01004         <span class="comment">//</span>
01005         <span class="comment">//  Update number of bytes transferred.</span>
01006         <span class="comment">//</span>
01007 
01008         Length -= ReceivedLength;
01009 
01010         <span class="comment">//</span>
01011         <span class="comment">//  Unmap the data now, and calculate length left to transfer.</span>
01012         <span class="comment">//</span>
01013 
01014         <span class="keywordflow">if</span> (Length != 0) {
01015 
01016             <span class="comment">//</span>
01017             <span class="comment">//  If there is more to go, just free this vacb.</span>
01018             <span class="comment">//</span>
01019 
01020             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
01021 
01022         } <span class="keywordflow">else</span> {
01023 
01024             <span class="comment">//</span>
01025             <span class="comment">//  Otherwise save it for the next time through.</span>
01026             <span class="comment">//</span>
01027 
01028             <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, Vacb, (FOffset.LowPart &gt;&gt; PAGE_SHIFT), 0 );
01029             <span class="keywordflow">break</span>;
01030         }
01031 
01032         <span class="comment">//</span>
01033         <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
01034         <span class="comment">//  to the end of the returned data.</span>
01035         <span class="comment">//</span>
01036 
01037         FOffset.LowPart = BeyondLastByte;
01038     }
01039 
01040     <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
01041 
01042     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
01043 
01044     <span class="comment">//</span>
01045     <span class="comment">//  Now enable read ahead if it looks like we got any misses, and do</span>
01046     <span class="comment">//  the first one.</span>
01047     <span class="comment">//</span>
01048 
01049     <span class="keywordflow">if</span> (GotAMiss &amp;&amp;
01050         !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, FO_RANDOM_ACCESS ) &amp;&amp;
01051         !PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a>) {
01052 
01053         PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01054         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, &amp;OriginalOffset, OriginalLength );
01055     }
01056 
01057     <span class="comment">//</span>
01058     <span class="comment">//  Now that we have described our desired read ahead, let's</span>
01059     <span class="comment">//  shift the read history down.</span>
01060     <span class="comment">//</span>
01061 
01062     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">FileOffset1</a>.LowPart = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.LowPart;
01063     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a>.LowPart = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.LowPart;
01064     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.LowPart = OriginalOffset.LowPart;
01065     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.LowPart = OriginalOffset.LowPart + OriginalLength;
01066 
01067     IoStatus-&gt;Status = STATUS_SUCCESS;
01068     IoStatus-&gt;Information = OriginalLength;
01069 
01070     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcFastCopyRead -&gt; VOID\n"</span>, 0 );
01071 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="copysup.c::CcFastCopyWrite" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcFastCopyWrite           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FileObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>FileOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l01482">1482</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l01065">ACTIVE_PAGE_IS_DIRTY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00816">_SHARED_CACHE_MAP::ActiveVacbSpinLock</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00583">_VACB::BaseAddress</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00501">BooleanFlagOn</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01747">CcCopyReadExceptionFilter()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05885">CcFreeActiveVacb()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l06024">CcMapAndCopy()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d1/d3/ex_2alpha_2raisests_8c-source.html#l00157">ExRaiseStatus()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01494">FO_WRITE_THROUGH</a>, <a class="el" href="../../d8/d2/fsrtl_2filter_8c-source.html#l00049">FsRtlNormalizeNtstatus()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01577">GetActiveVacb</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l00033">me</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00809">_SHARED_CACHE_MAP::NeedToZero</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00957">_SHARED_CACHE_MAP::NeedToZeroVacb</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01619">SetActiveVacb</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d5/d1/cache_8h-source.html#l00030">VACB_MAPPING_GRANULARITY</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01798">ZERO_FIRST_PAGE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01800">ZERO_LAST_PAGE</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01799">ZERO_MIDDLE_PAGES</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/fastio_8c-source.html#l00330">FsRtlCopyWrite()</a>.
<p>
<pre class="fragment"><div>01491                    :
01492 
01493     This routine attempts to copy <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> data from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
01494     buffer into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Cache, and deliver <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> correct I/O status.
01495 
01496     This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a faster version of <a class="code" href="../../d5/d7/copysup_8c.html#a3">CcCopyWrite</a> which <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> supports 32-bit <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>
01497     offsets and synchronicity (Wait = TRUE) and no Write Through.
01498 
01499 Arguments:
01500 
01501     FileObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> which was
01502                  opened with NO_INTERMEDIATE_BUFFERING clear, i.e., <span class="keywordflow">for</span>
01503                  which <a class="code" href="../../d5/d8/fssup_8c.html#a9">CcInitializeCacheMap</a> was called by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> system.
01504 
01505     FileOffset - Byte offset in <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> data.
01506 
01507     Length - Length of data in bytes.
01508 
01509     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Pointer to input buffer from which data should be copied.
01510 
01511 Return Value:
01512 
01513     None
01514 
01515 Raises:
01516 
01517     STATUS_INSUFFICIENT_RESOURCES - If a <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> allocation <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a> occurs.
01518         This can <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> occur <span class="keywordflow">if</span> Wait was specified as <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.  (If Wait <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01519         specified as <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, and an allocation <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a> occurs, <span class="keyword">this</span>
01520         routine simply returns <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>.)
01521 
01522 --*/
01523 
01524 {
01525     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01526     PVOID CacheBuffer;
01527     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb;
01528     ULONG ActivePage;
01529     PVOID ActiveAddress;
01530     ULONG PageIsDirty;
01531     KIRQL OldIrql;
01532     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01533     ULONG ZeroFlags;
01534     ULONG ValidDataLength;
01535     LARGE_INTEGER FOffset;
01536 
01537     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, me, <span class="stringliteral">"CcFastCopyWrite\n"</span>, 0 );
01538 
01539     <span class="comment">//</span>
01540     <span class="comment">//  Get pointer to shared cache map and a copy of valid data length</span>
01541     <span class="comment">//</span>
01542 
01543     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
01544 
01545     <span class="comment">//</span>
01546     <span class="comment">//  See if we have an active Vacb, that we can just copy to.</span>
01547     <span class="comment">//</span>
01548 
01549     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
01550 
01551     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01552 
01553         <span class="comment">//</span>
01554         <span class="comment">//  See if the request starts in the ActivePage.  WriteThrough requests must</span>
01555         <span class="comment">//  go the longer route through CcMapAndCopy, where WriteThrough flushes are</span>
01556         <span class="comment">//  implemented.</span>
01557         <span class="comment">//</span>
01558 
01559         <span class="keywordflow">if</span> (((FileOffset &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) == ActivePage) &amp;&amp; (Length != 0) &amp;&amp;
01560             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, FO_WRITE_THROUGH )) {
01561 
01562             ULONG LengthToCopy = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - (FileOffset &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
01563 
01564             <span class="comment">//</span>
01565             <span class="comment">//  Reduce LengthToCopy if it is greater than our caller's length.</span>
01566             <span class="comment">//</span>
01567 
01568             <span class="keywordflow">if</span> (LengthToCopy &gt; Length) {
01569                 LengthToCopy = Length;
01570             }
01571 
01572             <span class="comment">//</span>
01573             <span class="comment">//  Copy the data to the user buffer.</span>
01574             <span class="comment">//</span>
01575 
01576             <span class="keywordflow">try</span> {
01577 
01578                 <span class="comment">//</span>
01579                 <span class="comment">//  If we are copying to a page that is locked down, then</span>
01580                 <span class="comment">//  we have to do it under our spinlock, and update the</span>
01581                 <span class="comment">//  NeedToZero field.</span>
01582                 <span class="comment">//</span>
01583 
01584                 OldIrql = 0xFF;
01585 
01586                 CacheBuffer = (PVOID)((PCHAR)ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> +
01587                                       (FileOffset &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
01588 
01589                 <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01590 
01591                     <span class="comment">//</span>
01592                     <span class="comment">//  The FastLock may not write our "flag".</span>
01593                     <span class="comment">//</span>
01594 
01595                     OldIrql = 0;
01596 
01597                     ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, &amp;OldIrql );
01598 
01599                     <span class="comment">//</span>
01600                     <span class="comment">//  Note that the NeedToZero could be cleared, since we</span>
01601                     <span class="comment">//  tested it without the spinlock.</span>
01602                     <span class="comment">//</span>
01603 
01604                     ActiveAddress = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a>;
01605                     <span class="keywordflow">if</span> ((ActiveAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01606                         (ActiveVacb == SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o35">NeedToZeroVacb</a>) &amp;&amp;
01607                         (((PCHAR)CacheBuffer + LengthToCopy) &gt; (PCHAR)ActiveAddress)) {
01608 
01609                         <span class="comment">//</span>
01610                         <span class="comment">//  If we are skipping some bytes in the page, then we need</span>
01611                         <span class="comment">//  to zero them.</span>
01612                         <span class="comment">//</span>
01613 
01614                         <span class="keywordflow">if</span> ((PCHAR)CacheBuffer &gt; (PCHAR)ActiveAddress) {
01615 
01616                             RtlZeroMemory( ActiveAddress, (PCHAR)CacheBuffer - (PCHAR)ActiveAddress );
01617                         }
01618                         SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> = (PVOID)((PCHAR)CacheBuffer + LengthToCopy);
01619                     }
01620 
01621                     ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o15">ActiveVacbSpinLock</a>, OldIrql );
01622                 }
01623 
01624                 RtlCopyBytes( CacheBuffer, Buffer, LengthToCopy );
01625 
01626             } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
01627                                                  &amp;Status ) ) {
01628 
01629                 <span class="comment">//</span>
01630                 <span class="comment">//  If we failed to overwrite the uninitialized data,</span>
01631                 <span class="comment">//  zero it now (we cannot safely restore NeedToZero).</span>
01632                 <span class="comment">//</span>
01633 
01634                 <span class="keywordflow">if</span> (OldIrql != 0xFF) {
01635                     RtlZeroBytes( CacheBuffer, LengthToCopy );
01636                 }
01637 
01638                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );
01639 
01640                 <span class="comment">//</span>
01641                 <span class="comment">//  If we got an access violation, then the user buffer went</span>
01642                 <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
01643                 <span class="comment">//  to bring the data in.</span>
01644                 <span class="comment">//</span>
01645 
01646                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
01647                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
01648                 }
01649                 <span class="keywordflow">else</span> {
01650                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( Status,
01651                                                            STATUS_UNEXPECTED_IO_ERROR ));
01652                 }
01653             }
01654 
01655             <span class="comment">//</span>
01656             <span class="comment">//  Now adjust FileOffset and Length by what we copied.</span>
01657             <span class="comment">//</span>
01658 
01659             <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (PVOID)((PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + LengthToCopy);
01660             FileOffset += LengthToCopy;
01661             Length -= LengthToCopy;
01662 
01663             <span class="comment">//</span>
01664             <span class="comment">//  If that was all the data, then get outski...</span>
01665             <span class="comment">//</span>
01666 
01667             <span class="keywordflow">if</span> (Length == 0) {
01668 
01669                 <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );
01670                 <span class="keywordflow">return</span>;
01671             }
01672 
01673             <span class="comment">//</span>
01674             <span class="comment">//  Remember that the page is dirty now.</span>
01675             <span class="comment">//</span>
01676 
01677             PageIsDirty |= <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a>;
01678         }
01679 
01680         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
01681 
01682     <span class="comment">//</span>
01683     <span class="comment">//  Else someone else could have the active page, and may want to zero</span>
01684     <span class="comment">//  the range we plan to write!</span>
01685     <span class="comment">//</span>
01686 
01687     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01688 
01689         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, NULL, 0, FALSE );
01690     }
01691 
01692     <span class="comment">//</span>
01693     <span class="comment">//  Set up for call to CcMapAndCopy</span>
01694     <span class="comment">//</span>
01695 
01696     FOffset.LowPart = FileOffset;
01697     FOffset.HighPart = 0;
01698 
01699     ValidDataLength = ((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.LowPart;
01700 
01701     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((ValidDataLength == MAXULONG) ||
01702            (((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)FileObject-&gt;FsContext)-&gt;ValidDataLength.HighPart == 0));
01703 
01704     <span class="comment">//</span>
01705     <span class="comment">//  At this point we can calculate the ReadOnly flag for</span>
01706     <span class="comment">//  the purposes of whether to use the Bcb resource, and</span>
01707     <span class="comment">//  we can calculate the ZeroFlags.</span>
01708     <span class="comment">//</span>
01709 
01710     <span class="comment">//</span>
01711     <span class="comment">//  We can always zero middle pages, if any.</span>
01712     <span class="comment">//</span>
01713 
01714     ZeroFlags = <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a>;
01715 
01716     <span class="keywordflow">if</span> (((FileOffset &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) &amp;&amp;
01717         (Length &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
01718         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
01719     }
01720 
01721     <span class="keywordflow">if</span> (((FileOffset + Length) &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) {
01722         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01723     }
01724 
01725     <span class="keywordflow">if</span> ((FileOffset &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) &gt;= ValidDataLength) {
01726         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a> | <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01727     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((FileOffset &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &gt;= ValidDataLength) {
01728         ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
01729     }
01730 
01731     <span class="comment">//</span>
01732     <span class="comment">//  Call a routine to map and copy the data in Mm and get out.</span>
01733     <span class="comment">//</span>
01734 
01735     <a class="code" href="../../d5/d5/cc_8h.html#a183">CcMapAndCopy</a>( SharedCacheMap,
01736                   Buffer,
01737                   &amp;FOffset,
01738                   Length,
01739                   ZeroFlags,
01740                   <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>( FileObject-&gt;Flags, FO_WRITE_THROUGH ));
01741 
01742     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, me, <span class="stringliteral">"CcFastCopyWrite -&gt; VOID\n"</span>, 0 );
01743 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="copysup.c::CcPostDeferredWrites" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID CcPostDeferredWrites           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d6/copysup_8c-source.html#l02099">2099</a> of file <a class="el" href="../../d6/d6/copysup_8c-source.html">copysup.c</a>.
<p>
References <a class="el" href="../../d6/d4/cc_8h-source.html#l01400">_DEFERRED_WRITE::BytesToWrite</a>, <a class="el" href="../../d4/d2/cache_8h.html#a72">CcCanIWrite()</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00096">CcDeferredWrites</a>, <a class="el" href="../../d6/d1/cachedat_8c-source.html#l00095">CcDeferredWriteSpinLock</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01421">_DEFERRED_WRITE::Context1</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01422">_DEFERRED_WRITE::Context2</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01406">_DEFERRED_WRITE::DeferredWriteLinks</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01414">_DEFERRED_WRITE::Event</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01394">_DEFERRED_WRITE::FileObject</a>, <a class="el" href="../../d3/d7/eventobj_8c-source.html#l00343">KeSetEvent()</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l01424">_DEFERRED_WRITE::LimitModifiedPages</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d6/d4/cc_8h-source.html#l01420">_DEFERRED_WRITE::PostRoutine</a>.
<p>
Referenced by <a class="el" href="../../d6/d6/copysup_8c-source.html#l01790">CcCanIWrite()</a>, <a class="el" href="../../d6/d6/copysup_8c-source.html#l01982">CcDeferWrite()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l04411">CcFlushCache()</a>, <a class="el" href="../../d6/d0/lazyrite_8c-source.html#l00221">CcLazyWriteScan()</a>, <a class="el" href="../../d7/d1/cachesub_8c-source.html#l05143">CcUnpinRepinnedBcb()</a>, and <a class="el" href="../../d7/d1/cachesub_8c-source.html#l03880">CcWriteBehind()</a>.
<p>
<pre class="fragment"><div>02104                    :
02105 
02106     This routine may be called to see <span class="keywordflow">if</span> any deferred writes should be posted
02107     now, and to post them.  It should be called any time <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02108     queue may have changed, such as when a <span class="keyword">new</span> entry has been added, or <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02109     Lazy <a class="code" href="../../d4/d0/tex_8c.html#a44">Writer</a> has finished writing <a class="code" href="../../d6/d0/wsprintf_8c.html#a0">out</a> buffers and set them clean.
02110 
02111 Arguments:
02112 
02113     None
02114 
02115 Return Value:
02116 
02117     None
02118 
02119 --*/
02120 
02121 {
02122     <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">PDEFERRED_WRITE</a> DeferredWrite;
02123     ULONG TotalBytesLetLoose = 0;
02124     KIRQL OldIrql;
02125 
02126     <span class="keywordflow">do</span> {
02127 
02128         <span class="comment">//</span>
02129         <span class="comment">//  Initially clear the deferred write structure pointer</span>
02130         <span class="comment">//  and syncrhronize.</span>
02131         <span class="comment">//</span>
02132 
02133         DeferredWrite = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02134 
02135         ExAcquireSpinLock( &amp;CcDeferredWriteSpinLock, &amp;OldIrql );
02136 
02137         <span class="comment">//</span>
02138         <span class="comment">//  If the list is empty we are done.</span>
02139         <span class="comment">//</span>
02140 
02141         <span class="keywordflow">if</span> (!IsListEmpty(&amp;CcDeferredWrites)) {
02142 
02143             PLIST_ENTRY Entry;
02144 
02145             Entry = <a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>.Flink;
02146 
02147             <span class="keywordflow">while</span> (Entry != &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>) {
02148 
02149                 DeferredWrite = CONTAINING_RECORD( Entry,
02150                                                    <a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html">DEFERRED_WRITE</a>,
02151                                                    DeferredWriteLinks );
02152 
02153                 <span class="comment">//</span>
02154                 <span class="comment">//  Check for a paranoid case here that TotalBytesLetLoose</span>
02155                 <span class="comment">//  wraps.  We stop processing the list at this time.</span>
02156                 <span class="comment">//</span>
02157 
02158                 TotalBytesLetLoose += DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a>;
02159 
02160                 <span class="keywordflow">if</span> (TotalBytesLetLoose &lt; DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a>) {
02161 
02162                     DeferredWrite = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02163                     <span class="keywordflow">break</span>;
02164                 }
02165 
02166                 <span class="comment">//</span>
02167                 <span class="comment">//  If it is now ok to post this write, remove him from</span>
02168                 <span class="comment">//  the list.</span>
02169                 <span class="comment">//</span>
02170 
02171                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d2/cache_8h.html#a72">CcCanIWrite</a>( DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o2">FileObject</a>,
02172                                  TotalBytesLetLoose,
02173                                  FALSE,
02174                                  MAXUCHAR - 1 )) {
02175 
02176                     RemoveEntryList( &amp;DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o4">DeferredWriteLinks</a> );
02177                     <span class="keywordflow">break</span>;
02178 
02179                 <span class="comment">//</span>
02180                 <span class="comment">//  Otherwise, it is time to stop processing the list, so</span>
02181                 <span class="comment">//  we clear the pointer again unless we throttled this item</span>
02182                 <span class="comment">//  because of a private dirty page limit.</span>
02183                 <span class="comment">//</span>
02184 
02185                 } <span class="keywordflow">else</span> {
02186 
02187                     <span class="comment">//</span>
02188                     <span class="comment">//  If this was a private throttle, skip over it and</span>
02189                     <span class="comment">//  remove its byte count from the running total.</span>
02190                     <span class="comment">//</span>
02191 
02192                     <span class="keywordflow">if</span> (DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o9">LimitModifiedPages</a>) {
02193 
02194                         Entry = Entry-&gt;Flink;
02195                         TotalBytesLetLoose -= DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o3">BytesToWrite</a>;
02196                         DeferredWrite = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02197                         <span class="keywordflow">continue</span>;
02198 
02199                     } <span class="keywordflow">else</span> {
02200 
02201                         DeferredWrite = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02202 
02203                         <span class="keywordflow">break</span>;
02204                     }
02205                 }
02206             }
02207         }
02208 
02209         ExReleaseSpinLock( &amp;CcDeferredWriteSpinLock, OldIrql );
02210 
02211         <span class="comment">//</span>
02212         <span class="comment">//  If we got something, set the event or call the post routine</span>
02213         <span class="comment">//  and deallocate the structure.</span>
02214         <span class="comment">//</span>
02215 
02216         <span class="keywordflow">if</span> (DeferredWrite != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02217 
02218             <span class="keywordflow">if</span> (DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o5">Event</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02219 
02220                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o5">Event</a>, 0, FALSE );
02221 
02222             } <span class="keywordflow">else</span> {
02223 
02224                 (*DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o6">PostRoutine</a>)( DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o7">Context1</a>,
02225                                                DeferredWrite-&gt;<a class="code" href="../../d5/d2/struct__DEFERRED__WRITE.html#o8">Context2</a> );
02226                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( DeferredWrite );
02227             }
02228         }
02229 
02230     <span class="comment">//</span>
02231     <span class="comment">//  Loop until we find no more work to do.</span>
02232     <span class="comment">//</span>
02233 
02234     } <span class="keywordflow">while</span> (DeferredWrite != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02235 }
}
</div></pre>    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:43:17 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
