<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: name.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>name.c</h1><a href="../../d4/d5/name_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    Name.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    The unicode name support package is for manipulating unicode strings</span>
00012 <span class="comment">    The routines allow the caller to dissect and compare strings.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    This package uses the same FSRTL_COMPARISON_RESULT typedef used by name.c</span>
00015 <span class="comment"></span>
00016 <span class="comment">    The following routines are provided by this package:</span>
00017 <span class="comment"></span>
00018 <span class="comment">      o  FsRtlDissectName - This routine takes a path name string and breaks</span>
00019 <span class="comment">         into two parts.  The first name in the string and the remainder.</span>
00020 <span class="comment">         It also checks that the first name is valid for an NT file.</span>
00021 <span class="comment"></span>
00022 <span class="comment">      o  FsRtlColateNames - This routine is used to colate directories</span>
00023 <span class="comment">         according to lexical ordering.  Lexical ordering is strict unicode</span>
00024 <span class="comment">         numerical oerdering.</span>
00025 <span class="comment"></span>
00026 <span class="comment">      o  FsRtlDoesNameContainsWildCards - This routine tells the caller if</span>
00027 <span class="comment">         a string contains any wildcard characters.</span>
00028 <span class="comment"></span>
00029 <span class="comment">      o  FsRtlIsNameInExpression - This routine is used to compare a string</span>
00030 <span class="comment">         against a template (possibly containing wildcards) to sees if the</span>
00031 <span class="comment">         string is in the language denoted by the template.</span>
00032 <span class="comment"></span>
00033 <span class="comment">Author:</span>
00034 <span class="comment"></span>
00035 <span class="comment">    Gary Kimura     [GaryKi]    5-Feb-1990</span>
00036 <span class="comment"></span>
00037 <span class="comment">Revision History:</span>
00038 <span class="comment"></span>
00039 <span class="comment">--*/</span>
00040 
00041 <span class="preprocessor">#include "FsRtlP.h"</span>
00042 
00043 <span class="comment">//</span>
00044 <span class="comment">//  Trace level for the module</span>
00045 <span class="comment">//</span>
00046 
<a name="l00047"></a><a class="code" href="../../d4/d5/name_8c.html#a0">00047</a> <span class="preprocessor">#define Dbg                              (0x10000000)</span>
00048 <span class="preprocessor"></span>
00049 <span class="comment">//</span>
00050 <span class="comment">//  Some special debugging stuff</span>
00051 <span class="comment">//</span>
00052 
00053 <span class="preprocessor">#if DBG</span>
00054 <span class="preprocessor"></span>
00055 <span class="keyword">extern</span> ULONG DaveDebug;
00056 <span class="preprocessor">#define DavePrint if (DaveDebug) DbgPrint</span>
00057 <span class="preprocessor"></span>
00058 <span class="preprocessor">#else</span>
00059 <span class="preprocessor"></span>
<a name="l00060"></a><a class="code" href="../../d4/d5/name_8c.html#a1">00060</a> <span class="preprocessor">#define DavePrint NOTHING</span>
00061 <span class="preprocessor"></span>
00062 <span class="preprocessor">#endif</span>
00063 <span class="preprocessor"></span>
00064 <span class="comment">//</span>
00065 <span class="comment">//  Define a tag for general pool allocations from this module</span>
00066 <span class="comment">//</span>
00067 
00068 <span class="preprocessor">#undef MODULE_POOL_TAG</span>
<a name="l00069"></a><a class="code" href="../../d4/d5/name_8c.html#a2">00069</a> <span class="preprocessor"></span><span class="preprocessor">#define MODULE_POOL_TAG                  ('nrSF')</span>
00070 <span class="preprocessor"></span>
00071 <span class="comment">//</span>
00072 <span class="comment">//  Local support routine prototypes</span>
00073 <span class="comment">//</span>
00074 
00075 BOOLEAN
00076 <a class="code" href="../../d4/d5/name_8c.html#a4">FsRtlIsNameInExpressionPrivate</a> (
00077     IN PUNICODE_STRING Expression,
00078     IN PUNICODE_STRING Name,
00079     IN BOOLEAN IgnoreCase,
00080     IN PWCH UpcaseTable
00081     );
00082 
00083 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlAreNamesEqual)</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlDissectName)</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlDoesNameContainWildCards)</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlIsNameInExpression)</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, FsRtlIsNameInExpressionPrivate)</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00090 <span class="preprocessor"></span>
00091 
00092 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00093"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a176">00093</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a176">FsRtlDissectName</a> (
00094     IN UNICODE_STRING Path,
00095     OUT PUNICODE_STRING FirstName,
00096     OUT PUNICODE_STRING RemainingName
00097     )
00098 
00099 <span class="comment">/*++</span>
00100 <span class="comment"></span>
00101 <span class="comment">Routine Description:</span>
00102 <span class="comment"></span>
00103 <span class="comment">    This routine cracks a path.  It picks off the first element in the</span>
00104 <span class="comment">    given path name and provides both it and the remaining part.  A path</span>
00105 <span class="comment">    is a set of file names separated by backslashes.  If a name begins</span>
00106 <span class="comment">    with a backslash, the FirstName is the string immediately following</span>
00107 <span class="comment">    the backslash.  Here are some examples:</span>
00108 <span class="comment"></span>
00109 <span class="comment">        Path           FirstName    RemainingName</span>
00110 <span class="comment">        ----           ---------    -------------</span>
00111 <span class="comment">        empty          empty        empty</span>
00112 <span class="comment"></span>
00113 <span class="comment">        \              empty        empty</span>
00114 <span class="comment"></span>
00115 <span class="comment">        A              A            empty</span>
00116 <span class="comment"></span>
00117 <span class="comment">        \A             A            empty</span>
00118 <span class="comment"></span>
00119 <span class="comment">        A\B\C\D\E      A            B\C\D\E</span>
00120 <span class="comment"></span>
00121 <span class="comment">        *A?            *A?          empty</span>
00122 <span class="comment"></span>
00123 <span class="comment"></span>
00124 <span class="comment">    Note that both output strings use the same string buffer memory of the</span>
00125 <span class="comment">    input string, and are not necessarily null terminated.</span>
00126 <span class="comment"></span>
00127 <span class="comment">    Also, this routine makes no judgement as to the legality of each</span>
00128 <span class="comment">    file name componant.  This must be done separatly when each file name</span>
00129 <span class="comment">    is extracted.</span>
00130 <span class="comment"></span>
00131 <span class="comment">Arguments:</span>
00132 <span class="comment"></span>
00133 <span class="comment">    Path - The full path name to crack.</span>
00134 <span class="comment"></span>
00135 <span class="comment">    FirstName - The first name in the path.  Don't allocate a buffer for</span>
00136 <span class="comment">        this string.</span>
00137 <span class="comment"></span>
00138 <span class="comment">    RemainingName - The rest of the path.  Don't allocate a buffer for this</span>
00139 <span class="comment">        string.</span>
00140 <span class="comment"></span>
00141 <span class="comment">Return Value:</span>
00142 <span class="comment"></span>
00143 <span class="comment">    None.</span>
00144 <span class="comment"></span>
00145 <span class="comment">--*/</span>
00146 
00147 {
00148     ULONG i = 0;
00149     ULONG PathLength;
00150     ULONG FirstNameStart;
00151 
00152     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00153 
00154     <span class="comment">//</span>
00155     <span class="comment">//  Make both output strings empty for now</span>
00156     <span class="comment">//</span>
00157 
00158     FirstName-&gt;Length = 0;
00159     FirstName-&gt;MaximumLength = 0;
00160     FirstName-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00161 
00162     RemainingName-&gt;Length = 0;
00163     RemainingName-&gt;MaximumLength = 0;
00164     RemainingName-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00165 
00166     PathLength = Path.Length / <span class="keyword">sizeof</span>(WCHAR);
00167 
00168     <span class="comment">//</span>
00169     <span class="comment">//  Check for an empty input string</span>
00170     <span class="comment">//</span>
00171 
00172     <span class="keywordflow">if</span> (PathLength == 0) {
00173 
00174         <span class="keywordflow">return</span>;
00175     }
00176 
00177     <span class="comment">//</span>
00178     <span class="comment">//  Skip over a starting backslash, and make sure there is more.</span>
00179     <span class="comment">//</span>
00180 
00181     <span class="keywordflow">if</span> ( Path.Buffer[0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ) {
00182 
00183         i = 1;
00184     }
00185 
00186     <span class="comment">//</span>
00187     <span class="comment">//  Now run down the input string until we hit a backslash or the end</span>
00188     <span class="comment">//  of the string, remembering where we started;</span>
00189     <span class="comment">//</span>
00190 
00191     <span class="keywordflow">for</span> ( FirstNameStart = i;
00192           (i &lt; PathLength) &amp;&amp; (Path.Buffer[i] != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>);
00193           i += 1 ) {
00194 
00195         NOTHING;
00196     }
00197 
00198     <span class="comment">//</span>
00199     <span class="comment">//  At this point all characters up to (but not including) i are</span>
00200     <span class="comment">//  in the first part.   So setup the first name</span>
00201     <span class="comment">//</span>
00202 
00203     FirstName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((i - FirstNameStart) * <span class="keyword">sizeof</span>(WCHAR));
00204     FirstName-&gt;MaximumLength = FirstName-&gt;Length;
00205     FirstName-&gt;Buffer = &amp;Path.Buffer[FirstNameStart];
00206 
00207     <span class="comment">//</span>
00208     <span class="comment">//  Now the remaining part needs a string only if the first part didn't</span>
00209     <span class="comment">//  exhaust the entire input string.  We know that if anything is left</span>
00210     <span class="comment">//  that is must start with a backslash.  Note that if there is only</span>
00211     <span class="comment">//  a trailing backslash, the length will get correctly set to zero.</span>
00212     <span class="comment">//</span>
00213 
00214     <span class="keywordflow">if</span> (i &lt; PathLength) {
00215 
00216         RemainingName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((PathLength - (i + 1)) * <span class="keyword">sizeof</span>(WCHAR));
00217         RemainingName-&gt;MaximumLength = RemainingName-&gt;Length;
00218         RemainingName-&gt;Buffer = &amp;Path.Buffer[i + 1];
00219     }
00220 
00221     <span class="comment">//</span>
00222     <span class="comment">//  And return to our caller</span>
00223     <span class="comment">//</span>
00224 
00225     <span class="keywordflow">return</span>;
00226 }
00227 
00228 BOOLEAN
<a name="l00229"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a177">00229</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a177">FsRtlDoesNameContainWildCards</a> (
00230     IN PUNICODE_STRING Name
00231     )
00232 
00233 <span class="comment">/*++</span>
00234 <span class="comment"></span>
00235 <span class="comment">Routine Description:</span>
00236 <span class="comment"></span>
00237 <span class="comment">    This routine simply scans the input Name string looking for any Nt</span>
00238 <span class="comment">    wild card characters.</span>
00239 <span class="comment"></span>
00240 <span class="comment">Arguments:</span>
00241 <span class="comment"></span>
00242 <span class="comment">    Name - The string to check.</span>
00243 <span class="comment"></span>
00244 <span class="comment">Return Value:</span>
00245 <span class="comment"></span>
00246 <span class="comment">    BOOLEAN - TRUE if one or more wild card characters was found.</span>
00247 <span class="comment"></span>
00248 <span class="comment">--*/</span>
00249 {
00250     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> p;
00251 
00252     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00253 
00254     <span class="comment">//</span>
00255     <span class="comment">//  Check each character in the name to see if it's a wildcard</span>
00256     <span class="comment">//  character.</span>
00257     <span class="comment">//</span>
00258 
00259     <span class="keywordflow">if</span>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length ) {
00260         <span class="keywordflow">for</span>( p = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer + (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length / <span class="keyword">sizeof</span>(WCHAR)) - 1;
00261              p &gt;= <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer &amp;&amp; *p != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span> ;
00262              p-- ) {
00263 
00264             <span class="comment">//</span>
00265             <span class="comment">//  check for a wild card character</span>
00266             <span class="comment">//</span>
00267 
00268             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a45">FsRtlIsUnicodeCharacterWild</a>( *p )) {
00269 
00270                 <span class="comment">//</span>
00271                 <span class="comment">//  Tell caller that this name contains wild cards</span>
00272                 <span class="comment">//</span>
00273 
00274                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00275             }
00276         }
00277     }
00278 
00279     <span class="comment">//</span>
00280     <span class="comment">//  No wildcard characters were found, so return to our caller</span>
00281     <span class="comment">//</span>
00282 
00283     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00284 }
00285 
00286 
00287 BOOLEAN
<a name="l00288"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a178">00288</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a178">FsRtlAreNamesEqual</a> (
00289     PCUNICODE_STRING ConstantNameA,
00290     PCUNICODE_STRING ConstantNameB,
00291     IN BOOLEAN IgnoreCase,
00292     IN PCWCH UpcaseTable OPTIONAL
00293     )
00294 
00295 <span class="comment">/*++</span>
00296 <span class="comment"></span>
00297 <span class="comment">Routine Description:</span>
00298 <span class="comment"></span>
00299 <span class="comment">    This routine simple returns whether the two names are exactly equal.</span>
00300 <span class="comment">    If the two names are known to be constant, this routine is much</span>
00301 <span class="comment">    faster than FsRtlIsNameInExpression.</span>
00302 <span class="comment"></span>
00303 <span class="comment">Arguments:</span>
00304 <span class="comment"></span>
00305 <span class="comment">    ConstantNameA - Constant name.</span>
00306 <span class="comment"></span>
00307 <span class="comment">    ConstantNameB - Constant name.</span>
00308 <span class="comment"></span>
00309 <span class="comment">    IgnoreCase - TRUE if the Names should be Upcased before comparing.</span>
00310 <span class="comment"></span>
00311 <span class="comment">    UpcaseTable - If supplied, use this table for case insensitive compares,</span>
00312 <span class="comment">        otherwise, use the default system upcase table.</span>
00313 <span class="comment"></span>
00314 <span class="comment">Return Value:</span>
00315 <span class="comment"></span>
00316 <span class="comment">    BOOLEAN - TRUE if the two names are lexically equal.</span>
00317 <span class="comment"></span>
00318 <span class="comment">--*/</span>
00319 
00320 {
00321     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00322     ULONG NameLength;
00323     BOOLEAN FreeStrings = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00324 
00325     UNICODE_STRING LocalNameA;
00326     UNICODE_STRING LocalNameB;
00327 
00328     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00329 
00330     <span class="comment">//</span>
00331     <span class="comment">// If the names aren't even the same size, then return FALSE right away.</span>
00332     <span class="comment">//</span>
00333 
00334     <span class="keywordflow">if</span> ( ConstantNameA-&gt;Length != ConstantNameB-&gt;Length ) {
00335 
00336         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00337     }
00338 
00339     NameLength = ConstantNameA-&gt;Length / <span class="keyword">sizeof</span>(WCHAR);
00340 
00341     <span class="comment">//</span>
00342     <span class="comment">//  If we weren't given an upcase table, we have to upcase the names</span>
00343     <span class="comment">//  ourselves.</span>
00344     <span class="comment">//</span>
00345 
00346     <span class="keywordflow">if</span> ( IgnoreCase &amp;&amp; !ARGUMENT_PRESENT(UpcaseTable) ) {
00347 
00348         <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00349 
00350         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/nls_8c.html#a31">RtlUpcaseUnicodeString</a>( &amp;LocalNameA, ConstantNameA, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00351 
00352         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
00353 
00354             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00355         }
00356 
00357         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/nls_8c.html#a31">RtlUpcaseUnicodeString</a>( &amp;LocalNameB, ConstantNameB, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00358 
00359         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
00360 
00361             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;LocalNameA );
00362 
00363             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00364         }
00365 
00366         ConstantNameA = &amp;LocalNameA;
00367         ConstantNameB = &amp;LocalNameB;
00368 
00369         IgnoreCase = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00370         FreeStrings = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00371     }
00372 
00373     <span class="comment">//</span>
00374     <span class="comment">//  Do either case sensitive or insensitive compare.</span>
00375     <span class="comment">//</span>
00376 
00377     <span class="keywordflow">if</span> ( !IgnoreCase ) {
00378 
00379         BOOLEAN BytesEqual;
00380 
00381         BytesEqual = (BOOLEAN) RtlEqualMemory( ConstantNameA-&gt;Buffer,
00382                                                ConstantNameB-&gt;Buffer,
00383                                                ConstantNameA-&gt;Length );
00384 
00385         <span class="keywordflow">if</span> ( FreeStrings ) {
00386 
00387             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;LocalNameA );
00388             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;LocalNameB );
00389         }
00390 
00391         <span class="keywordflow">return</span> BytesEqual;
00392 
00393     } <span class="keywordflow">else</span> {
00394 
00395         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; NameLength; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
00396 
00397             <span class="keywordflow">if</span> ( UpcaseTable[ConstantNameA-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]] !=
00398                  UpcaseTable[ConstantNameB-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]] ) {
00399 
00400                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00401             }
00402         }
00403 
00404         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00405     }
00406 }
00407 
00408 
00409 <span class="comment">//</span>
00410 <span class="comment">//  The following routine is just a wrapper around</span>
00411 <span class="comment">//  FsRtlIsNameInExpressionPrivate to make a last minute fix a bit safer.</span>
00412 <span class="comment">//</span>
00413 
00414 BOOLEAN
<a name="l00415"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a179">00415</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a179">FsRtlIsNameInExpression</a> (
00416     IN PUNICODE_STRING Expression,
00417     IN PUNICODE_STRING Name,
00418     IN BOOLEAN IgnoreCase,
00419     IN PWCH UpcaseTable OPTIONAL
00420     )
00421 
00422 {
00423     BOOLEAN Result;
00424     UNICODE_STRING LocalName;
00425 
00426     <span class="comment">//</span>
00427     <span class="comment">//  If we weren't given an upcase table, we have to upcase the names</span>
00428     <span class="comment">//  ourselves.</span>
00429     <span class="comment">//</span>
00430 
00431     <span class="keywordflow">if</span> ( IgnoreCase &amp;&amp; !ARGUMENT_PRESENT(UpcaseTable) ) {
00432 
00433         <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00434 
00435         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/nls_8c.html#a31">RtlUpcaseUnicodeString</a>( &amp;LocalName, <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00436 
00437         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
00438 
00439             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00440         }
00441 
00442         <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> = &amp;LocalName;
00443 
00444         IgnoreCase = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00445 
00446     } <span class="keywordflow">else</span> {
00447 
00448         LocalName.Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00449     }
00450 
00451     <span class="comment">//</span>
00452     <span class="comment">//  Now call the main routine, remembering to free the upcased string</span>
00453     <span class="comment">//  if we allocated one.</span>
00454     <span class="comment">//</span>
00455 
00456     <span class="keywordflow">try</span> {
00457 
00458         Result = <a class="code" href="../../d4/d5/name_8c.html#a4">FsRtlIsNameInExpressionPrivate</a>( Expression,
00459                                                  <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>,
00460                                                  IgnoreCase,
00461                                                  UpcaseTable );
00462 
00463     } finally {
00464 
00465         <span class="keywordflow">if</span> (LocalName.Buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00466 
00467             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;LocalName );
00468         }
00469     }
00470 
00471     <span class="keywordflow">return</span> Result;
00472 }
00473 
00474 
<a name="l00475"></a><a class="code" href="../../d4/d5/name_8c.html#a3">00475</a> <span class="preprocessor">#define MATCHES_ARRAY_SIZE 16</span>
00476 <span class="preprocessor"></span>
00477 <span class="comment">//</span>
00478 <span class="comment">//  Local support routine prototypes</span>
00479 <span class="comment">//</span>
00480 
00481 BOOLEAN
<a name="l00482"></a><a class="code" href="../../d4/d5/name_8c.html#a4">00482</a> <a class="code" href="../../d4/d5/name_8c.html#a4">FsRtlIsNameInExpressionPrivate</a> (
00483     IN PUNICODE_STRING Expression,
00484     IN PUNICODE_STRING Name,
00485     IN BOOLEAN IgnoreCase,
00486     IN PWCH UpcaseTable
00487     )
00488 
00489 <span class="comment">/*++</span>
00490 <span class="comment"></span>
00491 <span class="comment">Routine Description:</span>
00492 <span class="comment"></span>
00493 <span class="comment">    This routine compares a Dbcs name and an expression and tells the caller</span>
00494 <span class="comment">    if the name is in the language defined by the expression.  The input name</span>
00495 <span class="comment">    cannot contain wildcards, while the expression may contain wildcards.</span>
00496 <span class="comment"></span>
00497 <span class="comment">    Expression wild cards are evaluated as shown in the nondeterministic</span>
00498 <span class="comment">    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.</span>
00499 <span class="comment"></span>
00500 <span class="comment"></span>
00501 <span class="comment">             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT</span>
00502 <span class="comment"></span>
00503 <span class="comment"></span>
00504 <span class="comment">                                       S</span>
00505 <span class="comment">                                    &lt;-----&lt;</span>
00506 <span class="comment">                                 X  |     |  e       Y</span>
00507 <span class="comment">             X * Y ==       (0)-----&gt;-(1)-&gt;-----(2)-----(3)</span>
00508 <span class="comment"></span>
00509 <span class="comment"></span>
00510 <span class="comment">                                      S-.</span>
00511 <span class="comment">                                    &lt;-----&lt;</span>
00512 <span class="comment">                                 X  |     |  e       Y</span>
00513 <span class="comment">             X ~* Y ==      (0)-----&gt;-(1)-&gt;-----(2)-----(3)</span>
00514 <span class="comment"></span>
00515 <span class="comment"></span>
00516 <span class="comment"></span>
00517 <span class="comment">                                X     S     S     Y</span>
00518 <span class="comment">             X ?? Y ==      (0)---(1)---(2)---(3)---(4)</span>
00519 <span class="comment"></span>
00520 <span class="comment"></span>
00521 <span class="comment"></span>
00522 <span class="comment">                                X     .        .      Y</span>
00523 <span class="comment">             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)</span>
00524 <span class="comment">                                   |      |________|</span>
00525 <span class="comment">                                   |           ^   |</span>
00526 <span class="comment">                                   |_______________|</span>
00527 <span class="comment">                                      ^EOF or .^</span>
00528 <span class="comment"></span>
00529 <span class="comment"></span>
00530 <span class="comment">                                X     S-.     S-.     Y</span>
00531 <span class="comment">             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)</span>
00532 <span class="comment">                                   |      |________|</span>
00533 <span class="comment">                                   |           ^   |</span>
00534 <span class="comment">                                   |_______________|</span>
00535 <span class="comment">                                      ^EOF or .^</span>
00536 <span class="comment"></span>
00537 <span class="comment"></span>
00538 <span class="comment"></span>
00539 <span class="comment">         where S is any single character</span>
00540 <span class="comment"></span>
00541 <span class="comment">               S-. is any single character except the final .</span>
00542 <span class="comment"></span>
00543 <span class="comment">               e is a null character transition</span>
00544 <span class="comment"></span>
00545 <span class="comment">               EOF is the end of the name string</span>
00546 <span class="comment"></span>
00547 <span class="comment">    In words:</span>
00548 <span class="comment"></span>
00549 <span class="comment">        * matches 0 or more characters.</span>
00550 <span class="comment"></span>
00551 <span class="comment">        ? matches exactly 1 character.</span>
00552 <span class="comment"></span>
00553 <span class="comment">        DOS_STAR matches 0 or more characters until encountering and matching</span>
00554 <span class="comment">            the final . in the name.</span>
00555 <span class="comment"></span>
00556 <span class="comment">        DOS_QM matches any single character, or upon encountering a period or</span>
00557 <span class="comment">            end of name string, advances the expression to the end of the</span>
00558 <span class="comment">            set of contiguous DOS_QMs.</span>
00559 <span class="comment"></span>
00560 <span class="comment">        DOS_DOT matches either a . or zero characters beyond name string.</span>
00561 <span class="comment"></span>
00562 <span class="comment">Arguments:</span>
00563 <span class="comment"></span>
00564 <span class="comment">    Expression - Supplies the input expression to check against</span>
00565 <span class="comment">        (Caller must already upcase if passing CaseInsensitive TRUE.)</span>
00566 <span class="comment"></span>
00567 <span class="comment">    Name - Supplies the input name to check for.</span>
00568 <span class="comment"></span>
00569 <span class="comment">    CaseInsensitive - TRUE if Name should be Upcased before comparing.</span>
00570 <span class="comment"></span>
00571 <span class="comment">Return Value:</span>
00572 <span class="comment"></span>
00573 <span class="comment">    BOOLEAN - TRUE if Name is an element in the set of strings denoted</span>
00574 <span class="comment">        by the input Expression and FALSE otherwise.</span>
00575 <span class="comment"></span>
00576 <span class="comment">--*/</span>
00577 
00578 {
00579     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> NameOffset;
00580     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ExprOffset;
00581 
00582     ULONG SrcCount;
00583     ULONG DestCount;
00584     ULONG PreviousDestCount;
00585     ULONG MatchesCount;
00586 
00587     WCHAR NameChar, ExprChar;
00588 
00589     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> LocalBuffer[<a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> * 2];
00590 
00591     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *AuxBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00592     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *PreviousMatches;
00593     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *CurrentMatches;
00594 
00595     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MaxState;
00596     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> CurrentState;
00597 
00598     BOOLEAN NameFinished = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00599 
00600     <span class="comment">//</span>
00601     <span class="comment">//  The idea behind the algorithm is pretty simple.  We keep track of</span>
00602     <span class="comment">//  all possible locations in the regular expression that are matching</span>
00603     <span class="comment">//  the name.  If when the name has been exhausted one of the locations</span>
00604     <span class="comment">//  in the expression is also just exhausted, the name is in the language</span>
00605     <span class="comment">//  defined by the regular expression.</span>
00606     <span class="comment">//</span>
00607 
00608     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00609 
00610     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlIsNameInExpression\n"</span>, 0);
00611     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" Expression      = %Z\n"</span>, Expression );
00612     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" Name            = %Z\n"</span>, <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> );
00613     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" CaseInsensitive = %08lx\n"</span>, CaseInsensitive );
00614 
00615     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length != 0 );
00616     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Expression-&gt;Length != 0 );
00617 
00618     <span class="comment">//</span>
00619     <span class="comment">//  If one string is empty return FALSE.  If both are empty return TRUE.</span>
00620     <span class="comment">//</span>
00621 
00622     <span class="keywordflow">if</span> ( (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length == 0) || (Expression-&gt;Length == 0) ) {
00623 
00624         <span class="keywordflow">return</span> (BOOLEAN)(!(<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length + Expression-&gt;Length));
00625     }
00626 
00627     <span class="comment">//</span>
00628     <span class="comment">//  Special case by far the most common wild card search of *</span>
00629     <span class="comment">//</span>
00630 
00631     <span class="keywordflow">if</span> ((Expression-&gt;Length == 2) &amp;&amp; (Expression-&gt;Buffer[0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'*'</span>)) {
00632 
00633         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00634     }
00635 
00636     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a177">FsRtlDoesNameContainWildCards</a>( Expression ) );
00637 
00638     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !IgnoreCase || ARGUMENT_PRESENT(UpcaseTable) );
00639 
00640     <span class="comment">//</span>
00641     <span class="comment">//  Also special case expressions of the form *X.  With this and the prior</span>
00642     <span class="comment">//  case we have covered virtually all normal queries.</span>
00643     <span class="comment">//</span>
00644 
00645     <span class="keywordflow">if</span> (Expression-&gt;Buffer[0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'*'</span>) {
00646 
00647         UNICODE_STRING LocalExpression;
00648 
00649         LocalExpression = *Expression;
00650 
00651         LocalExpression.Buffer += 1;
00652         LocalExpression.Length -= 2;
00653 
00654         <span class="comment">//</span>
00655         <span class="comment">//  Only special case an expression with a single *</span>
00656         <span class="comment">//</span>
00657 
00658         <span class="keywordflow">if</span> ( !<a class="code" href="../../d1/d8/fsrtl_8h.html#a177">FsRtlDoesNameContainWildCards</a>( &amp;LocalExpression ) ) {
00659 
00660             ULONG StartingNameOffset;
00661 
00662             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length &lt; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Expression-&gt;Length - <span class="keyword">sizeof</span>(WCHAR))) {
00663 
00664                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00665             }
00666 
00667             StartingNameOffset = ( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length -
00668                                    LocalExpression.Length ) / <span class="keyword">sizeof</span>(WCHAR);
00669 
00670             <span class="comment">//</span>
00671             <span class="comment">//  Do a simple memory compare if case sensitive, otherwise</span>
00672             <span class="comment">//  we have got to check this one character at a time.</span>
00673             <span class="comment">//</span>
00674 
00675             <span class="keywordflow">if</span> ( !IgnoreCase ) {
00676 
00677                 <span class="keywordflow">return</span> (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
00678                                                  <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer + StartingNameOffset,
00679                                                  LocalExpression.Length );
00680 
00681             } <span class="keywordflow">else</span> {
00682 
00683                 <span class="keywordflow">for</span> ( ExprOffset = 0;
00684                       ExprOffset &lt; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(LocalExpression.Length / <span class="keyword">sizeof</span>(WCHAR));
00685                       ExprOffset += 1 ) {
00686 
00687                     NameChar = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[StartingNameOffset + ExprOffset];
00688                     NameChar = UpcaseTable[NameChar];
00689 
00690                     ExprChar = LocalExpression.Buffer[ExprOffset];
00691 
00692                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ExprChar == UpcaseTable[ExprChar] );
00693 
00694                     <span class="keywordflow">if</span> ( NameChar != ExprChar ) {
00695 
00696                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00697                     }
00698                 }
00699 
00700                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00701             }
00702         }
00703     }
00704 
00705     <span class="comment">//</span>
00706     <span class="comment">//  Walk through the name string, picking off characters.  We go one</span>
00707     <span class="comment">//  character beyond the end because some wild cards are able to match</span>
00708     <span class="comment">//  zero characters beyond the end of the string.</span>
00709     <span class="comment">//</span>
00710     <span class="comment">//  With each new name character we determine a new set of states that</span>
00711     <span class="comment">//  match the name so far.  We use two arrays that we swap back and forth</span>
00712     <span class="comment">//  for this purpose.  One array lists the possible expression states for</span>
00713     <span class="comment">//  all name characters up to but not including the current one, and other</span>
00714     <span class="comment">//  array is used to build up the list of states considering the current</span>
00715     <span class="comment">//  name character as well.  The arrays are then switched and the process</span>
00716     <span class="comment">//  repeated.</span>
00717     <span class="comment">//</span>
00718     <span class="comment">//  There is not a one-to-one correspondence between state number and</span>
00719     <span class="comment">//  offset into the expression.  This is evident from the NFAs in the</span>
00720     <span class="comment">//  initial comment to this function.  State numbering is not continuous.</span>
00721     <span class="comment">//  This allows a simple conversion between state number and expression</span>
00722     <span class="comment">//  offset.  Each character in the expression can represent one or two</span>
00723     <span class="comment">//  states.  * and DOS_STAR generate two states: ExprOffset*2 and</span>
00724     <span class="comment">//  ExprOffset*2 + 1.  All other expreesion characters can produce only</span>
00725     <span class="comment">//  a single state.  Thus ExprOffset = State/2.</span>
00726     <span class="comment">//</span>
00727     <span class="comment">//</span>
00728     <span class="comment">//  Here is a short description of the variables involved:</span>
00729     <span class="comment">//</span>
00730     <span class="comment">//  NameOffset  - The offset of the current name char being processed.</span>
00731     <span class="comment">//</span>
00732     <span class="comment">//  ExprOffset  - The offset of the current expression char being processed.</span>
00733     <span class="comment">//</span>
00734     <span class="comment">//  SrcCount    - Prior match being investigated with current name char</span>
00735     <span class="comment">//</span>
00736     <span class="comment">//  DestCount   - Next location to put a matching assuming current name char</span>
00737     <span class="comment">//</span>
00738     <span class="comment">//  NameFinished - Allows one more itteration through the Matches array</span>
00739     <span class="comment">//                 after the name is exhusted (to come *s for example)</span>
00740     <span class="comment">//</span>
00741     <span class="comment">//  PreviousDestCount - This is used to prevent entry duplication, see coment</span>
00742     <span class="comment">//</span>
00743     <span class="comment">//  PreviousMatches   - Holds the previous set of matches (the Src array)</span>
00744     <span class="comment">//</span>
00745     <span class="comment">//  CurrentMatches    - Holds the current set of matches (the Dest array)</span>
00746     <span class="comment">//</span>
00747     <span class="comment">//  AuxBuffer, LocalBuffer - the storage for the Matches arrays</span>
00748     <span class="comment">//</span>
00749 
00750     <span class="comment">//</span>
00751     <span class="comment">//  Set up the initial variables</span>
00752     <span class="comment">//</span>
00753 
00754     PreviousMatches = &amp;LocalBuffer[0];
00755     CurrentMatches = &amp;LocalBuffer[<a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a>];
00756 
00757     PreviousMatches[0] = 0;
00758     MatchesCount = 1;
00759 
00760     NameOffset = 0;
00761 
00762     MaxState = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Expression-&gt;Length * 2);
00763 
00764     <span class="keywordflow">while</span> ( !NameFinished ) {
00765 
00766         <span class="keywordflow">if</span> ( NameOffset &lt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length ) {
00767 
00768             NameChar = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[NameOffset / <span class="keyword">sizeof</span>(WCHAR)];
00769 
00770             NameOffset += <span class="keyword">sizeof</span>(WCHAR);;
00771 
00772         } <span class="keywordflow">else</span> {
00773 
00774             NameFinished = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00775 
00776             <span class="comment">//</span>
00777             <span class="comment">//  if we have already exhasted the expression, cool.  Don't</span>
00778             <span class="comment">//  continue.</span>
00779             <span class="comment">//</span>
00780 
00781             <span class="keywordflow">if</span> ( PreviousMatches[MatchesCount-1] == MaxState ) {
00782 
00783                 <span class="keywordflow">break</span>;
00784             }
00785         }
00786 
00787 
00788         <span class="comment">//</span>
00789         <span class="comment">//  Now, for each of the previous stored expression matches, see what</span>
00790         <span class="comment">//  we can do with this name character.</span>
00791         <span class="comment">//</span>
00792 
00793         SrcCount = 0;
00794         DestCount = 0;
00795         PreviousDestCount = 0;
00796 
00797         <span class="keywordflow">while</span> ( SrcCount &lt; MatchesCount ) {
00798 
00799             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Length;
00800 
00801             <span class="comment">//</span>
00802             <span class="comment">//  We have to carry on our expression analysis as far as possible</span>
00803             <span class="comment">//  for each character of name, so we loop here until the</span>
00804             <span class="comment">//  expression stops matching.  A clue here is that expression</span>
00805             <span class="comment">//  cases that can match zero or more characters end with a</span>
00806             <span class="comment">//  continue, while those that can accept only a single character</span>
00807             <span class="comment">//  end with a break.</span>
00808             <span class="comment">//</span>
00809 
00810             ExprOffset = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((PreviousMatches[SrcCount++] + 1) / 2);
00811 
00812 
00813             Length = 0;
00814 
00815             <span class="keywordflow">while</span> ( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ) {
00816 
00817                 <span class="keywordflow">if</span> ( ExprOffset == Expression-&gt;Length ) {
00818 
00819                     <span class="keywordflow">break</span>;
00820                 }
00821 
00822                 <span class="comment">//</span>
00823                 <span class="comment">//  The first time through the loop we don't want</span>
00824                 <span class="comment">//  to increment ExprOffset.</span>
00825                 <span class="comment">//</span>
00826 
00827                 ExprOffset += Length;
00828                 Length = <span class="keyword">sizeof</span>(WCHAR);
00829 
00830                 CurrentState = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ExprOffset * 2);
00831 
00832                 <span class="keywordflow">if</span> ( ExprOffset == Expression-&gt;Length ) {
00833 
00834                     CurrentMatches[DestCount++] = MaxState;
00835                     <span class="keywordflow">break</span>;
00836                 }
00837 
00838                 ExprChar = Expression-&gt;Buffer[ExprOffset / <span class="keyword">sizeof</span>(WCHAR)];
00839 
00840                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !IgnoreCase || !((ExprChar &gt;= <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'a'</span>) &amp;&amp; (ExprChar &lt;= <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'z'</span>)) );
00841 
00842                 <span class="comment">//</span>
00843                 <span class="comment">//  Before we get started, we have to check for something</span>
00844                 <span class="comment">//  really gross.  We may be about to exhaust the local</span>
00845                 <span class="comment">//  space for ExpressionMatches[][], so we have to allocate</span>
00846                 <span class="comment">//  some pool if this is the case.  Yuk!</span>
00847                 <span class="comment">//</span>
00848 
00849                 <span class="keywordflow">if</span> ( (DestCount &gt;= <a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> - 2) &amp;&amp;
00850                      (AuxBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ) {
00851 
00852                     ULONG ExpressionChars;
00853 
00854                     ExpressionChars = Expression-&gt;Length / <span class="keyword">sizeof</span>(WCHAR);
00855 
00856                     AuxBuffer = <a class="code" href="../../d3/d8/fsrtlp_8h.html#a2">FsRtlpAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
00857                                                     (ExpressionChars+1) *
00858                                                     <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)*2*2 );
00859 
00860                     RtlCopyMemory( AuxBuffer,
00861                                    CurrentMatches,
00862                                    <a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) );
00863 
00864                     CurrentMatches = AuxBuffer;
00865 
00866                     RtlCopyMemory( AuxBuffer + (ExpressionChars+1)*2,
00867                                    PreviousMatches,
00868                                    <a class="code" href="../../d1/d3/dbcsname_8c.html#a4">MATCHES_ARRAY_SIZE</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) );
00869 
00870                     PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
00871                 }
00872 
00873                 <span class="comment">//</span>
00874                 <span class="comment">//  * matches any character zero or more times.</span>
00875                 <span class="comment">//</span>
00876 
00877                 <span class="keywordflow">if</span> (ExprChar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'*'</span>) {
00878 
00879                     CurrentMatches[DestCount++] = CurrentState;
00880                     CurrentMatches[DestCount++] = CurrentState + 3;
00881                     <span class="keywordflow">continue</span>;
00882                 }
00883 
00884                 <span class="comment">//</span>
00885                 <span class="comment">//  DOS_STAR matches any character except . zero or more times.</span>
00886                 <span class="comment">//</span>
00887 
00888                 <span class="keywordflow">if</span> (ExprChar == DOS_STAR) {
00889 
00890                     BOOLEAN ICanEatADot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00891 
00892                     <span class="comment">//</span>
00893                     <span class="comment">//  If we are at a period, determine if we are allowed to</span>
00894                     <span class="comment">//  consume it, ie. make sure it is not the last one.</span>
00895                     <span class="comment">//</span>
00896 
00897                     <span class="keywordflow">if</span> ( !NameFinished &amp;&amp; (NameChar == <span class="charliteral">'.'</span>) ) {
00898 
00899                         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00900 
00901                         <span class="keywordflow">for</span> ( <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = NameOffset;
00902                               <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length;
00903                               <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += Length ) {
00904 
00905                             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> / <span class="keyword">sizeof</span>(WCHAR)] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) {
00906 
00907                                 ICanEatADot = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00908                                 <span class="keywordflow">break</span>;
00909                             }
00910                         }
00911                     }
00912 
00913                     <span class="keywordflow">if</span> (NameFinished || (NameChar != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) || ICanEatADot) {
00914 
00915                         CurrentMatches[DestCount++] = CurrentState;
00916                         CurrentMatches[DestCount++] = CurrentState + 3;
00917                         <span class="keywordflow">continue</span>;
00918 
00919                     } <span class="keywordflow">else</span> {
00920 
00921                         <span class="comment">//</span>
00922                         <span class="comment">//  We are at a period.  We can only match zero</span>
00923                         <span class="comment">//  characters (ie. the epsilon transition).</span>
00924                         <span class="comment">//</span>
00925 
00926                         CurrentMatches[DestCount++] = CurrentState + 3;
00927                         <span class="keywordflow">continue</span>;
00928                     }
00929                 }
00930 
00931                 <span class="comment">//</span>
00932                 <span class="comment">//  The following expreesion characters all match by consuming</span>
00933                 <span class="comment">//  a character, thus force the expression, and thus state</span>
00934                 <span class="comment">//  forward.</span>
00935                 <span class="comment">//</span>
00936 
00937                 CurrentState += (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(<span class="keyword">sizeof</span>(WCHAR) * 2);
00938 
00939                 <span class="comment">//</span>
00940                 <span class="comment">//  DOS_QM is the most complicated.  If the name is finished,</span>
00941                 <span class="comment">//  we can match zero characters.  If this name is a '.', we</span>
00942                 <span class="comment">//  don't match, but look at the next expression.  Otherwise</span>
00943                 <span class="comment">//  we match a single character.</span>
00944                 <span class="comment">//</span>
00945 
00946                 <span class="keywordflow">if</span> ( ExprChar == DOS_QM ) {
00947 
00948                     <span class="keywordflow">if</span> ( NameFinished || (NameChar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) ) {
00949 
00950                         <span class="keywordflow">continue</span>;
00951                     }
00952 
00953                     CurrentMatches[DestCount++] = CurrentState;
00954                     <span class="keywordflow">break</span>;
00955                 }
00956 
00957                 <span class="comment">//</span>
00958                 <span class="comment">//  A DOS_DOT can match either a period, or zero characters</span>
00959                 <span class="comment">//  beyond the end of name.</span>
00960                 <span class="comment">//</span>
00961 
00962                 <span class="keywordflow">if</span> (ExprChar == DOS_DOT) {
00963 
00964                     <span class="keywordflow">if</span> ( NameFinished ) {
00965 
00966                         <span class="keywordflow">continue</span>;
00967                     }
00968 
00969                     <span class="keywordflow">if</span> (NameChar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) {
00970 
00971                         CurrentMatches[DestCount++] = CurrentState;
00972                         <span class="keywordflow">break</span>;
00973                     }
00974                 }
00975 
00976                 <span class="comment">//</span>
00977                 <span class="comment">//  From this point on a name character is required to even</span>
00978                 <span class="comment">//  continue, let alone make a match.</span>
00979                 <span class="comment">//</span>
00980 
00981                 <span class="keywordflow">if</span> ( NameFinished ) {
00982 
00983                     <span class="keywordflow">break</span>;
00984                 }
00985 
00986                 <span class="comment">//</span>
00987                 <span class="comment">//  If this expression was a '?' we can match it once.</span>
00988                 <span class="comment">//</span>
00989 
00990                 <span class="keywordflow">if</span> (ExprChar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'?'</span>) {
00991 
00992                     CurrentMatches[DestCount++] = CurrentState;
00993                     <span class="keywordflow">break</span>;
00994                 }
00995 
00996                 <span class="comment">//</span>
00997                 <span class="comment">//  Finally, check if the expression char matches the name char</span>
00998                 <span class="comment">//</span>
00999 
01000                 <span class="keywordflow">if</span> (ExprChar == (WCHAR)(IgnoreCase ?
01001                                         UpcaseTable[NameChar] : NameChar)) {
01002 
01003                     CurrentMatches[DestCount++] = CurrentState;
01004                     <span class="keywordflow">break</span>;
01005                 }
01006 
01007                 <span class="comment">//</span>
01008                 <span class="comment">//  The expression didn't match so go look at the next</span>
01009                 <span class="comment">//  previous match.</span>
01010                 <span class="comment">//</span>
01011 
01012                 <span class="keywordflow">break</span>;
01013             }
01014 
01015 
01016             <span class="comment">//</span>
01017             <span class="comment">//  Prevent duplication in the destination array.</span>
01018             <span class="comment">//</span>
01019             <span class="comment">//  Each of the arrays is montonically increasing and non-</span>
01020             <span class="comment">//  duplicating, thus we skip over any source element in the src</span>
01021             <span class="comment">//  array if we just added the same element to the destination</span>
01022             <span class="comment">//  array.  This guarentees non-duplication in the dest. array.</span>
01023             <span class="comment">//</span>
01024 
01025             <span class="keywordflow">if</span> ((SrcCount &lt; MatchesCount) &amp;&amp;
01026                 (PreviousDestCount &lt; DestCount) ) {
01027 
01028                 <span class="keywordflow">while</span> (PreviousDestCount &lt; DestCount) {
01029 
01030                     <span class="keywordflow">while</span> ( PreviousMatches[SrcCount] &lt;
01031                          CurrentMatches[PreviousDestCount] ) {
01032 
01033                         SrcCount += 1;
01034                     }
01035 
01036                     PreviousDestCount += 1;
01037                 }
01038             }
01039         }
01040 
01041         <span class="comment">//</span>
01042         <span class="comment">//  If we found no matches in the just finished itteration, it's time</span>
01043         <span class="comment">//  to bail.</span>
01044         <span class="comment">//</span>
01045 
01046         <span class="keywordflow">if</span> ( DestCount == 0 ) {
01047 
01048             <span class="keywordflow">if</span> (AuxBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) { <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( AuxBuffer ); }
01049 
01050             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01051         }
01052 
01053         <span class="comment">//</span>
01054         <span class="comment">//  Swap the meaning the two arrays</span>
01055         <span class="comment">//</span>
01056 
01057         {
01058             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> *Tmp;
01059 
01060             Tmp = PreviousMatches;
01061 
01062             PreviousMatches = CurrentMatches;
01063 
01064             CurrentMatches = Tmp;
01065         }
01066 
01067         MatchesCount = DestCount;
01068     }
01069 
01070 
01071     CurrentState = PreviousMatches[MatchesCount-1];
01072 
01073     <span class="keywordflow">if</span> (AuxBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) { <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( AuxBuffer ); }
01074 
01075 
01076     <span class="keywordflow">return</span> (BOOLEAN)(CurrentState == MaxState);
01077 }
01078 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:53 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
