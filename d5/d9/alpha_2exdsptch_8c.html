<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: alpha/exdsptch.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>exdsptch.c File Reference</h1><code>#include "<a class="el" href="../../d6/d8/ntrtlp_8h-source.html">ntrtlp.h</a>"</code><br>

<p>
<a href="../../d6/d8/alpha_2exdsptch_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(<a class="el" href="../../d2/d1/cttoken_8c.html#a18">Status</a>, ExceptionRecordt)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a1">IS_HANDLER_DEFINED</a>(FunctionEntry)&nbsp;&nbsp;&nbsp;(RF_EXCEPTION_HANDLER(FunctionEntry) != 0)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a>&nbsp;&nbsp;&nbsp;VirtualFramePointer</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a3">Real</a>&nbsp;&nbsp;&nbsp;RealFramePointer</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a5">_RtlpFoundTrapFrame</a>(NextPc)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a6">_RtlpVirtualUnwindExit</a>(NextPc, ContextRecord, EstablisherFrame)</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int __cdecl&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a8">sprintf</a> (char *, const char *,...)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a9">RtlpRaiseException</a> (IN PEXCEPTION_RECORD ExceptionRecord)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a10">RtlpRaiseStatus</a> (IN NTSTATUS <a class="el" href="../../d2/d1/cttoken_8c.html#a18">Status</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG_PTR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a11">RtlpVirtualUnwind</a> (IN ULONG_PTR ControlPc, IN PRUNTIME_FUNCTION FunctionEntry, IN PCONTEXT ContextRecord, OUT PBOOLEAN InFunction, OUT PFRAME_POINTERS EstablisherFrame)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PRUNTIME_FUNCTION&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a12">RtlLookupDynamicFunctionEntry</a> (IN ULONG_PTR ControlPc)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PRUNTIME_FUNCTION&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a13">RtlLookupStaticFunctionEntry</a> (IN ULONG_PTR ControlPc, OUT PBOOLEAN InImage)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a14">RtlGetUnwindFunctionEntry</a> (IN ULONG_PTR ControlPc, IN PRUNTIME_FUNCTION FunctionEntry, OUT PRUNTIME_FUNCTION UnwindFunctionEntry, OUT PULONG StackAdjust, OUT PULONG_PTR FixedReturn)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a15">RtlDispatchException</a> (IN PEXCEPTION_RECORD ExceptionRecord, IN PCONTEXT ContextRecord)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PRUNTIME_FUNCTION&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a16">RtlLookupFunctionEntry</a> (IN ULONG_PTR ControlPc)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a17">RtlRaiseException</a> (IN PEXCEPTION_RECORD ExceptionRecord)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a18">RtlRaiseStatus</a> (IN NTSTATUS <a class="el" href="../../d2/d1/cttoken_8c.html#a18">Status</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a19">RtlUnwind</a> (IN PVOID TargetFrame OPTIONAL, IN PVOID TargetIp OPTIONAL, IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL, IN PVOID ReturnValue)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a20">RtlUnwind2</a> (IN PVOID TargetFrame OPTIONAL, IN PVOID TargetIp OPTIONAL, IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL, IN PVOID ReturnValue, IN PCONTEXT ContextRecord)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG_PTR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a21">RtlVirtualUnwind</a> (IN ULONG_PTR ControlPc, IN PRUNTIME_FUNCTION FunctionEntry, IN OUT PCONTEXT ContextRecord, OUT PBOOLEAN InFunction, OUT PFRAME_POINTERS EstablisherFrame, IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PRUNTIME_FUNCTION&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a22">RtlLookupDirectFunctionEntry</a> (IN ULONG_PTR ControlPc)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PLIST_ENTRY&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a23">RtlGetFunctionTableListHead</a> (VOID)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a24">RtlAddFunctionTable</a> (IN PRUNTIME_FUNCTION FunctionTable, IN ULONG EntryCount)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a25">RtlDeleteFunctionTable</a> (IN PRUNTIME_FUNCTION FunctionTable)</td></tr>

<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>LIST_ENTRY&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a></td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a4" doxytag="alpha/exdsptch.c::_RtlpDebugDisassemble" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define _RtlpDebugDisassemble          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ControlPc,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>ContextRecord&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l01448">1448</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l01455">RtlVirtualUnwind()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="alpha/exdsptch.c::_RtlpFoundTrapFrame" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define _RtlpFoundTrapFrame          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">NextPc&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l01449">1449</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l01455">RtlVirtualUnwind()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="alpha/exdsptch.c::_RtlpVirtualUnwindExit" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define _RtlpVirtualUnwindExit          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">NextPc,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>ContextRecord,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>EstablisherFrame&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l01450">1450</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l01455">RtlVirtualUnwind()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="alpha/exdsptch.c::IS_HANDLER_DEFINED" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define IS_HANDLER_DEFINED          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FunctionEntry&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;(RF_EXCEPTION_HANDLER(FunctionEntry) != 0)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00079">79</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00162">RtlDispatchException()</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00883">RtlUnwind2()</a>, <a class="el" href="../../d7/d8/unwindr_8c-source.html#l00492">RtlUnwindReturn()</a>, and <a class="el" href="../../d7/d8/unwindr_8c-source.html#l00076">RtlUnwindRfp()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="alpha/exdsptch.c::RAISE_EXCEPTION" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define RAISE_EXCEPTION          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d2/d1/cttoken_8c.html#a18">Status</a>,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>ExceptionRecordt&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>{ \
    EXCEPTION_RECORD ExceptionRecordn; \
                                            \
    ExceptionRecordn.ExceptionCode = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>; \
    ExceptionRecordn.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>; \
    ExceptionRecordn.ExceptionRecord = ExceptionRecordt; \
    ExceptionRecordn.NumberParameters = 0; \
    <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a17">RtlRaiseException</a>(&amp;ExceptionRecordn); \
    }
</div></pre>
<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00065">65</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00162">RtlDispatchException()</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00883">RtlUnwind2()</a>, <a class="el" href="../../d7/d8/unwindr_8c-source.html#l00492">RtlUnwindReturn()</a>, and <a class="el" href="../../d7/d8/unwindr_8c-source.html#l00076">RtlUnwindRfp()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="alpha/exdsptch.c::Real" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define Real&nbsp;&nbsp;&nbsp;RealFramePointer          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00106">106</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="alpha/exdsptch.c::Virtual" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define Virtual&nbsp;&nbsp;&nbsp;VirtualFramePointer          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00105">105</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
Referenced by <a class="el" href="../../d8/d4/alpha_2flushtb_8c-source.html#l00231">KeFlushMultipleTb()</a>, <a class="el" href="../../d8/d4/alpha_2flushtb_8c-source.html#l00587">KeFlushMultipleTb64()</a>, <a class="el" href="../../d8/d4/alpha_2flushtb_8c-source.html#l00420">KeFlushSingleTb()</a>, <a class="el" href="../../d8/d4/alpha_2flushtb_8c-source.html#l00797">KeFlushSingleTb64()</a>, <a class="el" href="../../d8/d4/alpha_2flushtb_8c-source.html#l00353">KiFlushMultipleTbTarget()</a>, <a class="el" href="../../d8/d4/alpha_2flushtb_8c-source.html#l00733">KiFlushMultipleTbTarget64()</a>, <a class="el" href="../../d9/d4/i386_2flushtb_8c-source.html#l00589">KiFlushSingleTbSynchronous()</a>, <a class="el" href="../../d8/d4/alpha_2flushtb_8c-source.html#l00535">KiFlushSingleTbTarget()</a>, <a class="el" href="../../d8/d4/alpha_2flushtb_8c-source.html#l00932">KiFlushSingleTbTarget64()</a>, <a class="el" href="../../d9/d4/i386_2flushtb_8c-source.html#l00368">KiFlushTargetMultipleTb()</a>, <a class="el" href="../../d7/d1/mm_2ia64_2initia64_8c-source.html#l01871">MiGetKSegAddress()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00724">UdfAddToPcb()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00804">UdfCompletePcb()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00309">UdfDeletePcb()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00923">UdfEquivalentPcb()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l00367">UdfInitializePcb()</a>, <a class="el" href="../../d3/d5/allocsup_8c-source.html#l01017">UdfLookupPsnOfExtent()</a>, and <a class="el" href="../../d0/d7/udfs_2strucsup_8c-source.html#l00477">UdfUpdateVcbPhase0()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a24" doxytag="alpha/exdsptch.c::RtlAddFunctionTable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlAddFunctionTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRUNTIME_FUNCTION&nbsp;</td>
          <td class="mdname" nowrap> <em>FunctionTable</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>EntryCount</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02869">2869</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00137">DynamicFunctionTable</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00142">LoaderLock</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d6/config_2utils_2regutil_8c-source.html#l00022">RtlAllocateHeap</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>02876                    :
02877 
02878     Add a dynamic function table to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dynamic function table list. Dynamic
02879     function tables describe code generated at run-time. The dynamic function
02880     tables are searched via a call to <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a10">RtlLookupDynamicFunctionEntry</a>().
02881     Normally <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> invoked via calls to <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>().
02882 
02883     The FunctionTable entries need not be sorted in any particular order. The
02884     list <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> scanned <span class="keywordflow">for</span> a <a class="code" href="../../d3/d8/udfprocs_8h.html#a3">Min</a> and <a class="code" href="../../d3/d8/udfprocs_8h.html#a4">Max</a> address range and whether or not <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
02885     sorted. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> latter <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a10">RtlLookupDynamicFunctionEntry</a>() uses a binary
02886     search, otherwise it uses a linear search.
02887 
02888     The dynamic function entries will be searched only after a search
02889     through the static function entries associated with all current
02890     process images has failed.
02891 
02892 Arguments:
02893 
02894    FunctionTable       Address of an array of function entries where
02895                        each element is of type RUNTIME_FUNCTION.
02896 
02897    EntryCount          The number of function entries in the array
02898 
02899 Return value:
02900 
02901    TRUE                if RtlAddFunctionTable completed successfully
02902    FALSE               if RtlAddFunctionTable completed unsuccessfully
02903 
02904 --*/
02905 {
02906     PDYNAMIC_FUNCTION_TABLE pNew;
02907     PRUNTIME_FUNCTION FunctionEntry;
02908     ULONG i;
02909 
02910     <span class="keywordflow">if</span> (EntryCount == 0)
02911         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02912 
02913     <span class="comment">//</span>
02914     <span class="comment">// Make sure the link list is initialized;</span>
02915     <span class="comment">//</span>
02916 
02917     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02918        InitializeListHead(&amp;DynamicFunctionTable);
02919     }
02920 
02921     <span class="comment">//</span>
02922     <span class="comment">//  Allocate memory for this link list entry</span>
02923     <span class="comment">//</span>
02924 
02925     pNew = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( RtlProcessHeap(), 0, <span class="keyword">sizeof</span>(DYNAMIC_FUNCTION_TABLE) );
02926 
02927     <span class="keywordflow">if</span> (pNew != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02928         pNew-&gt;FunctionTable = FunctionTable;
02929         pNew-&gt;EntryCount = EntryCount;
02930         NtQuerySystemTime( &amp;pNew-&gt;TimeStamp );
02931 
02932         <span class="comment">//</span>
02933         <span class="comment">// Scan the function table for Minimum/Maximum and to determine</span>
02934         <span class="comment">// if it is sorted. If the latter, we can perform a binary search.</span>
02935         <span class="comment">//</span>
02936 
02937         FunctionEntry = FunctionTable;
02938         pNew-&gt;MinimumAddress = RF_BEGIN_ADDRESS(FunctionEntry);
02939         pNew-&gt;MaximumAddress = RF_END_ADDRESS(FunctionEntry);
02940         pNew-&gt;Sorted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02941         FunctionEntry++;
02942 
02943         <span class="keywordflow">for</span> (i = 1; i &lt; EntryCount; FunctionEntry++, i++) {
02944             <span class="keywordflow">if</span> (pNew-&gt;Sorted &amp;&amp; FunctionEntry-&gt;BeginAddress &lt; FunctionTable[i-1].BeginAddress) {
02945                 pNew-&gt;Sorted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02946             }
02947             <span class="keywordflow">if</span> (FunctionEntry-&gt;BeginAddress &lt; pNew-&gt;MinimumAddress) {
02948                 pNew-&gt;MinimumAddress = RF_BEGIN_ADDRESS(FunctionEntry);
02949             }
02950             <span class="keywordflow">if</span> (FunctionEntry-&gt;EndAddress &gt; pNew-&gt;MaximumAddress) {
02951                 pNew-&gt;MaximumAddress = RF_END_ADDRESS(FunctionEntry);
02952             }
02953         }
02954 
02955         <span class="comment">//</span>
02956         <span class="comment">// Insert the new entry in the dynamic function table list.</span>
02957         <span class="comment">// Protect the insertion with the loader lock.</span>
02958         <span class="comment">//</span>
02959 
02960         RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;LoaderLock);
02961         InsertTailList((PLIST_ENTRY)&amp;DynamicFunctionTable, (PLIST_ENTRY)pNew);
02962         RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;LoaderLock);
02963 
02964         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02965     } <span class="keywordflow">else</span> {
02966         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02967     }
02968 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="alpha/exdsptch.c::RtlDeleteFunctionTable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlDeleteFunctionTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PRUNTIME_FUNCTION&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>FunctionTable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02971">2971</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00137">DynamicFunctionTable</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00142">LoaderLock</a>, <a class="el" href="../../d4/d6/config_2utils_2regutil_8c-source.html#l00023">RtlFreeHeap</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>02974 {
02975 
02976 <span class="comment">/*++</span>
02977 <span class="comment"></span>
02978 <span class="comment">Routine Description:</span>
02979 <span class="comment"></span>
02980 <span class="comment">    Remove a dynamic function table from the dynamic function table list.</span>
02981 <span class="comment"></span>
02982 <span class="comment">Arguments:</span>
02983 <span class="comment"></span>
02984 <span class="comment">   FunctionTable       Address of an array of function entries that</span>
02985 <span class="comment">                       was passed in a previous call to RtlAddFunctionTable</span>
02986 <span class="comment"></span>
02987 <span class="comment">Return Value</span>
02988 <span class="comment"></span>
02989 <span class="comment">    TRUE - If function completed successfully</span>
02990 <span class="comment">    FALSE - If function completed unsuccessfully</span>
02991 <span class="comment"></span>
02992 <span class="comment">--*/</span>
02993 
02994     PDYNAMIC_FUNCTION_TABLE CurrentEntry;
02995     PLIST_ENTRY Head;
02996     PLIST_ENTRY Next;
02997     BOOLEAN <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02998 
02999     RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;LoaderLock);
03000 
03001     <span class="comment">//</span>
03002     <span class="comment">// Search the dynamic function table list for a match on the the function</span>
03003     <span class="comment">// table address.</span>
03004     <span class="comment">//</span>
03005 
03006     Head = &amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>;
03007     <span class="keywordflow">for</span> (Next = Head-&gt;Blink; Next != Head; Next = Next-&gt;Blink) {
03008         CurrentEntry = CONTAINING_RECORD(Next,DYNAMIC_FUNCTION_TABLE,Links);
03009         <span class="keywordflow">if</span> (CurrentEntry-&gt;FunctionTable == FunctionTable) {
03010             RemoveEntryList((PLIST_ENTRY)CurrentEntry);
03011             <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( RtlProcessHeap(), 0, CurrentEntry );
03012             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03013             <span class="keywordflow">break</span>;
03014         }
03015     }
03016 
03017     RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;LoaderLock);
03018     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03019 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="alpha/exdsptch.c::RtlDispatchException" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlDispatchException           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PEXCEPTION_RECORD&nbsp;</td>
          <td class="mdname" nowrap> <em>ExceptionRecord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PCONTEXT&nbsp;</td>
          <td class="mdname" nowrap> <em>ContextRecord</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00162">162</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d5/d9/cmconfig_8c-source.html#l00051">Count</a>, <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d6/d9/i386_2exdsptch_8c.html#a0">DISPATCHER_CONTEXT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00051">EXCEPTION_NESTED_CALL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00047">EXCEPTION_NONCONTINUABLE</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00050">EXCEPTION_STACK_INVALID</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00059">ExceptionContinueExecution</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00060">ExceptionContinueSearch</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00061">ExceptionNestedException</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d9/cmchek_8c-source.html#l00095">Index</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00079">IS_HANDLER_DEFINED</a>, <a class="el" href="../../d0/d2/ldrp_8h-source.html#l00370">NtGlobalFlag</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00065">RAISE_EXCEPTION</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00348">RtlLookupFunctionEntry()</a>, <a class="el" href="../../d6/d9/ntrtlppc_8h.html#a0">RtlpExecuteHandlerForException()</a>, <a class="el" href="../../d9/d9/rtl_2ia64_2miscc_8c-source.html#l00126">RtlpGetStackLimits()</a>, <a class="el" href="../../d4/d8/excptdbg_8c-source.html#l00065">RtlpLogExceptionHandler()</a>, <a class="el" href="../../d5/d9/ntrtlp_8h.html#a49">RtlpLogLastExceptionDisposition()</a>, <a class="el" href="../../d1/d6/ppc_2vunwind_8c-source.html#l00467">RtlVirtualUnwind()</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>00169                    :
00170 
00171     This function attempts to dispatch an exception to a frame based
00172     handler by searching backwards through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> stack based call frames.
00173     The search begins with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> frame specified in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context record and
00174     continues backward until either a handler <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> found that handles <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00175     exception, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> stack <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> found to be invalid (i.e., out of limits or
00176     unaligned), or <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call hierarchy <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> reached.
00177 
00178     As each frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> encountered, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PC where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> corresponding
00179     function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> determined and used to lookup exception handler information
00180     in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> runtime function table built by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> linker. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> respective
00181     routine has an exception handler, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handler <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00182     handler does not handle <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> prologue of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> routine
00183     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> executed backwards to <span class="stringliteral">"unwind"</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> effect of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> prologue and then
00184     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> next frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> examined.
00185 
00186 Arguments:
00187 
00188     ExceptionRecord - Supplies a pointer to an exception record.
00189 
00190     ContextRecord - Supplies a pointer to a context record.
00191 
00192 Return Value:
00193 
00194     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> handled by one of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> frame based handlers, then
00195     a value of <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned. Otherwise a value of <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.
00196 
00197 --*/
00198 
00199 {
00200 
00201     CONTEXT ContextRecord1;
00202     ULONG_PTR ControlPc;
00203 <span class="preprocessor">#if DBG</span>
00204 <span class="preprocessor"></span>    ULONG_PTR ControlPcHistory[PC_HISTORY_DEPTH];
00205     ULONG ControlPcHistoryIndex = 0;
00206 <span class="preprocessor">#endif</span>
00207 <span class="preprocessor"></span>    <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00208     EXCEPTION_DISPOSITION Disposition;
00209     FRAME_POINTERS EstablisherFrame;
00210     ULONG ExceptionFlags;
00211 <span class="preprocessor">#if DBG</span>
00212 <span class="preprocessor"></span>    LONG FrameDepth = 0;
00213 <span class="preprocessor">#endif</span>
00214 <span class="preprocessor"></span>    PRUNTIME_FUNCTION FunctionEntry;
00215     ULONG_PTR HighLimit;
00216     BOOLEAN InFunction;
00217     ULONG_PTR LowLimit;
00218     ULONG_PTR NestedFrame;
00219     ULONG_PTR NextPc;
00220 
00221     <span class="comment">//</span>
00222     <span class="comment">// Get current stack limits, copy the context record, get the initial</span>
00223     <span class="comment">// PC value, capture the exception flags, and set the nested exception</span>
00224     <span class="comment">// frame pointer.</span>
00225     <span class="comment">//</span>
00226     <span class="comment">// The initial PC value is obtained from ExceptionAddress rather than</span>
00227     <span class="comment">// from ContextRecord.Fir since some Alpha exceptions are asynchronous.</span>
00228     <span class="comment">//</span>
00229 
00230     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00231     RtlMoveMemory(&amp;ContextRecord1, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
00232     ControlPc = (ULONG_PTR)ExceptionRecord-&gt;ExceptionAddress;
00233 
00234 <span class="preprocessor">#if DBG</span>
00235 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((ULONG_PTR)ExceptionRecord-&gt;ExceptionAddress != (ULONG_PTR)ContextRecord-&gt;Fir) {
00236         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: ExceptionAddress = %p, Fir = %p\n"</span>,
00237                  ExceptionRecord-&gt;ExceptionAddress, (ULONG_PTR)ContextRecord-&gt;Fir);
00238     }
00239 <span class="preprocessor">#endif</span>
00240 <span class="preprocessor"></span>
00241     ExceptionFlags = ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00242     NestedFrame = 0;
00243 
00244 <span class="preprocessor">#if DBG</span>
00245 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION) {
00246         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\nRtlDispatchException(ExceptionRecord = %p, ContextRecord = %p)\n"</span>,
00247                  ExceptionRecord, ContextRecord);
00248         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: ControlPc = %p, ExceptionRecord-&gt;ExceptionCode = %lx\n"</span>,
00249                  ControlPc, ExceptionRecord-&gt;ExceptionCode);
00250     }
00251 <span class="preprocessor">#endif</span>
00252 <span class="preprocessor"></span>
00253     <span class="comment">//</span>
00254     <span class="comment">// Start with the frame specified by the context record and search</span>
00255     <span class="comment">// backwards through the call frame hierarchy attempting to find an</span>
00256     <span class="comment">// exception handler that will handle the exception.</span>
00257     <span class="comment">//</span>
00258 
00259     <span class="keywordflow">do</span> {
00260 <span class="preprocessor">#if DBG</span>
00261 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
00262             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: Loop: FrameDepth = %d, sp = %p, ControlPc = %p\n"</span>,
00263                      FrameDepth, (ULONG_PTR)ContextRecord1.IntSp, ControlPc);
00264             FrameDepth -= 1;
00265         }
00266 <span class="preprocessor">#endif</span>
00267 <span class="preprocessor"></span>
00268         <span class="comment">//</span>
00269         <span class="comment">// Lookup the function table entry using the point at which control</span>
00270         <span class="comment">// left the procedure.</span>
00271         <span class="comment">//</span>
00272 
00273         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00274 
00275         <span class="comment">//</span>
00276         <span class="comment">// If there is a function table entry for the routine, then virtually</span>
00277         <span class="comment">// unwind to the caller of the current routine to obtain the virtual</span>
00278         <span class="comment">// frame pointer of the establisher and check if there is an exception</span>
00279         <span class="comment">// handler for the frame.</span>
00280         <span class="comment">//</span>
00281 
00282         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00283             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00284                                       FunctionEntry,
00285                                       &amp;ContextRecord1,
00286                                       &amp;InFunction,
00287                                       &amp;EstablisherFrame,
00288                                       NULL);
00289 
00290             <span class="comment">//</span>
00291             <span class="comment">// If the virtual frame pointer is not within the specified stack</span>
00292             <span class="comment">// limits or the virtual frame pointer is unaligned, then set the</span>
00293             <span class="comment">// stack invalid flag in the exception record and return exception</span>
00294             <span class="comment">// not handled. Otherwise, check if the current routine has an</span>
00295             <span class="comment">// exception handler.</span>
00296             <span class="comment">//</span>
00297 
00298             <span class="keywordflow">if</span> ((EstablisherFrame.Virtual &lt; LowLimit) ||
00299                 (EstablisherFrame.Virtual &gt; HighLimit) ||
00300                 ((EstablisherFrame.Virtual &amp; 0xF) != 0)) {
00301 
00302 <span class="preprocessor">#if DBG</span>
00303 <span class="preprocessor"></span>                <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - stack invalid (exception).\n"</span>);
00304                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  EstablisherFrame.Virtual = %p, EstablisherFrame.Real = %p\n"</span>,
00305                          EstablisherFrame.Virtual, EstablisherFrame.Real);
00306                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  LowLimit = %p, HighLimit = %p\n"</span>,
00307                          LowLimit, HighLimit);
00308                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  NextPc = %p, ControlPc = %p\n"</span>,
00309                          NextPc, ControlPc);
00310                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Now setting EXCEPTION_STACK_INVALID flag.\n"</span>);
00311 <span class="preprocessor">#endif</span>
00312 <span class="preprocessor"></span>
00313                 ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a28">EXCEPTION_STACK_INVALID</a>;
00314                 <span class="keywordflow">break</span>;
00315 
00316             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a1">IS_HANDLER_DEFINED</a>(FunctionEntry) &amp;&amp; InFunction) {
00317 
00318                 ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00319 
00320 <span class="preprocessor">#if DBG</span>
00321 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
00322                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: ExceptionHandler = %p, HandlerData = %p\n"</span>,
00323                              FunctionEntry-&gt;ExceptionHandler, FunctionEntry-&gt;HandlerData);
00324                 }
00325 <span class="preprocessor">#endif</span>
00326 <span class="preprocessor"></span>
00327                 <span class="comment">//</span>
00328                 <span class="comment">// The frame has an exception handler. The handler must be</span>
00329                 <span class="comment">// executed by calling another routine that is written in</span>
00330                 <span class="comment">// assembler. This is required because up level addressing</span>
00331                 <span class="comment">// of the handler information is required when a nested</span>
00332                 <span class="comment">// exception is encountered.</span>
00333                 <span class="comment">//</span>
00334 
00335                 DispatcherContext.ControlPc = ControlPc;
00336                 DispatcherContext.FunctionEntry = FunctionEntry;
00337                 DispatcherContext.EstablisherFrame = EstablisherFrame.Virtual;
00338                 DispatcherContext.ContextRecord = ContextRecord;
00339                 ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00340 
00341                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00342                     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a48">RtlpLogExceptionHandler</a>(
00343                                     ExceptionRecord,
00344                                     ContextRecord,
00345                                     ControlPc,
00346                                     FunctionEntry,
00347                                     <span class="keyword">sizeof</span>(RUNTIME_FUNCTION));
00348                 }
00349 
00350 <span class="preprocessor">#if DBG</span>
00351 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
00352                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: calling RtlpExecuteHandlerForException, ControlPc = %lx Handler = %lx\n"</span>,
00353                              ControlPc, RF_EXCEPTION_HANDLER(FunctionEntry) );
00354                 }
00355 <span class="preprocessor">#endif</span>
00356 <span class="preprocessor"></span>                Disposition =
00357                     <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a0">RtlpExecuteHandlerForException</a>(ExceptionRecord,
00358                                                    EstablisherFrame.Virtual,
00359                                                    ContextRecord,
00360                                                    &amp;DispatcherContext,
00361                                                    RF_EXCEPTION_HANDLER(FunctionEntry));
00362 <span class="preprocessor">#if DBG</span>
00363 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
00364                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: RtlpExecuteHandlerForException returned Disposition = %lx\n"</span>, Disposition);
00365                 }
00366 <span class="preprocessor">#endif</span>
00367 <span class="preprocessor"></span>
00368                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00369                     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a49">RtlpLogLastExceptionDisposition</a>(Index, Disposition);
00370                 }
00371 
00372                 ExceptionFlags |=
00373                     (ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>);
00374 
00375                 <span class="comment">//</span>
00376                 <span class="comment">// If the current scan is within a nested context and the frame</span>
00377                 <span class="comment">// just examined is the end of the nested region, then clear</span>
00378                 <span class="comment">// the nested context frame and the nested exception flag in</span>
00379                 <span class="comment">// the exception flags.</span>
00380                 <span class="comment">//</span>
00381 
00382                 <span class="keywordflow">if</span> (NestedFrame == EstablisherFrame.Virtual) {
00383                     ExceptionFlags &amp;= (~<a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>);
00384                     NestedFrame = 0;
00385                 }
00386 
00387                 <span class="comment">//</span>
00388                 <span class="comment">// Case on the handler disposition.</span>
00389                 <span class="comment">//</span>
00390 
00391                 <span class="keywordflow">switch</span> (Disposition) {
00392 
00393                     <span class="comment">//</span>
00394                     <span class="comment">// The disposition is to continue execution.</span>
00395                     <span class="comment">//</span>
00396                     <span class="comment">// If the exception is not continuable, then raise the</span>
00397                     <span class="comment">// exception STATUS_NONCONTINUABLE_EXCEPTION. Otherwise</span>
00398                     <span class="comment">// return exception handled.</span>
00399                     <span class="comment">//</span>
00400 
00401                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a36">ExceptionContinueExecution</a> :
00402                     <span class="keywordflow">if</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>) != 0) {
00403                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_NONCONTINUABLE_EXCEPTION, ExceptionRecord);
00404 
00405                     } <span class="keywordflow">else</span> {
00406 <span class="preprocessor">#if DBG</span>
00407 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION) {
00408                             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: returning TRUE\n"</span>);
00409                         }
00410 <span class="preprocessor">#endif</span>
00411 <span class="preprocessor"></span>                        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00412                     }
00413 
00414                     <span class="comment">//</span>
00415                     <span class="comment">// The disposition is to continue the search.</span>
00416                     <span class="comment">//</span>
00417                     <span class="comment">// Get next frame address and continue the search.</span>
00418                     <span class="comment">//</span>
00419 
00420                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00421                     <span class="keywordflow">break</span>;
00422 
00423                     <span class="comment">//</span>
00424                     <span class="comment">// The disposition is nested exception.</span>
00425                     <span class="comment">//</span>
00426                     <span class="comment">// Set the nested context frame to the establisher frame</span>
00427                     <span class="comment">// address and set the nested exception flag in the</span>
00428                     <span class="comment">// exception flags.</span>
00429                     <span class="comment">//</span>
00430 
00431                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a38">ExceptionNestedException</a> :
00432                     ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>;
00433                     <span class="keywordflow">if</span> (DispatcherContext.EstablisherFrame &gt; NestedFrame) {
00434                         NestedFrame = DispatcherContext.EstablisherFrame;
00435                     }
00436 
00437                     <span class="keywordflow">break</span>;
00438 
00439                     <span class="comment">//</span>
00440                     <span class="comment">// All other disposition values are invalid.</span>
00441                     <span class="comment">//</span>
00442                     <span class="comment">// Raise invalid disposition exception.</span>
00443                     <span class="comment">//</span>
00444 
00445                 <span class="keywordflow">default</span> :
00446                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
00447                 }
00448             }
00449 
00450         } <span class="keywordflow">else</span> {
00451 
00452             <span class="comment">//</span>
00453             <span class="comment">// Set point at which control left the previous routine.</span>
00454             <span class="comment">//</span>
00455 
00456             NextPc = (ULONG_PTR)ContextRecord1.IntRa - 4;
00457 
00458             <span class="comment">//</span>
00459             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
00460             <span class="comment">// the function table is not correctly formed.</span>
00461             <span class="comment">//</span>
00462 
00463             <span class="keywordflow">if</span> (NextPc == ControlPc) {
00464 <span class="preprocessor">#if DBG</span>
00465 <span class="preprocessor"></span>                ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00466                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - malformed function table (exception).\n"</span>);
00467                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"ControlPc = %p, NextPc %p"</span>, NextPc, ControlPc);
00468                 <span class="keywordflow">for</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &lt; PC_HISTORY_DEPTH; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1) {
00469                     <span class="keywordflow">if</span> (ControlPcHistoryIndex &gt; 0) {
00470                         ControlPcHistoryIndex -= 1;
00471                         ControlPc = ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH];
00472                         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">", %p"</span>, ControlPc);
00473                     }
00474                 }
00475                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(ControlPcHistoryIndex == 0 ? <span class="stringliteral">".\n"</span> : <span class="stringliteral">", ...\n"</span>);
00476 <span class="preprocessor">#endif</span>
00477 <span class="preprocessor"></span>                <span class="keywordflow">break</span>;
00478             }
00479         }
00480 
00481         <span class="comment">//</span>
00482         <span class="comment">// Set point at which control left the previous routine.</span>
00483         <span class="comment">//</span>
00484 
00485 <span class="preprocessor">#if DBG</span>
00486 <span class="preprocessor"></span>        ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH] = ControlPc;
00487         ControlPcHistoryIndex += 1;
00488 <span class="preprocessor">#endif</span>
00489 <span class="preprocessor"></span>        ControlPc = NextPc;
00490 
00491     } <span class="keywordflow">while</span> ((ULONG_PTR)ContextRecord1.IntSp &lt; HighLimit);
00492 
00493     <span class="comment">//</span>
00494     <span class="comment">// Set final exception flags and return exception not handled.</span>
00495     <span class="comment">//</span>
00496 
00497     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00498 <span class="preprocessor">#if DBG</span>
00499 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION) {
00500         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: returning FALSE\n"</span>);
00501     }
00502 <span class="preprocessor">#endif</span>
00503 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00504 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="alpha/exdsptch.c::RtlGetFunctionTableListHead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PLIST_ENTRY RtlGetFunctionTableListHead           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">VOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02849">2849</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00137">DynamicFunctionTable</a>.
<p>
<pre class="fragment"><div>02855                    :
02856 
02857     Return <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dynamic function table list head.
02858 
02859 Return value:
02860 
02861     Address of dynamic function table list head.
02862 
02863 --*/
02864 {
02865     <span class="keywordflow">return</span> &amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>;
02866 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="alpha/exdsptch.c::RtlGetUnwindFunctionEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlGetUnwindFunctionEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>ControlPc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PRUNTIME_FUNCTION&nbsp;</td>
          <td class="mdname" nowrap> <em>FunctionEntry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PRUNTIME_FUNCTION&nbsp;</td>
          <td class="mdname" nowrap> <em>UnwindFunctionEntry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>StackAdjust</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>FixedReturn</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02536">2536</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02364">RtlLookupDirectFunctionEntry()</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l01455">RtlVirtualUnwind()</a>.
<p>
<pre class="fragment"><div>02545                    :
02546 
02547     This function returns a function entry (RUNTIME_FUNCTION) suitable
02548     for unwinding from ControlPc. It encapsulates the handling of primary
02549     and secondary function entries so that this processing is not duplicated
02550     in RtlVirtualUnwind and other similar functions.
02551 
02552 Arguments:
02553 
02554     ControlPc - Supplies the address where control left the specified
02555         function.
02556 
02557     FunctionEntry - Supplies the address of the function table entry for the
02558         specified function.
02559 
02560     UnwindFunctionEntry - Supplies the address of a function table entry which
02561         will be setup with appropriate fields for unwinding from ControlPc
02562 
02563     StackAdjust - Receives the optional stack adjustment amount specified
02564         in RF_NULL_CONTEXT type secondary function entries. Will be zero
02565         if no null-context stack adjustment is required.
02566         
02567     FixedReturn - Receives the return address specified by fixed-return functin
02568         entries. Will be zero if a fixed return address was not specified.
02569 
02570 Return Value:
02571 
02572     None.
02573 
02574 --*/
02575 
02576 {
02577     ULONG EntryType = 0;
02578     PRUNTIME_FUNCTION SecondaryFunctionEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02579     ULONG_PTR AlternateProlog;
02580 
02581     *FixedReturn = 0;
02582     *StackAdjust = 0;
02583     
02584     <span class="comment">// FunctionEntry should never be null, but if it is create one that</span>
02585     <span class="comment">// looks like a leaf entry for ControlPc</span>
02586 
02587     <span class="keywordflow">if</span> (FunctionEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02588 <span class="preprocessor">#if DBG</span>
02589 <span class="preprocessor"></span>        <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - Null function table entry for unwinding.\n"</span>);
02590 <span class="preprocessor">#endif</span>
02591 <span class="preprocessor"></span>        UnwindFunctionEntry-&gt;BeginAddress     = ControlPc;
02592         UnwindFunctionEntry-&gt;EndAddress       = ControlPc+4;
02593         UnwindFunctionEntry-&gt;ExceptionHandler = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02594         UnwindFunctionEntry-&gt;HandlerData      = 0;
02595         UnwindFunctionEntry-&gt;PrologEndAddress = ControlPc;
02596         <span class="keywordflow">return</span>;
02597     }
02598 
02599     <span class="comment">//</span>
02600     <span class="comment">// Because of the secondary-to-primary function entry indirection applied by</span>
02601     <span class="comment">// RtlLookupFunctionEntry() ControlPc may not be within the range described</span>
02602     <span class="comment">// by the supplied function entry. Call RtlLookupDirectFunctionEntry()</span>
02603     <span class="comment">// to recover the actual (secondary) function entry.  If we don't get a</span>
02604     <span class="comment">// valid associated function entry then process the unwind with the one</span>
02605     <span class="comment">// supplied, trusting that the caller has supplied the given entry intentionally.</span>
02606     <span class="comment">//</span>
02607     <span class="comment">// A secondary function entry is a RUNTIME_FUNCTION entry where</span>
02608     <span class="comment">// PrologEndAddress is not in the range of BeginAddress to EndAddress.</span>
02609     <span class="comment">// There are three types of secondary function entries. They are</span>
02610     <span class="comment">// distinquished by the Entry Type field (2 bits):</span>
02611     <span class="comment">//</span>
02612     <span class="comment">// RF_NOT_CONTIGUOUS - discontiguous code</span>
02613     <span class="comment">// RF_ALT_ENT_PROLOG - alternate entry point prologue</span>
02614     <span class="comment">// RF_NULL_CONTEXT   - null-context code</span>
02615     <span class="comment">//</span>
02616 
02617     <span class="keywordflow">if</span> ((ControlPc &lt;  RF_BEGIN_ADDRESS(FunctionEntry)) ||
02618         (ControlPc &gt;= RF_END_ADDRESS(FunctionEntry))) {
02619 
02620         <span class="comment">// ControlPC is not in the range of the supplied function entry.</span>
02621         <span class="comment">// Get the actual function entry which is expected to be the</span>
02622         <span class="comment">// associated secondary function entry.</span>
02623 
02624 <span class="preprocessor">#if DBG</span>
02625 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_FUNCTION_ENTRY) {
02626             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\nGetUnwindFunctionEntry:RtlLookupDirectFunctionEntry(ControlPc=%lx)\n"</span>, ControlPc);
02627         }
02628 <span class="preprocessor">#endif</span>
02629 <span class="preprocessor"></span>        SecondaryFunctionEntry = <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a22">RtlLookupDirectFunctionEntry</a>( ControlPc );
02630 
02631         <span class="keywordflow">if</span> (SecondaryFunctionEntry) {
02632             
02633 <span class="preprocessor">#if DBG</span>
02634 <span class="preprocessor"></span>            ShowRuntimeFunction(SecondaryFunctionEntry, <span class="stringliteral">"GetUnwindFunctionEntry: LookupDirectFunctionEntry"</span>);
02635 <span class="preprocessor">#endif</span>
02636 <span class="preprocessor"></span>            
02637             <span class="comment">// If this is a null-context tail region then unwind with a null-context-like descriptor</span>
02638 
02639             <span class="keywordflow">if</span> ((ControlPc &gt;= RF_END_ADDRESS(SecondaryFunctionEntry)-(RF_NULL_CONTEXT_COUNT(SecondaryFunctionEntry)*4)) &amp;&amp;
02640                 (ControlPc &lt;  RF_END_ADDRESS(SecondaryFunctionEntry))) {
02641 
02642                 <span class="comment">// Use the secondary function entry with PrologEndAddress = BeginAddress.</span>
02643                 <span class="comment">// This ensures that the prologue is not reverse executed.</span>
02644 
02645                 UnwindFunctionEntry-&gt;BeginAddress     = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02646                 UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(SecondaryFunctionEntry);
02647                 UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02648                 UnwindFunctionEntry-&gt;HandlerData      = 0;
02649                 UnwindFunctionEntry-&gt;PrologEndAddress = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02650                 <span class="keywordflow">return</span>;
02651             }
02652             
02653             <span class="keywordflow">if</span> ((SecondaryFunctionEntry-&gt;PrologEndAddress &lt; RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) ||
02654                 (SecondaryFunctionEntry-&gt;PrologEndAddress &gt; RF_END_ADDRESS(SecondaryFunctionEntry))) {
02655                 
02656                 <span class="comment">// Got a secondary function entry as expected. But if indirection doesn't point</span>
02657                 <span class="comment">// to FunctionEntry then ignore it and use the caller supplied FunctionEntry.</span>
02658 
02659                 <span class="keywordflow">if</span> (RF_PROLOG_END_ADDRESS(SecondaryFunctionEntry) != (ULONG_PTR)FunctionEntry) {
02660 <span class="preprocessor">#if DBG</span>
02661 <span class="preprocessor"></span>                    <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlGetUnwindFunctionEntry: unexpected secondary function entry from RtlLookupDirectFunctionEntry\n"</span>);
02662 <span class="preprocessor">#endif</span>
02663 <span class="preprocessor"></span>                    SecondaryFunctionEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02664                 }
02665             } <span class="keywordflow">else</span> {
02666 
02667                 <span class="comment">// Got a primary function entry. The only valid type is a</span>
02668                 <span class="comment">// Fixed Return Function Entry, which if present gets processed</span>
02669                 <span class="comment">// at the end.  Even if it is not a fixed return function entry,</span>
02670                 <span class="comment">// use it, since its prolog matches up with the control PC.</span>
02671 
02672                 FunctionEntry = SecondaryFunctionEntry;
02673                 SecondaryFunctionEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02674 
02675 <span class="preprocessor">#if DBG</span>
02676 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (!RF_FIXED_RETURN(FunctionEntry)) {
02677                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlGetUnwindFunctionEntry: unexpected primary function entry from RtlLookupDirectFunctionEntry\n"</span>);
02678                 }
02679 <span class="preprocessor">#endif</span>
02680 <span class="preprocessor"></span>            }
02681 <span class="preprocessor">#if DBG</span>
02682 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
02683             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"GetUnwindFunctionEntry: LookupDirectFunctionEntry returned NULL\n"</span>);
02684 <span class="preprocessor">#endif</span>
02685 <span class="preprocessor"></span>        }
02686         
02687     } <span class="keywordflow">else</span> {
02688 
02689         <span class="comment">// ControlPC is in the range of the supplied function entry.</span>
02690         <span class="comment">// Check if it is a secondary function entry. If so, get the</span>
02691         <span class="comment">// associated primary function entry.</span>
02692 
02693         <span class="comment">// If this is a null-context tail region then unwind with a null-context-like descriptor</span>
02694 
02695         <span class="keywordflow">if</span> ((ControlPc &gt;= RF_END_ADDRESS(FunctionEntry)-(RF_NULL_CONTEXT_COUNT(FunctionEntry)*4)) &amp;&amp;
02696             (ControlPc &lt;  RF_END_ADDRESS(FunctionEntry))) {
02697             
02698             <span class="comment">// Create the unwind function entry with PrologEndAddress = BeginAddress.</span>
02699             <span class="comment">// This ensures that the prologue is not reverse executed.</span>
02700 
02701             UnwindFunctionEntry-&gt;BeginAddress     = RF_BEGIN_ADDRESS(FunctionEntry);
02702             UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(FunctionEntry);
02703             UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02704             UnwindFunctionEntry-&gt;HandlerData      = 0;
02705             UnwindFunctionEntry-&gt;PrologEndAddress = RF_BEGIN_ADDRESS(FunctionEntry);
02706             <span class="keywordflow">return</span>;
02707         }
02708         
02709         <span class="keywordflow">if</span> ((FunctionEntry-&gt;PrologEndAddress &lt; RF_BEGIN_ADDRESS(FunctionEntry)) ||
02710             (FunctionEntry-&gt;PrologEndAddress &gt; RF_END_ADDRESS(FunctionEntry))) {
02711 
02712             SecondaryFunctionEntry = FunctionEntry;
02713             FunctionEntry = (PRUNTIME_FUNCTION)RF_PROLOG_END_ADDRESS(SecondaryFunctionEntry);
02714 <span class="preprocessor">#if DBG</span>
02715 <span class="preprocessor"></span>            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlGetUnwindFunctionEntry: received secondary function entry\n"</span>);
02716 <span class="preprocessor">#endif</span>
02717 <span class="preprocessor"></span>        }
02718     }
02719 
02720 <span class="preprocessor">#if DBG</span>
02721 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ControlPc &amp; 0x3) {
02722         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlGetUnwindFunctionEntry: Warning - Invalid ControlPc %lx for unwinding.\n"</span>, ControlPc);
02723     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (RF_BEGIN_ADDRESS(FunctionEntry) &gt;= RF_END_ADDRESS(FunctionEntry)) {
02724         ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlGetUnwindFunctionEntry: Warning - BeginAddress &lt; EndAddress."</span>);
02725     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (FunctionEntry-&gt;PrologEndAddress &lt; RF_BEGIN_ADDRESS(FunctionEntry)) {
02726         ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlGetUnwindFunctionEntry: Warning - PrologEndAddress &lt; BeginAddress."</span>);
02727     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (FunctionEntry-&gt;PrologEndAddress &gt; RF_END_ADDRESS(FunctionEntry)) {
02728         ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlGetUnwindFunctionEntry: Warning - PrologEndAddress &gt; EndAddress."</span>);
02729     }
02730 <span class="preprocessor">#endif</span>
02731 <span class="preprocessor"></span>
02732     <span class="comment">// FunctionEntry is now the primary function entry and if SecondaryFunctionEntry is</span>
02733     <span class="comment">// not NULL then it is the secondary function entry that contains the ControlPC. Setup a</span>
02734     <span class="comment">// copy of the FunctionEntry suitable for unwinding. By default use the supplied FunctionEntry.</span>
02735 
02736     <span class="keywordflow">if</span> (SecondaryFunctionEntry) {
02737 
02738         <span class="comment">// Extract the secondary function entry type.</span>
02739 
02740         EntryType = RF_ENTRY_TYPE(SecondaryFunctionEntry);
02741 
02742         <span class="keywordflow">if</span> (EntryType == RF_NOT_CONTIGUOUS) {
02743             <span class="comment">// The exception happened in the body of the procedure but in a non-contiguous</span>
02744             <span class="comment">// section of code. Regardless of what entry point was used, it is normally valid</span>
02745             <span class="comment">// to unwind using the primary entry point prologue. The only exception is when an</span>
02746             <span class="comment">// alternate prologue is specified However, there may be an</span>
02747             <span class="comment">// alternate prologue end addresss specified in which case unwind using this</span>
02748             <span class="comment">// block as though it were the primary.</span>
02749     
02750             AlternateProlog = RF_ALT_PROLOG(SecondaryFunctionEntry);
02751     
02752             <span class="keywordflow">if</span> ((AlternateProlog &gt;= RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) &amp;&amp;
02753                 (AlternateProlog &lt;  RF_END_ADDRESS(SecondaryFunctionEntry))) {
02754 
02755                 <span class="comment">// If the control PC is in the alternate prologue, use the secondary.</span>
02756                 <span class="comment">// The control Pc is not in procedure context.</span>
02757 
02758                 <span class="keywordflow">if</span> ((ControlPc &gt;= RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) &amp;&amp;
02759                     (ControlPc &lt;  AlternateProlog)) {
02760 
02761                     UnwindFunctionEntry-&gt;BeginAddress     = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02762                     UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(SecondaryFunctionEntry);
02763                     UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02764                     UnwindFunctionEntry-&gt;HandlerData      = 0;
02765                     UnwindFunctionEntry-&gt;PrologEndAddress = AlternateProlog;
02766                     <span class="keywordflow">return</span>;
02767                 }
02768             }
02769 
02770             <span class="comment">// Fall out of the if statement to pick up the primary function entry below.</span>
02771             <span class="comment">// This code is in-procedure-context and subject to the primary's prologue</span>
02772             <span class="comment">// and exception handlers.</span>
02773         
02774         
02775         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (EntryType == RF_ALT_ENT_PROLOG) {
02776             
02777             <span class="comment">// Exception occured in an alternate entry point prologue.</span>
02778             <span class="comment">// Use the secondary function entry with a fixed-up PrologEndAddress.</span>
02779 
02780             UnwindFunctionEntry-&gt;BeginAddress     = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02781             UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(SecondaryFunctionEntry);
02782             UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02783             UnwindFunctionEntry-&gt;HandlerData      = 0;
02784             UnwindFunctionEntry-&gt;PrologEndAddress = RF_END_ADDRESS(UnwindFunctionEntry);
02785             
02786             <span class="comment">// Check for an alternate prologue.</span>
02787             
02788             AlternateProlog = RF_ALT_PROLOG(SecondaryFunctionEntry);
02789             <span class="keywordflow">if</span> (AlternateProlog &gt;= UnwindFunctionEntry-&gt;BeginAddress &amp;&amp;
02790                 AlternateProlog &lt;  UnwindFunctionEntry-&gt;EndAddress ) {
02791                 <span class="comment">// The prologue is only part of the procedure</span>
02792                 UnwindFunctionEntry-&gt;PrologEndAddress = AlternateProlog;
02793             }
02794 
02795             <span class="keywordflow">return</span>;
02796         
02797         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (EntryType == RF_NULL_CONTEXT) {
02798 
02799             <span class="comment">// Exception occured in null-context code associated with a primary function.</span>
02800             <span class="comment">// Use the secondary function entry with a PrologEndAddress = BeginAddress.</span>
02801             <span class="comment">// There is no prologue for null-context code.</span>
02802 
02803             *StackAdjust = RF_STACK_ADJUST(SecondaryFunctionEntry);
02804             UnwindFunctionEntry-&gt;BeginAddress     = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02805             UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(SecondaryFunctionEntry);
02806             UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02807             UnwindFunctionEntry-&gt;HandlerData      = 0;
02808             UnwindFunctionEntry-&gt;PrologEndAddress = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02809             <span class="keywordflow">return</span>;
02810         }
02811 
02812     }
02813     
02814     <span class="comment">// Use the primary function entry</span>
02815     
02816     *UnwindFunctionEntry = *FunctionEntry;
02817     UnwindFunctionEntry-&gt;EndAddress = RF_END_ADDRESS(UnwindFunctionEntry);  <span class="comment">// Remove null-context count</span>
02818     
02819     <span class="comment">// If the primary has a fixed return address, pull that out now.</span>
02820 
02821     <span class="keywordflow">if</span> (RF_IS_FIXED_RETURN(FunctionEntry)) {
02822         *FixedReturn = RF_FIXED_RETURN(FunctionEntry);
02823         UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02824         UnwindFunctionEntry-&gt;HandlerData      = 0;
02825     }
02826 
02827     <span class="comment">// If the ControlPc is in the primary Null context, return null context.</span>
02828     <span class="comment">// Otherwise, remove Null context count</span>
02829 
02830     <span class="keywordflow">if</span> ((ControlPc &gt;= RF_END_ADDRESS(FunctionEntry)-(RF_NULL_CONTEXT_COUNT(FunctionEntry)*4)) &amp;&amp;
02831         (ControlPc &lt;  RF_END_ADDRESS(FunctionEntry))) {
02832 
02833         <span class="comment">// Exception occured in null-context code associated with a primary function.</span>
02834         <span class="comment">// Create the unwind function entry with a PrologEndAddress = BeginAddress.</span>
02835         <span class="comment">// This ensures that the prologue is not reverse executed.</span>
02836 
02837         UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(FunctionEntry);
02838         UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02839         UnwindFunctionEntry-&gt;HandlerData      = 0;
02840         UnwindFunctionEntry-&gt;PrologEndAddress = RF_BEGIN_ADDRESS(FunctionEntry);
02841     }
02842     <span class="keywordflow">else</span> {
02843         UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(FunctionEntry);
02844     }
02845 }
<span class="preprocessor">#if !defined(NTOS_KERNEL_RUNTIME)</span>
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="alpha/exdsptch.c::RtlLookupDirectFunctionEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PRUNTIME_FUNCTION RtlLookupDirectFunctionEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG_PTR&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ControlPc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02364">2364</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d8/d8/ia64_2exdsptch_8c-source.html#l01583">RtlLookupDynamicFunctionEntry()</a>, and <a class="el" href="../../d7/d9/ia64_2exdsptch_8c.html#a9">RtlLookupStaticFunctionEntry()</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02536">RtlGetUnwindFunctionEntry()</a>, and <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00507">RtlLookupFunctionEntry()</a>.
<p>
<pre class="fragment"><div>02370                    :
02371 
02372     This function searches <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> currently active function tables (<span class="keyword">static</span> and dynamic)
02373     <span class="keywordflow">for</span> an entry that corresponds to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified PC value.
02374 
02375 Arguments:
02376 
02377     ControlPc - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of an instruction within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
02378         function.
02379 
02380 Return Value:
02381 
02382     If there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> no entry in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function table <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified PC, then
02383     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned. Otherwise, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function table entry
02384     that corresponds to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified PC <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.
02385 
02386 --*/
02387 
02388 {
02389     PRUNTIME_FUNCTION FunctionEntry;
02390     BOOLEAN InImage;
02391 
02392     <span class="comment">//</span>
02393     <span class="comment">// look for function entry in static function tables</span>
02394     <span class="comment">//</span>
02395 
02396     FunctionEntry = <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a9">RtlLookupStaticFunctionEntry</a>( ControlPc, &amp;InImage );
02397 
02398 <span class="preprocessor">#if !defined(NTOS_KERNEL_RUNTIME)</span>
02399 <span class="preprocessor"></span>    <span class="comment">//</span>
02400     <span class="comment">// If not in static image range and no static function entry</span>
02401     <span class="comment">// found then look for a dynamic function entry</span>
02402     <span class="comment">//</span>
02403 
02404     <span class="keywordflow">if</span> (FunctionEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; !InImage) {
02405 
02406         FunctionEntry = <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a10">RtlLookupDynamicFunctionEntry</a>( ControlPc );
02407 
02408     }
02409 <span class="preprocessor">#endif</span>
02410 <span class="preprocessor"></span>
02411 <span class="preprocessor">#if DBG</span>
02412 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_FUNCTION_ENTRY) {
02413         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlLookupDirectFunctionEntry: returning FunctionEntry = %p\n"</span>, FunctionEntry);
02414     }
02415 <span class="preprocessor">#endif</span>
02416 <span class="preprocessor"></span>
02417     <span class="keywordflow">return</span> FunctionEntry;
02418 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="alpha/exdsptch.c::RtlLookupDynamicFunctionEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PRUNTIME_FUNCTION RtlLookupDynamicFunctionEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG_PTR&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ControlPc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l03022">3022</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00137">DynamicFunctionTable</a>, <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00142">LoaderLock</a>, and <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>.
<p>
<pre class="fragment"><div>03028                    :
03029 
03030   This function searches through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dynamic function entry
03031   tables and returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function entry address that corresponds
03032   to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified ControlPc. This routine does NOT perform <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
03033   secondary function entry indirection. That <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> performed
03034   by <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>().
03035 
03036   Argument:
03037 
03038      ControlPc           Supplies a ControlPc.
03039 
03040   Return Value
03041 
03042      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> - No function entry found that contains <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> ControlPc.
03043 
03044      NON-<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> - Address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function entry that describes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
03045                 code containing ControlPC.
03046 
03047 --*/
03048 
03049 {
03050     PDYNAMIC_FUNCTION_TABLE CurrentEntry;
03051     PLIST_ENTRY Next,Head;
03052     PRUNTIME_FUNCTION FunctionTable;
03053     PRUNTIME_FUNCTION FunctionEntry;
03054     LONG High;
03055     LONG Low;
03056     LONG Middle;
03057 
03058     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
03059         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03060 
03061     <span class="keywordflow">if</span> (RtlTryEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;LoaderLock) ) {
03062 
03063         <span class="comment">//</span>
03064         <span class="comment">//  Search the tree starting from the head, continue until the entry</span>
03065         <span class="comment">//  is found or we reach the end of the list.</span>
03066         <span class="comment">//</span>
03067 
03068         Head = &amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>;
03069         <span class="keywordflow">for</span> (Next = Head-&gt;Blink; Next != Head; Next = Next-&gt;Blink) {
03070             CurrentEntry = CONTAINING_RECORD(Next,DYNAMIC_FUNCTION_TABLE,Links);
03071             FunctionTable = CurrentEntry-&gt;FunctionTable;
03072 
03073             <span class="comment">//</span>
03074             <span class="comment">// Check if the ControlPC is within the range of this function table</span>
03075             <span class="comment">//</span>
03076 
03077             <span class="keywordflow">if</span> ((ControlPc &gt;= CurrentEntry-&gt;MinimumAddress) &amp;&amp;
03078                 (ControlPc &lt;  CurrentEntry-&gt;MaximumAddress) ) {
03079 
03080                 <span class="comment">// If this function table is sorted do a binary search.</span>
03081 
03082                 <span class="keywordflow">if</span> (CurrentEntry-&gt;Sorted) {
03083 
03084                     <span class="comment">//</span>
03085                     <span class="comment">// Perform binary search on the function table for a function table</span>
03086                     <span class="comment">// entry that subsumes the specified PC.</span>
03087                     <span class="comment">//</span>
03088 
03089                     Low = 0;
03090                     High = CurrentEntry-&gt;EntryCount -1 ;
03091                     <span class="keywordflow">while</span> (High &gt;= Low) {
03092 
03093                         <span class="comment">//</span>
03094                         <span class="comment">// Compute next probe index and test entry. If the specified PC</span>
03095                         <span class="comment">// is greater than of equal to the beginning address and less</span>
03096                         <span class="comment">// than the ending address of the function table entry, then</span>
03097                         <span class="comment">// return the address of the function table entry. Otherwise,</span>
03098                         <span class="comment">// continue the search.</span>
03099                         <span class="comment">//</span>
03100 
03101                         Middle = (Low + High) &gt;&gt; 1;
03102                         FunctionEntry = &amp;FunctionTable[Middle];
03103                         <span class="keywordflow">if</span> (ControlPc &lt; RF_BEGIN_ADDRESS(FunctionEntry)) {
03104                             High = Middle - 1;
03105 
03106                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ControlPc &gt;= RF_END_ADDRESS(FunctionEntry)) {
03107                             Low = Middle + 1;
03108 
03109                         } <span class="keywordflow">else</span> {
03110 <span class="preprocessor">#if DBG</span>
03111 <span class="preprocessor"></span>                            ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlLookupDynamicFunctionEntry: binary search"</span> );
03112 <span class="preprocessor">#endif</span>
03113 <span class="preprocessor"></span>                            RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;LoaderLock);
03114                             <span class="keywordflow">return</span> FunctionEntry;
03115                         }
03116                     }
03117 
03118                 } <span class="keywordflow">else</span> {    <span class="comment">// Not sorted. Do linear search.</span>
03119 
03120                     PRUNTIME_FUNCTION LastFunctionEntry = &amp;FunctionTable[CurrentEntry-&gt;EntryCount];
03121 
03122                     <span class="keywordflow">for</span> (FunctionEntry = FunctionTable; FunctionEntry &lt; LastFunctionEntry; FunctionEntry++) {
03123                         <span class="keywordflow">if</span> ((ControlPc &gt;= RF_BEGIN_ADDRESS(FunctionEntry)) &amp;&amp;
03124                             (ControlPc &lt;  RF_END_ADDRESS(FunctionEntry))) {
03125 <span class="preprocessor">#if DBG</span>
03126 <span class="preprocessor"></span>                            ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlLookupDynamicFunctionEntry: linear search"</span> );
03127 <span class="preprocessor">#endif</span>
03128 <span class="preprocessor"></span>                            RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;LoaderLock);
03129                             <span class="keywordflow">return</span> FunctionEntry;
03130                         }
03131                     }
03132                 } <span class="comment">// binary/linear search</span>
03133             } <span class="comment">// if in range</span>
03134         } <span class="comment">// for (... Next != Head ...)</span>
03135 
03136         RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;LoaderLock);
03137     } <span class="comment">// LoaderLock</span>
03138 
03139     
03140     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03141 }
<span class="preprocessor">#endif</span>
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="alpha/exdsptch.c::RtlLookupFunctionEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PRUNTIME_FUNCTION RtlLookupFunctionEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG_PTR&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ControlPc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00507">507</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02364">RtlLookupDirectFunctionEntry()</a>, and <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00348">RtlLookupFunctionEntry()</a>.
<p>
<pre class="fragment"><div>00513                    :
00514 
00515     This function searches <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> currently active function tables (<span class="keyword">static</span> and dynamic)
00516     <span class="keywordflow">for</span> an entry that corresponds to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified PC value. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entry <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <span class="keywordflow">for</span> a
00517     secondary function entry then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> primary function table entry <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained
00518     via an indirection through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PrologEndAddress. <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a22">RtlLookupDirectFunctionEntry</a>()
00519     performs the same function without the indirection to the primary function table.
00520     Because RtlLookupFunctionEntry() always returns the primary function entry, it
00521     has the property such that
00522 
00523         RtlLookupFunctionEntry(Pc1) == RtlLookupFunctionEntry(Pc2)
00524 
00525         implies
00526 
00527         Pc1 and Pc2 are in the same procedure.
00528 
00529 Arguments:
00530 
00531     ControlPc - Supplies the address of an instruction within the specified
00532         function.
00533 
00534 Return Value:
00535 
00536     If there is no entry in the function table for the specified PC, then
00537     NULL is returned. Otherwise, the address of the primary function table
00538     entry that corresponds to the specified PC is returned.
00539 
00540 --*/
00541 
00542 {
00543     PRUNTIME_FUNCTION FunctionEntry;
00544 
00545     <span class="comment">// Look for a static or dynamic function entry</span>
00546 
00547     FunctionEntry = <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a22">RtlLookupDirectFunctionEntry</a>( ControlPc );
00548 
00549     <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00550 
00551         <span class="comment">//</span>
00552         <span class="comment">// The capability exists for more than one function entry</span>
00553         <span class="comment">// to map to the same function. This permits a function to</span>
00554         <span class="comment">// have discontiguous code segments described by separate</span>
00555         <span class="comment">// function table entries. If the ending prologue address</span>
00556         <span class="comment">// is not within the limits of the begining and ending</span>
00557         <span class="comment">// address of the function able entry, then the prologue</span>
00558         <span class="comment">// ending address is the address of the primary function</span>
00559         <span class="comment">// table entry that accurately describes the ending prologue</span>
00560         <span class="comment">// address.</span>
00561         <span class="comment">//</span>
00562 
00563         <span class="keywordflow">if</span> ((RF_PROLOG_END_ADDRESS(FunctionEntry) &lt;  RF_BEGIN_ADDRESS(FunctionEntry)) ||
00564             (RF_PROLOG_END_ADDRESS(FunctionEntry) &gt;= RF_END_ADDRESS(FunctionEntry))) {
00565 <span class="preprocessor">#if DBG</span>
00566 <span class="preprocessor"></span>            ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlLookupFunctionEntry: secondary entry"</span> );
00567 <span class="preprocessor">#endif</span>
00568 <span class="preprocessor"></span>            <span class="comment">// Officially the PrologEndAddress field in secondary function entries</span>
00569             <span class="comment">// doesn't have the exception mode bits there have been some versions</span>
00570             <span class="comment">// of alpha tools that put them there. Strip them off to be safe.</span>
00571 
00572             FunctionEntry = (PRUNTIME_FUNCTION)RF_PROLOG_END_ADDRESS(FunctionEntry);
00573         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (RF_IS_FIXED_RETURN(FunctionEntry)) {
00574             ULONG_PTR FixedReturn = RF_FIXED_RETURN(FunctionEntry);
00575     
00576 <span class="preprocessor">#if DBG</span>
00577 <span class="preprocessor"></span>            ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"LookupFunctionEntry: fixed return entry"</span>);
00578 <span class="preprocessor">#endif</span>
00579 <span class="preprocessor"></span>            <span class="comment">// Recursively call LookupFunctionEntry to ensure we get a primary function entry here.</span>
00580             <span class="comment">// Check for incorrectly formed function entry where the fixed return points to itself.</span>
00581     
00582             <span class="keywordflow">if</span> ((FixedReturn &lt;  RF_BEGIN_ADDRESS(FunctionEntry)) ||
00583                 (FixedReturn &gt;= RF_END_ADDRESS(FunctionEntry))) {
00584                 FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>( RF_FIXED_RETURN(FunctionEntry) );
00585             }
00586         }
00587 <span class="preprocessor">#if DBG</span>
00588 <span class="preprocessor"></span>        <span class="keywordflow">else</span> {
00589             ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlLookupFunctionEntry: primary entry"</span> );
00590         }
00591 <span class="preprocessor">#endif</span>
00592 <span class="preprocessor"></span>    }
00593 
00594 <span class="preprocessor">#if DBG</span>
00595 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_FUNCTION_ENTRY) {
00596         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlLookupFunctionEntry: returning FunctionEntry = %lx\n"</span>, FunctionEntry);
00597     }
00598 <span class="preprocessor">#endif</span>
00599 <span class="preprocessor"></span>    <span class="keywordflow">return</span> FunctionEntry;
00600 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="alpha/exdsptch.c::RtlLookupStaticFunctionEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PRUNTIME_FUNCTION RtlLookupStaticFunctionEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>ControlPc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PBOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>InImage</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02421">2421</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d9/d8/imagedir_8c-source.html#l00250">RtlImageDirectoryEntryToData()</a>, <a class="el" href="../../d7/d3/pctohdr_8c-source.html#l00042">RtlPcToFileHeader()</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>02428                    :
02429 
02430     This function searches <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> currently active <span class="keyword">static</span> function tables <span class="keywordflow">for</span> an
02431     entry that corresponds to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified PC value.
02432 
02433 Arguments:
02434 
02435     ControlPc - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of an instruction within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
02436         function.
02437 
02438     InImage - Address to recieve a flag indicating whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> ControlPc
02439         was in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> range of a <span class="keyword">static</span> function table
02440 
02441 Return Value:
02442 
02443     If there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> no entry in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">static</span> function tables <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified PC,
02444     then <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned. Otherwise, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function table entry
02445     that corresponds to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified PC <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.
02446 
02447 --*/
02448 
02449 {
02450     PRUNTIME_FUNCTION FunctionEntry;
02451     PRUNTIME_FUNCTION FunctionTable;
02452     ULONG SizeOfExceptionTable;
02453     LONG High;
02454     PVOID ImageBase;
02455     LONG Low;
02456     LONG Middle;
02457 
02458     <span class="comment">//</span>
02459     <span class="comment">// Search for the image that includes the specified PC value.</span>
02460     <span class="comment">//</span>
02461 
02462     ImageBase = <a class="code" href="../../d6/d4/pctohdr_8c.html#a1">RtlPcToFileHeader</a>((PVOID)ControlPc, &amp;ImageBase);
02463 
02464 <span class="preprocessor">#if DBG</span>
02465 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_FUNCTION_ENTRY) {
02466         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlLookupStaticFunctionEntry(ControlPc = %p) ImageBase = %p\n"</span>,
02467                  ControlPc, ImageBase);
02468     }
02469 <span class="preprocessor">#endif</span>
02470 <span class="preprocessor"></span>
02471     <span class="comment">//</span>
02472     <span class="comment">// If an image is found that includes the specified PC, then locate the</span>
02473     <span class="comment">// function table for the image.</span>
02474     <span class="comment">//</span>
02475 
02476     *InImage = (ImageBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02477     FunctionEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02478     <span class="keywordflow">if</span> (ImageBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02479         FunctionTable = (PRUNTIME_FUNCTION)<a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(
02480                          ImageBase, TRUE, IMAGE_DIRECTORY_ENTRY_EXCEPTION,
02481                          &amp;SizeOfExceptionTable);
02482 <span class="preprocessor">#if DBG</span>
02483 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_FUNCTION_ENTRY_DETAIL) {
02484             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlLookupStaticFunctionEntry: FunctionTable = %p, SizeOfExceptionTable = %lx\n"</span>,
02485                      FunctionTable, SizeOfExceptionTable);
02486         }
02487 <span class="preprocessor">#endif</span>
02488 <span class="preprocessor"></span>
02489         <span class="comment">//</span>
02490         <span class="comment">// If a function table is located, then search the function table</span>
02491         <span class="comment">// for a function table entry for the specified PC.</span>
02492         <span class="comment">//</span>
02493 
02494         <span class="keywordflow">if</span> (FunctionTable != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02495 
02496             <span class="comment">//</span>
02497             <span class="comment">// Initialize search indicies.</span>
02498             <span class="comment">//</span>
02499 
02500             Low = 0;
02501             High = (SizeOfExceptionTable / <span class="keyword">sizeof</span>(RUNTIME_FUNCTION)) - 1;
02502 
02503             <span class="comment">//</span>
02504             <span class="comment">// Perform binary search on the function table for a function table</span>
02505             <span class="comment">// entry that subsumes the specified PC.</span>
02506             <span class="comment">//</span>
02507 
02508             <span class="keywordflow">while</span> (High &gt;= Low) {
02509 
02510                 <span class="comment">//</span>
02511                 <span class="comment">// Compute next probe index and test entry. If the specified PC</span>
02512                 <span class="comment">// is greater than of equal to the beginning address and less</span>
02513                 <span class="comment">// than the ending address of the function table entry, then</span>
02514                 <span class="comment">// return the address of the function table entry. Otherwise,</span>
02515                 <span class="comment">// continue the search.</span>
02516                 <span class="comment">//</span>
02517 
02518                 Middle = (Low + High) &gt;&gt; 1;
02519                 FunctionEntry = &amp;FunctionTable[Middle];
02520                 <span class="keywordflow">if</span> (ControlPc &lt; RF_BEGIN_ADDRESS(FunctionEntry)) {
02521                     High = Middle - 1;
02522 
02523                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ControlPc &gt;= RF_END_ADDRESS(FunctionEntry)) {
02524                     Low = Middle + 1;
02525 
02526                 } <span class="keywordflow">else</span> {
02527                     <span class="keywordflow">return</span> FunctionEntry;
02528                 }
02529             } <span class="comment">// while (High &gt;= Low)</span>
02530         } <span class="comment">// FunctionTable != NULL</span>
02531     } <span class="comment">// ImageBase != NULL</span>
02532     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02533 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="alpha/exdsptch.c::RtlpRaiseException" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpRaiseException           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PEXCEPTION_RECORD&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ExceptionRecord</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00643">643</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00348">RtlLookupFunctionEntry()</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00563">RtlRaiseStatus()</a>, <a class="el" href="../../d1/d6/ppc_2vunwind_8c-source.html#l00467">RtlVirtualUnwind()</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>00649                    :
00650 
00651     This function raises a software exception by building a context record
00652     and calling <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> raise exception system service.
00653 
00654 Arguments:
00655 
00656     ExceptionRecord - Supplies a pointer to an exception record.
00657 
00658 Return Value:
00659 
00660     None.
00661 
00662 --*/
00663 
00664 {
00665 
00666     ULONG_PTR ControlPc;
00667     CONTEXT ContextRecord;
00668     FRAME_POINTERS EstablisherFrame;
00669     PRUNTIME_FUNCTION FunctionEntry;
00670     BOOLEAN InFunction;
00671     ULONG_PTR NextPc;
00672     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00673 
00674     <span class="comment">//</span>
00675     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00676     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00677     <span class="comment">// call the raise exception system service.</span>
00678     <span class="comment">//</span>
00679 
00680     RtlCaptureContext(&amp;ContextRecord);
00681     ControlPc = (ULONG_PTR)ContextRecord.IntRa - 4;
00682     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00683     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00684                               FunctionEntry,
00685                               &amp;ContextRecord,
00686                               &amp;InFunction,
00687                               &amp;EstablisherFrame,
00688                               NULL);
00689 
00690     ContextRecord.Fir = (ULONGLONG)(LONG_PTR)NextPc + 4;
00691     ExceptionRecord-&gt;ExceptionAddress = (PVOID)ContextRecord.Fir;
00692     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(ExceptionRecord, &amp;ContextRecord, TRUE);
00693 
00694     <span class="comment">//</span>
00695     <span class="comment">// There should never be a return from this system service unless</span>
00696     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00697     <span class="comment">// exception specifying the status value returned.</span>
00698     <span class="comment">//</span>
00699 
00700     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(Status);
00701     <span class="keywordflow">return</span>;
00702 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="alpha/exdsptch.c::RtlpRaiseStatus" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpRaiseStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN NTSTATUS&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Status</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00745">745</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00047">EXCEPTION_NONCONTINUABLE</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00348">RtlLookupFunctionEntry()</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00563">RtlRaiseStatus()</a>, <a class="el" href="../../d1/d6/ppc_2vunwind_8c-source.html#l00467">RtlVirtualUnwind()</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>00751                    :
00752 
00753     This function raises an exception with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified status value. The
00754     exception <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> marked as noncontinuable with no parameters.
00755 
00756 Arguments:
00757 
00758     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status value to be used as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception code
00759         <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be raised.
00760 
00761 Return Value:
00762 
00763     None.
00764 
00765 --*/
00766 
00767 {
00768 
00769     ULONG_PTR ControlPc;
00770     CONTEXT ContextRecord;
00771     FRAME_POINTERS EstablisherFrame;
00772     EXCEPTION_RECORD ExceptionRecord;
00773     PRUNTIME_FUNCTION FunctionEntry;
00774     BOOLEAN InFunction;
00775     ULONG_PTR NextPc;
00776 
00777     <span class="comment">//</span>
00778     <span class="comment">// Construct an exception record.</span>
00779     <span class="comment">//</span>
00780 
00781     ExceptionRecord.ExceptionCode = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00782     ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00783     ExceptionRecord.NumberParameters = 0;
00784     ExceptionRecord.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00785 
00786     <span class="comment">//</span>
00787     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00788     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00789     <span class="comment">// call the raise exception system service.</span>
00790     <span class="comment">//</span>
00791 
00792     RtlCaptureContext(&amp;ContextRecord);
00793     ControlPc = (ULONG_PTR)ContextRecord.IntRa - 4;
00794     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00795     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00796                               FunctionEntry,
00797                               &amp;ContextRecord,
00798                               &amp;InFunction,
00799                               &amp;EstablisherFrame,
00800                               NULL);
00801 
00802     ContextRecord.Fir = (ULONGLONG)(LONG_PTR)NextPc + 4;
00803     ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.Fir;
00804     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(&amp;ExceptionRecord, &amp;ContextRecord, TRUE);
00805 
00806     <span class="comment">//</span>
00807     <span class="comment">// There should never be a return from this system service unless</span>
00808     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00809     <span class="comment">// exception specifying the status value returned.</span>
00810     <span class="comment">//</span>
00811 
00812     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(Status);
00813     <span class="keywordflow">return</span>;
00814 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="alpha/exdsptch.c::RtlpVirtualUnwind" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG_PTR RtlpVirtualUnwind           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>ControlPc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PRUNTIME_FUNCTION&nbsp;</td>
          <td class="mdname" nowrap> <em>FunctionEntry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PCONTEXT&nbsp;</td>
          <td class="mdname" nowrap> <em>ContextRecord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PBOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>InFunction</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PFRAME_POINTERS&nbsp;</td>
          <td class="mdname" nowrap> <em>EstablisherFrame</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02284">2284</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d1/d6/ppc_2vunwind_8c-source.html#l00467">RtlVirtualUnwind()</a>.
<p>
<pre class="fragment"><div>02294                    :
02295 
02296     This function virtually unwinds <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specfified function by executing its
02297     prologue code backwards.
02298 
02299     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a leaf function, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left
02300     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context record. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function
02301     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a nested function, but not an exception or interrupt frame, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02302     prologue code <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> executed backwards and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left
02303     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> updated context record.
02304 
02305     Otherwise, an exception or interrupt entry to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> system <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being unwound
02306     and a specially coded prologue restores <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">return</span> address twice. Once
02307     from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fault instruction address and once from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> saved <span class="keywordflow">return</span> address
02308     <span class="keyword">register</span>. The first restore <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function value and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02309     second restore <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> place in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> updated context record.
02310 
02311     If a context pointers record <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where each
02312     nonvolatile registers <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> restored from <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> recorded in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate
02313     element of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context pointers record.
02314 
02315     N.B. This function copies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified context record and <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> computes
02316          <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> establisher frame and whether <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> actually in a function.
02317 
02318 Arguments:
02319 
02320     ControlPc - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
02321         function.
02322 
02323     FunctionEntry - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function table entry <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02324         specified function.
02325 
02326     ContextRecord - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of a context record.
02327 
02328     InFunction - Supplies a pointer to a variable that receives whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02329         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> PC <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current function.
02330 
02331     EstablisherFrame - Supplies a pointer to a variable that receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02332         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> establisher frame pointer value.
02333 
02334     ContextPointers - Supplies an optional pointer to a context pointers
02335         record.
02336 
02337 Return Value:
02338 
02339     The address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02340     function value.
02341 
02342 --*/
02343 
02344 {
02345 
02346     CONTEXT LocalContext;
02347 
02348     <span class="comment">//</span>
02349     <span class="comment">// Copy the context record so updates will not be reflected in the</span>
02350     <span class="comment">// original copy and then virtually unwind to the caller of the</span>
02351     <span class="comment">// specified control point.</span>
02352     <span class="comment">//</span>
02353 
02354     RtlMoveMemory((PVOID)&amp;LocalContext, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
02355     <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
02356                             FunctionEntry,
02357                             &amp;LocalContext,
02358                             InFunction,
02359                             EstablisherFrame,
02360                             NULL);
02361 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="alpha/exdsptch.c::RtlRaiseException" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlRaiseException           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PEXCEPTION_RECORD&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ExceptionRecord</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00603">603</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, and <a class="el" href="../../d8/d8/ia64_2exdsptch_8c-source.html#l00311">RtlpRaiseException()</a>.
<p>
Referenced by <a class="el" href="../../d8/d7/dll_2resource_8c-source.html#l00515">RtlAcquireResourceExclusive()</a>, <a class="el" href="../../d8/d7/dll_2resource_8c-source.html#l00350">RtlAcquireResourceShared()</a>, <a class="el" href="../../d8/d7/dll_2resource_8c-source.html#l00851">RtlConvertSharedToExclusive()</a>, and <a class="el" href="../../d8/d7/dll_2resource_8c-source.html#l01544">RtlpWaitForCriticalSection()</a>.
<p>
<pre class="fragment"><div>00609                    :
00610 
00611     This function raises a software exception by building a context record
00612     and calling <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> raise exception system service.
00613 
00614     N.B. This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a shell routine that simply calls another routine
00615          to <span class="keywordflow">do</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> real work. The <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a10">reason</a> <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> done <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to avoid a problem
00616          in <span class="keywordflow">try</span>/finally scopes where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last statement in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> scope <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a
00617          call to raise an exception.
00618 
00619 Arguments:
00620 
00621     ExceptionRecord - Supplies a pointer to an exception record.
00622 
00623 Return Value:
00624 
00625     None.
00626 
00627 --*/
00628 
00629 {
00630 
00631 <span class="preprocessor">#if DBG</span>
00632 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_RAISE_EXCEPTION) {
00633         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlRaiseException(ExceptionRecord = %p) Status = %lx\n"</span>,
00634                  ExceptionRecord, ExceptionRecord-&gt;ExceptionCode);
00635     }
00636 <span class="preprocessor">#endif</span>
00637 <span class="preprocessor"></span>
00638     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a>(ExceptionRecord);
00639     <span class="keywordflow">return</span>;
00640 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="alpha/exdsptch.c::RtlRaiseStatus" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlRaiseStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN NTSTATUS&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Status</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00705">705</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d8/d8/ia64_2exdsptch_8c-source.html#l00409">RtlpRaiseStatus()</a>, and <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>.
<p>
<pre class="fragment"><div>00711                    :
00712 
00713     This function raises an exception with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified status value. The
00714     exception <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> marked as noncontinuable with no parameters.
00715 
00716     N.B. This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a shell routine that simply calls another routine
00717          to <span class="keywordflow">do</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> real work. The <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a10">reason</a> <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> done <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to avoid a problem
00718          in <span class="keywordflow">try</span>/finally scopes where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last statement in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> scope <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a
00719          call to raise an exception.
00720 
00721 Arguments:
00722 
00723     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status value to be used as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception code
00724         <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be raised.
00725 
00726 Return Value:
00727 
00728     None.
00729 
00730 --*/
00731 
00732 {
00733 
00734 <span class="preprocessor">#if DBG</span>
00735 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_RAISE_EXCEPTION) {
00736         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlRaiseStatus(Status = %lx)\n"</span>, Status);
00737     }
00738 <span class="preprocessor">#endif</span>
00739 <span class="preprocessor"></span>
00740     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a>(Status);
00741     <span class="keywordflow">return</span>;
00742 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="alpha/exdsptch.c::RtlUnwind" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlUnwind           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID TargetFrame&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID TargetIp&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PEXCEPTION_RECORD ExceptionRecord&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>ReturnValue</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00817">817</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00737">RtlUnwind2()</a>.
<p>
<pre class="fragment"><div>00826                    :
00827 
00828     This function initiates an unwind of <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> call frames. The machine
00829     state at <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> time of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call to unwind <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> captured in a context record
00830     and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwinding flag <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> set in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception flags of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception
00831     record. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> TargetFrame parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a> unwind
00832     flag <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> also set in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception flags of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception record. <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> backward
00833     scan through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> call frames <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> then performed to find <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> target
00834     of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind operation.
00835 
00836     As each frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> encounter, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PC where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> corresponding
00837     function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> determined and used to lookup exception handler information
00838     in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> runtime function table built by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> linker. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> respective
00839     routine has an exception handler, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handler <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called.
00840 
00841     N.B. This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> provided <span class="keywordflow">for</span> backward compatibility with release 1.
00842 
00843 Arguments:
00844 
00845     TargetFrame - Supplies an optional pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call frame that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00846         target of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind. If <span class="keyword">this</span> parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified, then an <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>
00847         unwind <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> performed.
00848 
00849     TargetIp - Supplies an optional instruction address that specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00850         continuation address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind. This address <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> ignored <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00851         target frame parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified.
00852 
00853     ExceptionRecord - Supplies an optional pointer to an exception record.
00854 
00855     ReturnValue - Supplies a value that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be placed in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> integer
00856         function <span class="keywordflow">return</span> <span class="keyword">register</span> just before continuing execution.
00857 
00858 Return Value:
00859 
00860     None.
00861 
00862 --*/
00863 
00864 {
00865     CONTEXT ContextRecord;
00866 
00867 
00868     <span class="comment">//</span>
00869     <span class="comment">// Call real unwind routine specifying a context record as an</span>
00870     <span class="comment">// extra argument.</span>
00871     <span class="comment">//</span>
00872 
00873     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a>(TargetFrame,
00874                TargetIp,
00875                ExceptionRecord,
00876                ReturnValue,
00877                &amp;ContextRecord);
00878 
00879     <span class="keywordflow">return</span>;
00880 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="alpha/exdsptch.c::RtlUnwind2" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlUnwind2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID TargetFrame&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID TargetIp&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PEXCEPTION_RECORD ExceptionRecord&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>ReturnValue</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PCONTEXT&nbsp;</td>
          <td class="mdname" nowrap> <em>ContextRecord</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00883">883</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d5/d9/cmconfig_8c-source.html#l00051">Count</a>, <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00053">EXCEPTION_COLLIDED_UNWIND</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00049">EXCEPTION_EXIT_UNWIND</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00052">EXCEPTION_TARGET_UNWIND</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00048">EXCEPTION_UNWINDING</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00062">ExceptionCollidedUnwind</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00060">ExceptionContinueSearch</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00079">IS_HANDLER_DEFINED</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00065">RAISE_EXCEPTION</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00348">RtlLookupFunctionEntry()</a>, <a class="el" href="../../d6/d9/ntrtlppc_8h.html#a1">RtlpExecuteHandlerForUnwind()</a>, <a class="el" href="../../d9/d9/rtl_2ia64_2miscc_8c-source.html#l00126">RtlpGetStackLimits()</a>, <a class="el" href="../../d9/d9/ppc_2exdsptch_8c.html#a3">RtlpRestoreContext()</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l01102">RtlpVirtualUnwind()</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00563">RtlRaiseStatus()</a>, and <a class="el" href="../../d1/d6/ppc_2vunwind_8c-source.html#l00467">RtlVirtualUnwind()</a>.
<p>
<pre class="fragment"><div>00893                    :
00894 
00895     This function initiates an unwind of <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> call frames. The machine
00896     state at <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> time of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call to unwind <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> captured in a context record
00897     and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwinding flag <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> set in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception flags of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception
00898     record. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> TargetFrame parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a> unwind
00899     flag <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> also set in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception flags of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception record. <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> backward
00900     scan through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> call frames <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> then performed to find <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> target
00901     of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind operation.
00902 
00903     As each frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> encounter, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PC where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> corresponding
00904     function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> determined and used to lookup exception handler information
00905     in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> runtime function table built by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> linker. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> respective
00906     routine has an exception handler, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handler <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called.
00907 
00908     N.B. This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> provided <span class="keywordflow">for</span> backward compatibility with release 1.
00909 
00910 Arguments:
00911 
00912     TargetFrame - Supplies an optional pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call frame that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00913         target of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind. If <span class="keyword">this</span> parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified, then an <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>
00914         unwind <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> performed.
00915 
00916     TargetIp - Supplies an optional instruction address that specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00917         continuation address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind. This address <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> ignored <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00918         target frame parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified.
00919 
00920     ExceptionRecord - Supplies an optional pointer to an exception record.
00921 
00922     ReturnValue - Supplies a value that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be placed in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> integer
00923         function <span class="keywordflow">return</span> <span class="keyword">register</span> just before continuing execution.
00924 
00925 Return Value:
00926 
00927     None.
00928 
00929 --*/
00930 
00931 {
00932     ULONG_PTR ControlPc;
00933 <span class="preprocessor">#if DBG</span>
00934 <span class="preprocessor"></span>    ULONG_PTR ControlPcHistory[PC_HISTORY_DEPTH];
00935     ULONG ControlPcHistoryIndex = 0;
00936 <span class="preprocessor">#endif</span>
00937 <span class="preprocessor"></span>    <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00938     EXCEPTION_DISPOSITION Disposition;
00939     FRAME_POINTERS EstablisherFrame;
00940     ULONG ExceptionFlags;
00941     EXCEPTION_RECORD ExceptionRecord1;
00942 <span class="preprocessor">#if DBG</span>
00943 <span class="preprocessor"></span>    LONG FrameDepth = 0;
00944 <span class="preprocessor">#endif</span>
00945 <span class="preprocessor"></span>    PRUNTIME_FUNCTION FunctionEntry;
00946     ULONG_PTR HighLimit;
00947     BOOLEAN InFunction;
00948     ULONG_PTR LowLimit;
00949     ULONG_PTR NextPc;
00950 
00951 <span class="preprocessor">#if DBG</span>
00952 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
00953         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\nRtlUnwind(TargetFrame = %p, TargetIp = %p,, ReturnValue = %lx)\n"</span>,
00954                  TargetFrame, TargetIp, ReturnValue);
00955     }
00956 <span class="preprocessor">#endif</span>
00957 <span class="preprocessor"></span>
00958     <span class="comment">//</span>
00959     <span class="comment">// Get current stack limits, capture the current context, virtually</span>
00960     <span class="comment">// unwind to the caller of this routine, get the initial PC value, and</span>
00961     <span class="comment">// set the unwind target address.</span>
00962     <span class="comment">//</span>
00963 
00964     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00965     RtlCaptureContext(ContextRecord);
00966     ControlPc = (ULONG_PTR)ContextRecord-&gt;IntRa - 4;
00967     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00968     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00969                               FunctionEntry,
00970                               ContextRecord,
00971                               &amp;InFunction,
00972                               &amp;EstablisherFrame,
00973                               NULL);
00974 
00975     ControlPc = NextPc;
00976     ContextRecord-&gt;Fir = (ULONGLONG)(LONG_PTR)TargetIp;
00977 
00978     <span class="comment">//</span>
00979     <span class="comment">// If an exception record is not specified, then build a local exception</span>
00980     <span class="comment">// record for use in calling exception handlers during the unwind operation.</span>
00981     <span class="comment">//</span>
00982 
00983     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ExceptionRecord) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00984         ExceptionRecord = &amp;ExceptionRecord1;
00985         ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
00986         ExceptionRecord1.ExceptionRecord = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00987         ExceptionRecord1.ExceptionAddress = (PVOID)ControlPc;
00988         ExceptionRecord1.NumberParameters = 0;
00989     }
00990 
00991     <span class="comment">//</span>
00992     <span class="comment">// If the target frame of the unwind is specified, then a normal unwind</span>
00993     <span class="comment">// is being performed. Otherwise, an exit unwind is being performed.</span>
00994     <span class="comment">//</span>
00995 
00996     ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a26">EXCEPTION_UNWINDING</a>;
00997     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TargetFrame) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00998         ExceptionRecord-&gt;ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a27">EXCEPTION_EXIT_UNWIND</a>;
00999     }
01000 
01001     <span class="comment">//</span>
01002     <span class="comment">// Scan backward through the call frame hierarchy and call exception</span>
01003     <span class="comment">// handlers until the target frame of the unwind is reached.</span>
01004     <span class="comment">//</span>
01005 
01006     <span class="keywordflow">do</span> {
01007 
01008 <span class="preprocessor">#if DBG</span>
01009 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
01010         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: Loop: FrameDepth = %d, sp = %p, ControlPc = %p\n"</span>,
01011                  FrameDepth, (ULONG_PTR)ContextRecord-&gt;IntSp, ControlPc);
01012         FrameDepth -= 1;
01013     }
01014 <span class="preprocessor">#endif</span>
01015 <span class="preprocessor"></span>
01016         <span class="comment">//</span>
01017         <span class="comment">// Lookup the function table entry using the point at which control</span>
01018         <span class="comment">// left the procedure.</span>
01019         <span class="comment">//</span>
01020 
01021         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
01022 
01023         <span class="comment">//</span>
01024         <span class="comment">// If there is a function table entry for the routine, then virtually</span>
01025         <span class="comment">// unwind to the caller of the routine to obtain the virtual frame</span>
01026         <span class="comment">// pointer of the establisher, but don't update the context record.</span>
01027         <span class="comment">//</span>
01028 
01029         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01030             NextPc = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a>(ControlPc,
01031                                        FunctionEntry,
01032                                        ContextRecord,
01033                                        &amp;InFunction,
01034                                        &amp;EstablisherFrame);
01035 
01036             <span class="comment">//</span>
01037             <span class="comment">// If the virtual frame pointer is not within the specified stack</span>
01038             <span class="comment">// limits, the virtual frame pointer is unaligned, or the target</span>
01039             <span class="comment">// frame is below the virtual frame and an exit unwind is not being</span>
01040             <span class="comment">// performed, then raise the exception STATUS_BAD_STACK. Otherwise,</span>
01041             <span class="comment">// check to determine if the current routine has an exception</span>
01042             <span class="comment">// handler.</span>
01043             <span class="comment">//</span>
01044 
01045             <span class="keywordflow">if</span> ((EstablisherFrame.Virtual &lt; LowLimit) ||
01046                 (EstablisherFrame.Virtual &gt; HighLimit) ||
01047                 ((ARGUMENT_PRESENT(TargetFrame) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01048                  ((ULONG_PTR)TargetFrame &lt; EstablisherFrame.Virtual)) ||
01049                 ((EstablisherFrame.Virtual &amp; 0xF) != 0)) {
01050 
01051 <span class="preprocessor">#if DBG</span>
01052 <span class="preprocessor"></span>                <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - bad stack or target frame (unwind).\n"</span>);
01053                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  EstablisherFrame Virtual = %p, Real = %p\n"</span>,
01054                          EstablisherFrame.Virtual, EstablisherFrame.Real);
01055                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  TargetFrame = %p\n"</span>, TargetFrame);
01056                 <span class="keywordflow">if</span> ((ARGUMENT_PRESENT(TargetFrame) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01057                     ((ULONG_PTR)TargetFrame &lt; EstablisherFrame.Virtual)) {
01058                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  TargetFrame is below EstablisherFrame!\n"</span>);
01059                 }
01060                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Previous EstablisherFrame (sp) = %p\n"</span>,
01061                          (ULONG_PTR)ContextRecord-&gt;IntSp);
01062                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  LowLimit = %p, HighLimit = %p\n"</span>,
01063                          LowLimit, HighLimit);
01064                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  NextPc = %p, ControlPc = %p\n"</span>,
01065                          NextPc, ControlPc);
01066                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Now raising STATUS_BAD_STACK exception.\n"</span>);
01067 <span class="preprocessor">#endif</span>
01068 <span class="preprocessor"></span>
01069                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_BAD_STACK, ExceptionRecord);
01070 
01071             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a1">IS_HANDLER_DEFINED</a>(FunctionEntry) &amp;&amp; InFunction) {
01072 
01073 <span class="preprocessor">#if DBG</span>
01074 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
01075     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: ExceptionHandler = %p, HandlerData = %p\n"</span>,
01076              FunctionEntry-&gt;ExceptionHandler, FunctionEntry-&gt;HandlerData);
01077 }
01078 <span class="preprocessor">#endif</span>
01079 <span class="preprocessor"></span>
01080                 <span class="comment">//</span>
01081                 <span class="comment">// The frame has an exception handler.</span>
01082                 <span class="comment">//</span>
01083                 <span class="comment">// The control PC, establisher frame pointer, the address</span>
01084                 <span class="comment">// of the function table entry, and the address of the</span>
01085                 <span class="comment">// context record are all stored in the dispatcher context.</span>
01086                 <span class="comment">// This information is used by the unwind linkage routine</span>
01087                 <span class="comment">// and can be used by the exception handler itself.</span>
01088                 <span class="comment">//</span>
01089                 <span class="comment">// A linkage routine written in assembler is used to actually</span>
01090                 <span class="comment">// call the actual exception handler. This is required by the</span>
01091                 <span class="comment">// exception handler that is associated with the linkage</span>
01092                 <span class="comment">// routine so it can have access to two sets of dispatcher</span>
01093                 <span class="comment">// context when it is called.</span>
01094                 <span class="comment">//</span>
01095 
01096                 DispatcherContext.ControlPc = ControlPc;
01097                 DispatcherContext.FunctionEntry = FunctionEntry;
01098                 DispatcherContext.EstablisherFrame = EstablisherFrame.Virtual;
01099                 DispatcherContext.ContextRecord = ContextRecord;
01100 
01101                 <span class="comment">//</span>
01102                 <span class="comment">// Call the exception handler.</span>
01103                 <span class="comment">//</span>
01104 
01105                 <span class="keywordflow">do</span> {
01106 
01107                     <span class="comment">//</span>
01108                     <span class="comment">// If the establisher frame is the target of the unwind</span>
01109                     <span class="comment">// operation, then set the target unwind flag.</span>
01110                     <span class="comment">//</span>
01111 
01112                     <span class="keywordflow">if</span> ((ULONG_PTR)TargetFrame == EstablisherFrame.Virtual) {
01113                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>;
01114                     }
01115 
01116                     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
01117 
01118                     <span class="comment">//</span>
01119                     <span class="comment">// Set the specified return value in case the exception</span>
01120                     <span class="comment">// handler directly continues execution.</span>
01121                     <span class="comment">//</span>
01122 
01123                     ContextRecord-&gt;IntV0 = (ULONGLONG)(LONG_PTR)ReturnValue;
01124 <span class="preprocessor">#if DBG</span>
01125 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
01126         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: calling RtlpExecuteHandlerForUnwind, ControlPc = %p\n"</span>, ControlPc);
01127     }
01128 <span class="preprocessor">#endif</span>
01129 <span class="preprocessor"></span>                    Disposition =
01130                         <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a1">RtlpExecuteHandlerForUnwind</a>(ExceptionRecord,
01131                                                     EstablisherFrame.Virtual,
01132                                                     ContextRecord,
01133                                                     &amp;DispatcherContext,
01134                                                     RF_EXCEPTION_HANDLER(FunctionEntry));
01135 <span class="preprocessor">#if DBG</span>
01136 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
01137         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: RtlpExecuteHandlerForUnwind returned Disposition = %lx\n"</span>, Disposition);
01138     }
01139 <span class="preprocessor">#endif</span>
01140 <span class="preprocessor"></span>
01141                     <span class="comment">//</span>
01142                     <span class="comment">// Clear target unwind and collided unwind flags.</span>
01143                     <span class="comment">//</span>
01144 
01145                     ExceptionFlags &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a> |
01146                                         <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>);
01147 
01148                     <span class="comment">//</span>
01149                     <span class="comment">// Case on the handler disposition.</span>
01150                     <span class="comment">//</span>
01151 
01152                     <span class="keywordflow">switch</span> (Disposition) {
01153 
01154                         <span class="comment">//</span>
01155                         <span class="comment">// The disposition is to continue the search.</span>
01156                         <span class="comment">//</span>
01157                         <span class="comment">// If the target frame has not been reached, then</span>
01158                         <span class="comment">// virtually unwind to the caller of the current</span>
01159                         <span class="comment">// routine, update the context record, and continue</span>
01160                         <span class="comment">// the search for a handler.</span>
01161                         <span class="comment">//</span>
01162 
01163                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
01164                         <span class="keywordflow">if</span> (EstablisherFrame.Virtual != (ULONG_PTR)TargetFrame) {
01165                             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
01166                                                       FunctionEntry,
01167                                                       ContextRecord,
01168                                                       &amp;InFunction,
01169                                                       &amp;EstablisherFrame,
01170                                                       NULL);
01171                         }
01172 
01173                         <span class="keywordflow">break</span>;
01174 
01175                         <span class="comment">//</span>
01176                         <span class="comment">// The disposition is collided unwind.</span>
01177                         <span class="comment">//</span>
01178                         <span class="comment">// Set the target of the current unwind to the context</span>
01179                         <span class="comment">// record of the previous unwind, and reexecute the</span>
01180                         <span class="comment">// exception handler from the collided frame with the</span>
01181                         <span class="comment">// collided unwind flag set in the exception record.</span>
01182                         <span class="comment">//</span>
01183 
01184                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a39">ExceptionCollidedUnwind</a> :
01185                         ControlPc = DispatcherContext.ControlPc;
01186                         FunctionEntry = DispatcherContext.FunctionEntry;
01187                         ContextRecord = DispatcherContext.ContextRecord;
01188                         ContextRecord-&gt;Fir = (ULONGLONG)(LONG_PTR)TargetIp;
01189                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>;
01190                         EstablisherFrame.Virtual = DispatcherContext.EstablisherFrame;
01191                         <span class="keywordflow">break</span>;
01192 
01193                         <span class="comment">//</span>
01194                         <span class="comment">// All other disposition values are invalid.</span>
01195                         <span class="comment">//</span>
01196                         <span class="comment">// Raise invalid disposition exception.</span>
01197                         <span class="comment">//</span>
01198 
01199                     <span class="keywordflow">default</span> :
01200                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
01201                     }
01202 
01203                 } <span class="keywordflow">while</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>) != 0);
01204             } <span class="keywordflow">else</span> {
01205 
01206                 <span class="comment">//</span>
01207                 <span class="comment">// Virtually unwind to the caller of the current routine and</span>
01208                 <span class="comment">// update the context record.</span>
01209                 <span class="comment">//</span>
01210 
01211                 <span class="keywordflow">if</span> (EstablisherFrame.Virtual != (ULONG_PTR)TargetFrame) {
01212                     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
01213                                               FunctionEntry,
01214                                               ContextRecord,
01215                                               &amp;InFunction,
01216                                               &amp;EstablisherFrame,
01217                                               NULL);
01218                 }
01219             }
01220 
01221         } <span class="keywordflow">else</span> {
01222 
01223             <span class="comment">//</span>
01224             <span class="comment">// Set point at which control left the previous routine.</span>
01225             <span class="comment">//</span>
01226 
01227             NextPc = (ULONG_PTR)ContextRecord-&gt;IntRa - 4;
01228 
01229             <span class="comment">//</span>
01230             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
01231             <span class="comment">// the function table is not correctly formed.</span>
01232             <span class="comment">//</span>
01233 
01234             <span class="keywordflow">if</span> (NextPc == ControlPc) {
01235 <span class="preprocessor">#if DBG</span>
01236 <span class="preprocessor"></span>                ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
01237                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - malformed function table (unwind).\n"</span>);
01238                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"ControlPc = %p, %p"</span>, NextPc, ControlPc);
01239                 <span class="keywordflow">for</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &lt; PC_HISTORY_DEPTH; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1) {
01240                     <span class="keywordflow">if</span> (ControlPcHistoryIndex &gt; 0) {
01241                         ControlPcHistoryIndex -= 1;
01242                         ControlPc = ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH];
01243                         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">", %p"</span>, ControlPc);
01244                     }
01245                 }
01246                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(ControlPcHistoryIndex == 0 ? <span class="stringliteral">".\n"</span> : <span class="stringliteral">", ...\n"</span>);
01247                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Now raising STATUS_BAD_FUNCTION_TABLE exception.\n"</span>);
01248 <span class="preprocessor">#endif</span>
01249 <span class="preprocessor"></span>                <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(STATUS_BAD_FUNCTION_TABLE);
01250             }
01251         }
01252 
01253         <span class="comment">//</span>
01254         <span class="comment">// Set point at which control left the previous routine.</span>
01255         <span class="comment">//</span>
01256 
01257 <span class="preprocessor">#if DBG</span>
01258 <span class="preprocessor"></span>        ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH] = ControlPc;
01259         ControlPcHistoryIndex += 1;
01260 <span class="preprocessor">#endif</span>
01261 <span class="preprocessor"></span>        ControlPc = NextPc;
01262 
01263     } <span class="keywordflow">while</span> ((EstablisherFrame.Virtual &lt; HighLimit) &amp;&amp;
01264              (EstablisherFrame.Virtual != (ULONG_PTR)TargetFrame));
01265 
01266     <span class="comment">//</span>
01267     <span class="comment">// If the establisher stack pointer is equal to the target frame</span>
01268     <span class="comment">// pointer, then continue execution. Otherwise, an exit unwind was</span>
01269     <span class="comment">// performed or the target of the unwind did not exist and the</span>
01270     <span class="comment">// debugger and subsystem are given a second chance to handle the</span>
01271     <span class="comment">// unwind.</span>
01272     <span class="comment">//</span>
01273 
01274     <span class="keywordflow">if</span> (EstablisherFrame.Virtual == (ULONG_PTR)TargetFrame) {
01275         ContextRecord-&gt;IntV0 = (ULONGLONG)(LONG_PTR)ReturnValue;
01276 
01277 <span class="preprocessor">#if DBG</span>
01278 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
01279         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: finished unwinding, and calling RtlpRestoreContext(%lx)\n"</span>,ContextRecord);
01280     }
01281 <span class="preprocessor">#endif</span>
01282 <span class="preprocessor"></span>
01283         <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a3">RtlpRestoreContext</a>(ContextRecord);
01284 
01285     } <span class="keywordflow">else</span> {
01286 
01287 <span class="preprocessor">#if DBG</span>
01288 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
01289         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: finished unwinding, but calling ZwRaiseException\n"</span>);
01290     }
01291 <span class="preprocessor">#endif</span>
01292 <span class="preprocessor"></span>
01293         ZwRaiseException(ExceptionRecord, ContextRecord, FALSE);
01294     }
01295 
01296 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="alpha/exdsptch.c::RtlVirtualUnwind" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG_PTR RtlVirtualUnwind           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>ControlPc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PRUNTIME_FUNCTION&nbsp;</td>
          <td class="mdname" nowrap> <em>FunctionEntry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PCONTEXT&nbsp;</td>
          <td class="mdname" nowrap> <em>ContextRecord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PBOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>InFunction</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PFRAME_POINTERS&nbsp;</td>
          <td class="mdname" nowrap> <em>EstablisherFrame</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l01455">1455</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
References <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l01448">_RtlpDebugDisassemble</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l01449">_RtlpFoundTrapFrame</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l01450">_RtlpVirtualUnwindExit</a>, <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/ia64_2alignem_8c-source.html#l00032">LDA_OP</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02536">RtlGetUnwindFunctionEntry()</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>01466                    :
01467 
01468     This function virtually unwinds <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified function by executing its
01469     prologue code backwards. Given <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current context and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> instructions
01470     that preserve registers in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> prologue, <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> possible to recreate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01471     nonvolatile context at <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> point <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function was called.
01472 
01473     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a leaf function, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left
01474     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context record. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function
01475     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a nested function, but not an exception or interrupt frame, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01476     prologue code <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> executed backwards and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left
01477     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> updated context record.
01478 
01479     Otherwise, an exception or interrupt entry to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> system <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being unwound
01480     and a specially coded prologue restores <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">return</span> address twice. Once
01481     from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fault instruction address and once from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> saved <span class="keywordflow">return</span> address
01482     <span class="keyword">register</span>. The first restore <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function value and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01483     second restore <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> placed in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> updated context record.
01484 
01485     During <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">virtual</span> and real frame pointers <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function
01486     are calculated and returned in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> given frame pointers structure.
01487 
01488     If a context pointers record <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where each
01489     <span class="keyword">register</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> restored from <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> recorded in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate element of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01490     context pointers record.
01491 
01492 Arguments:
01493 
01494     ControlPc - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
01495         function.
01496 
01497     FunctionEntry - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function table entry <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01498         specified function.
01499 
01500     ContextRecord - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of a context record.
01501 
01502     InFunction - Supplies a pointer to a variable that receives whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01503         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> PC <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current function.
01504 
01505     EstablisherFrame - Supplies a pointer to a frame pointers structure
01506         that will receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> values <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">virtual</span> frame pointer and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01507         real frame pointer. The value of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> real frame pointer <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> reliable
01508         <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> when InFunction <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>.
01509 
01510     ContextPointers - Supplies an optional pointer to a context pointers
01511         record.
01512 
01513 Return Value:
01514 
01515     The address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01516     function value.
01517 
01518 Implementation Notes:
01519 
01520     N.B. <span class="stringliteral">"where control left"</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="stringliteral">"return address"</span> of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01521     previous frame. For normal frames, NextPc points to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last instruction
01522     that completed in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame (the JSR/BSR). The difference between
01523     NextPc and NextPc + 4 (<span class="keywordflow">return</span> address) <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> important <span class="keywordflow">for</span> correct behavior
01524     in boundary cases of exception addresses and scope tables.
01525 
01526     For exception and interrupt frames, NextPc <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> trap frame
01527     contination address (Fir). For faults and synchronous traps, NextPc <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> both
01528     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last instruction to execute in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> next
01529     instruction to execute <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function were to <span class="keywordflow">return</span>. For asynchronous
01530     traps, NextPc <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> continuation address. It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> responsibility of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01531     compiler to insert TRAPB instructions to insure asynchronous traps <span class="keywordflow">do</span> not
01532     occur outside <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> scope from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> instruction(s) that caused them.
01533 
01534     N.B. in this and other files where RtlVirtualUnwind is used, the variable
01535     named NextPc is perhaps more accurately, LastPc - the last PC value in
01536     the previous frame, or CallPc - the address of the call instruction, or
01537     ControlPc - the address where control left the previous frame. Instead
01538     think of NextPc as the next PC to use in another call to virtual unwind.
01539 
01540     The Alpha version of virtual unwind is similar in design, but slightly
01541     more complex than the Mips version. This is because Alpha compilers
01542     are given more flexibility to optimize generated code and instruction
01543     sequences, including within procedure prologues. In addition, because of
01544     the current inability of the GEM compiler to materialize virtual frame
01545     pointers, this function must manage both virtual and real frame pointers.
01546 
01547 --*/
01548 
01549 {
01550 
01551     ULONG_PTR Address;
01552     ULONG DecrementOffset;
01553     ULONG DecrementRegister;
01554     ALPHA_INSTRUCTION FollowingInstruction;
01555     PULONGLONG FloatingRegister;
01556     ULONG_PTR FrameSize;
01557     ULONG Function;
01558     ALPHA_INSTRUCTION Instruction;
01559     PULONGLONG IntegerRegister;
01560     ULONG Literal8;
01561     ULONG_PTR NextPc;
01562     LONG Offset16;
01563     ULONG Opcode;
01564     ULONG Ra;
01565     ULONG Rb;
01566     ULONG Rc;
01567     BOOLEAN RestoredRa;
01568     BOOLEAN RestoredSp;
01569     RUNTIME_FUNCTION UnwindFunctionEntry;
01570     ULONG StackAdjust;
01571     ULONG_PTR FixedReturn;
01572 
01573 <span class="preprocessor">#if DBG</span>
01574 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_VIRTUAL_UNWIND) {
01575         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\nRtlVirtualUnwind(ControlPc = %p, FunctionEntry = %p,) sp = %p\n"</span>,
01576                  ControlPc, FunctionEntry, (ULONG_PTR)ContextRecord-&gt;IntSp);
01577     }
01578 <span class="preprocessor">#endif</span>
01579 <span class="preprocessor"></span>
01580     <span class="comment">// Construct a function entry suitable for unwinding from ControlPc</span>
01581 
01582     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a14">RtlGetUnwindFunctionEntry</a>( ControlPc, FunctionEntry, &amp;UnwindFunctionEntry, &amp;StackAdjust, &amp;FixedReturn );
01583 
01584 <span class="preprocessor">#if DBG</span>
01585 <span class="preprocessor"></span>    ShowRuntimeFunction(&amp;UnwindFunctionEntry, <span class="stringliteral">"RtlVirtualUnwind: unwind function entry"</span> );
01586 <span class="preprocessor">#endif</span>
01587 <span class="preprocessor"></span>    <span class="comment">//</span>
01588     <span class="comment">// Set the base address of the integer and floating register arrays within</span>
01589     <span class="comment">// the context record. Each set of 32 registers is known to be contiguous.</span>
01590     <span class="comment">//</span>
01591 
01592     IntegerRegister = &amp;ContextRecord-&gt;IntV0;
01593     FloatingRegister = &amp;ContextRecord-&gt;FltF0;
01594 
01595     <span class="comment">//</span>
01596     <span class="comment">// Handle the epilogue case where the next instruction is a return.</span>
01597     <span class="comment">//</span>
01598     <span class="comment">// Exception handlers cannot be called if the ControlPc is within the</span>
01599     <span class="comment">// epilogue because exception handlers expect to operate with a current</span>
01600     <span class="comment">// stack frame. The value of SP is not current within the epilogue.</span>
01601     <span class="comment">//</span>
01602 
01603     Instruction.Long = *((PULONG)ControlPc);
01604     <span class="keywordflow">if</span> (IS_RETURN_0001_INSTRUCTION(Instruction.Long)) {
01605         Rb = Instruction.Jump.Rb;
01606         NextPc = (ULONG_PTR)IntegerRegister[Rb] - 4;
01607 
01608         <span class="comment">//</span>
01609         <span class="comment">// The instruction at the point where control left the specified</span>
01610         <span class="comment">// function is a return, so any saved registers have already been</span>
01611         <span class="comment">// restored, and the stack pointer has already been adjusted. The</span>
01612         <span class="comment">// stack does not need to be unwound in this case and the saved</span>
01613         <span class="comment">// return address register is returned as the function value.</span>
01614         <span class="comment">//</span>
01615         <span class="comment">// In fact, reverse execution of the prologue is not possible in</span>
01616         <span class="comment">// this case: the stack pointer has already been incremented and</span>
01617         <span class="comment">// so, for this frame, neither a valid stack pointer nor frame</span>
01618         <span class="comment">// pointer exists from which to begin reverse execution of the</span>
01619         <span class="comment">// prologue. In addition, the integrity of any data on the stack</span>
01620         <span class="comment">// below the stack pointer is never guaranteed (due to interrupts</span>
01621         <span class="comment">// and exceptions).</span>
01622         <span class="comment">//</span>
01623         <span class="comment">// The epilogue instruction sequence is:</span>
01624         <span class="comment">//</span>
01625         <span class="comment">// ==&gt;  ret   zero, (Ra), 1     // return</span>
01626         <span class="comment">// or</span>
01627         <span class="comment">//</span>
01628         <span class="comment">//      mov   ra, Rx            // save return address</span>
01629         <span class="comment">//      ...</span>
01630         <span class="comment">// ==&gt;  ret   zero, (Rx), 1     // return</span>
01631         <span class="comment">//</span>
01632 
01633         EstablisherFrame-&gt;Real = 0;
01634         EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
01635         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01636         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01637         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a6">_RtlpVirtualUnwindExit</a>(NextPc, ContextRecord, EstablisherFrame);
01638         <span class="keywordflow">return</span> NextPc;
01639     }
01640 
01641     <span class="comment">//</span>
01642     <span class="comment">// Handle the epilogue case where the next two instructions are a stack</span>
01643     <span class="comment">// frame deallocation and a return.</span>
01644     <span class="comment">//</span>
01645 
01646     FollowingInstruction.Long = *((PULONG)(ControlPc + 4));
01647     <span class="keywordflow">if</span> (IS_RETURN_0001_INSTRUCTION(FollowingInstruction.Long)) {
01648         Rb = FollowingInstruction.Jump.Rb;
01649         NextPc = (ULONG_PTR)IntegerRegister[Rb] - 4;
01650 
01651         <span class="comment">//</span>
01652         <span class="comment">// The second instruction following the point where control</span>
01653         <span class="comment">// left the specified function is a return. If the instruction</span>
01654         <span class="comment">// before the return is a stack increment instruction, then all</span>
01655         <span class="comment">// saved registers have already been restored except for SP.</span>
01656         <span class="comment">// The value of the stack pointer register cannot be recovered</span>
01657         <span class="comment">// through reverse execution of the prologue because in order</span>
01658         <span class="comment">// to begin reverse execution either the stack pointer or the</span>
01659         <span class="comment">// frame pointer (if any) must still be valid.</span>
01660         <span class="comment">//</span>
01661         <span class="comment">// Instead, the effect that the stack increment instruction</span>
01662         <span class="comment">// would have had on the context is manually applied to the</span>
01663         <span class="comment">// current context. This is forward execution of the epilogue</span>
01664         <span class="comment">// rather than reverse execution of the prologue.</span>
01665         <span class="comment">//</span>
01666         <span class="comment">// In an epilogue, as in a prologue, the stack pointer is always</span>
01667         <span class="comment">// adjusted with a single instruction: either an immediate-value</span>
01668         <span class="comment">// (lda) or a register-value (addq) add instruction.</span>
01669         <span class="comment">//</span>
01670 
01671         Function = Instruction.OpReg.Function;
01672         Offset16 = Instruction.Memory.MemDisp;
01673         Opcode = Instruction.OpReg.Opcode;
01674         Ra = Instruction.OpReg.Ra;
01675         Rb = Instruction.OpReg.Rb;
01676         Rc = Instruction.OpReg.Rc;
01677 
01678         <span class="keywordflow">if</span> ((Opcode == <a class="code" href="../../d5/d5/ia64_2alignem_8c.html#a3">LDA_OP</a>) &amp;&amp; (Ra == SP_REG)) {
01679 
01680             <span class="comment">//</span>
01681             <span class="comment">// Load Address instruction.</span>
01682             <span class="comment">//</span>
01683             <span class="comment">// Since the destination (Ra) register is SP, an immediate-</span>
01684             <span class="comment">// value stack deallocation operation is being performed. The</span>
01685             <span class="comment">// displacement value should be added to SP. The displacement</span>
01686             <span class="comment">// value is assumed to be positive. The amount of stack</span>
01687             <span class="comment">// deallocation possible using this instruction ranges from</span>
01688             <span class="comment">// 16 to 32752 (32768 - 16) bytes. The base register (Rb) is</span>
01689             <span class="comment">// usually SP, but may be another register.</span>
01690             <span class="comment">//</span>
01691             <span class="comment">// The epilogue instruction sequence is:</span>
01692             <span class="comment">//</span>
01693             <span class="comment">// ==&gt;  lda   sp, +N(sp)        // deallocate stack frame</span>
01694             <span class="comment">//      ret   zero, (ra)        // return</span>
01695             <span class="comment">// or</span>
01696             <span class="comment">//</span>
01697             <span class="comment">// ==&gt;  lda   sp, +N(Rx)        // restore SP and deallocate frame</span>
01698             <span class="comment">//      ret   zero, (ra)        // return</span>
01699             <span class="comment">//</span>
01700 
01701             ContextRecord-&gt;IntSp = Offset16 + IntegerRegister[Rb];
01702             EstablisherFrame-&gt;Real = 0;
01703             EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
01704             *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01705             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01706             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc + 4, ContextRecord);
01707             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a6">_RtlpVirtualUnwindExit</a>(NextPc, ContextRecord, EstablisherFrame);
01708             <span class="keywordflow">return</span> NextPc;
01709 
01710         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Opcode == ARITH_OP) &amp;&amp; (Function == ADDQ_FUNC) &amp;&amp;
01711                    (Rc == SP_REG) &amp;&amp;
01712                    (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT)) {
01713 
01714             <span class="comment">//</span>
01715             <span class="comment">// Add Quadword instruction.</span>
01716             <span class="comment">//</span>
01717             <span class="comment">// Since both source operands are registers, and the</span>
01718             <span class="comment">// destination register is SP, a register-value stack</span>
01719             <span class="comment">// deallocation is being performed. The value of the two</span>
01720             <span class="comment">// source registers should be added and this is the new</span>
01721             <span class="comment">// value of SP. One of the source registers is usually SP,</span>
01722             <span class="comment">// but may be another register.</span>
01723             <span class="comment">//</span>
01724             <span class="comment">// The epilogue instruction sequence is:</span>
01725             <span class="comment">//</span>
01726             <span class="comment">//      ldiq  Rx, N             // set [large] frame size</span>
01727             <span class="comment">//      ...</span>
01728             <span class="comment">// ==&gt;  addq  sp, Rx, sp        // deallocate stack frame</span>
01729             <span class="comment">//      ret   zero, (ra)        // return</span>
01730             <span class="comment">// or</span>
01731             <span class="comment">//</span>
01732             <span class="comment">// ==&gt;  addq  Rx, Ry, sp        // restore SP and deallocate frame</span>
01733             <span class="comment">//      ret   zero, (ra)        // return</span>
01734             <span class="comment">//</span>
01735 
01736             ContextRecord-&gt;IntSp = IntegerRegister[Ra] + IntegerRegister[Rb];
01737             EstablisherFrame-&gt;Real = 0;
01738             EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
01739             *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01740             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01741             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc + 4, ContextRecord);
01742             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a6">_RtlpVirtualUnwindExit</a>(NextPc, ContextRecord, EstablisherFrame);
01743             <span class="keywordflow">return</span> NextPc;
01744         }
01745     }
01746 
01747     <span class="comment">//</span>
01748     <span class="comment">// By default set the frame pointers to the current value of SP.</span>
01749     <span class="comment">//</span>
01750     <span class="comment">// When a procedure is called, the value of SP before the stack</span>
01751     <span class="comment">// allocation instruction is the virtual frame pointer. When reverse</span>
01752     <span class="comment">// executing instructions in the prologue, the value of SP before the</span>
01753     <span class="comment">// stack allocation instruction is encountered is the real frame</span>
01754     <span class="comment">// pointer. This is the current value of SP unless the procedure uses</span>
01755     <span class="comment">// a frame pointer (e.g., FP_REG).</span>
01756     <span class="comment">//</span>
01757 
01758     EstablisherFrame-&gt;Real = (ULONG_PTR)ContextRecord-&gt;IntSp;
01759     EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
01760 
01761     <span class="comment">//</span>
01762     <span class="comment">// If the address where control left the specified function is beyond</span>
01763     <span class="comment">// the end of the prologue, then the control PC is considered to be</span>
01764     <span class="comment">// within the function and the control address is set to the end of</span>
01765     <span class="comment">// the prologue. Otherwise, the control PC is not considered to be</span>
01766     <span class="comment">// within the function (i.e., the prologue).</span>
01767     <span class="comment">//</span>
01768     <span class="comment">// N.B. PrologEndAddress is equal to BeginAddress for a leaf function.</span>
01769     <span class="comment">//</span>
01770     <span class="comment">// The low-order two bits of PrologEndAddress are reserved for the IEEE</span>
01771     <span class="comment">// exception mode and so must be masked out.</span>
01772     <span class="comment">//</span>
01773 
01774     <span class="keywordflow">if</span> ((ControlPc &lt; UnwindFunctionEntry.BeginAddress) ||
01775         (ControlPc &gt;= UnwindFunctionEntry.PrologEndAddress)) {
01776         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01777         ControlPc = (UnwindFunctionEntry.PrologEndAddress &amp; (~(UINT_PTR)0x3));
01778 
01779     } <span class="keywordflow">else</span> {
01780         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01781     }
01782 
01783     <span class="comment">//</span>
01784     <span class="comment">// Scan backward through the prologue to reload callee saved registers</span>
01785     <span class="comment">// that were stored or copied and to increment the stack pointer if it</span>
01786     <span class="comment">// was decremented.</span>
01787     <span class="comment">//</span>
01788 
01789     DecrementRegister = ZERO_REG;
01790     NextPc = (ULONG_PTR)ContextRecord-&gt;IntRa - 4;
01791     RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01792     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01793     <span class="keywordflow">while</span> (ControlPc &gt; UnwindFunctionEntry.BeginAddress) {
01794 
01795         <span class="comment">//</span>
01796         <span class="comment">// Get instruction value, decode fields, case on opcode value, and</span>
01797         <span class="comment">// reverse register store and stack decrement operations.</span>
01798         <span class="comment">// N.B. The location of Opcode, Ra, Rb, and Rc is the same across</span>
01799         <span class="comment">// all opcode formats. The same is not true for Function.</span>
01800         <span class="comment">//</span>
01801 
01802         ControlPc -= 4;
01803         Instruction.Long = *((PULONG)ControlPc);
01804         Function = Instruction.OpReg.Function;
01805         Literal8 = Instruction.OpLit.Literal;
01806         Offset16 = Instruction.Memory.MemDisp;
01807         Opcode = Instruction.OpReg.Opcode;
01808         Ra = Instruction.OpReg.Ra;
01809         Rb = Instruction.OpReg.Rb;
01810         Rc = Instruction.OpReg.Rc;
01811 
01812         <span class="comment">//</span>
01813         <span class="comment">// Compare against each instruction type that will affect the context</span>
01814         <span class="comment">// and that is allowed in a prologue. Any other instructions found</span>
01815         <span class="comment">// in the prologue will be ignored since they are assumed to have no</span>
01816         <span class="comment">// effect on the context.</span>
01817         <span class="comment">//</span>
01818 
01819         <span class="keywordflow">switch</span> (Opcode) {
01820 
01821         <span class="keywordflow">case</span> STQ_OP :
01822 
01823             <span class="comment">//</span>
01824             <span class="comment">// Store Quad instruction.</span>
01825             <span class="comment">//</span>
01826             <span class="comment">// If the base register is SP, then reload the source register</span>
01827             <span class="comment">// value from the value stored on the stack.</span>
01828             <span class="comment">//</span>
01829             <span class="comment">// The prologue instruction sequence is:</span>
01830             <span class="comment">//</span>
01831             <span class="comment">// ==&gt;  stq   Rx, N(sp)         // save integer register Rx</span>
01832             <span class="comment">//</span>
01833 
01834             <span class="keywordflow">if</span> ((Rb == SP_REG) &amp;&amp; (Ra != ZERO_REG)) {
01835 
01836                 <span class="comment">//</span>
01837                 <span class="comment">// Reload the register by retrieving the value previously</span>
01838                 <span class="comment">// stored on the stack.</span>
01839                 <span class="comment">//</span>
01840 
01841                 Address = Offset16 + (LONG_PTR)ContextRecord-&gt;IntSp;
01842                 IntegerRegister[Ra] = *((PULONGLONG)Address);
01843 
01844                 <span class="comment">//</span>
01845                 <span class="comment">// If the destination register is RA and this is the first</span>
01846                 <span class="comment">// time that RA is being restored, then set the address of</span>
01847                 <span class="comment">// where control left the previous frame. Otherwise, if this</span>
01848                 <span class="comment">// is the second time RA is being restored, then the first</span>
01849                 <span class="comment">// one was an interrupt or exception address and the return</span>
01850                 <span class="comment">// PC should not have been biased by 4.</span>
01851                 <span class="comment">//</span>
01852 
01853                 <span class="keywordflow">if</span> (Ra == RA_REG) {
01854                     <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01855                         NextPc = (ULONG_PTR)ContextRecord-&gt;IntRa - 4;
01856                         RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01857 
01858                     } <span class="keywordflow">else</span> {
01859                         NextPc += 4;
01860                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a5">_RtlpFoundTrapFrame</a>(NextPc);
01861                     }
01862 
01863                 <span class="comment">//</span>
01864                 <span class="comment">// Otherwise, if the destination register is SP and this is</span>
01865                 <span class="comment">// the first time that SP is being restored, then set the</span>
01866                 <span class="comment">// establisher frame pointers.</span>
01867                 <span class="comment">//</span>
01868 
01869                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Ra == SP_REG) &amp;&amp; (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01870                     EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
01871                     EstablisherFrame-&gt;Real = (ULONG_PTR)ContextRecord-&gt;IntSp;
01872                     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01873                 }
01874 
01875                 <span class="comment">//</span>
01876                 <span class="comment">// If a context pointer record is specified, then record</span>
01877                 <span class="comment">// the address where the destination register contents</span>
01878                 <span class="comment">// are stored.</span>
01879                 <span class="comment">//</span>
01880 
01881                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01882                     ContextPointers-&gt;IntegerContext[Ra] = (PULONGLONG)Address;
01883                 }
01884                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01885             }
01886             <span class="keywordflow">break</span>;
01887 
01888         <span class="keywordflow">case</span> LDAH_OP :
01889             Offset16 &lt;&lt;= 16;
01890 
01891         <span class="keywordflow">case</span> <a class="code" href="../../d5/d5/ia64_2alignem_8c.html#a3">LDA_OP</a> :
01892 
01893             <span class="comment">//</span>
01894             <span class="comment">// Load Address High, Load Address instruction.</span>
01895             <span class="comment">//</span>
01896             <span class="comment">// There are several cases where the lda and/or ldah instructions</span>
01897             <span class="comment">// are used: one to decrement the stack pointer directly, and the</span>
01898             <span class="comment">// others to load immediate values into another register and that</span>
01899             <span class="comment">// register is then used to decrement the stack pointer.</span>
01900             <span class="comment">//</span>
01901             <span class="comment">// In the examples below, as a single instructions or as a pair,</span>
01902             <span class="comment">// a lda may be substituted for a ldah and visa-versa.</span>
01903             <span class="comment">//</span>
01904 
01905             <span class="keywordflow">if</span> (Ra == SP_REG) {
01906                 <span class="keywordflow">if</span> (Rb == SP_REG) {
01907 
01908                     <span class="comment">//</span>
01909                     <span class="comment">// If both the destination (Ra) and base (Rb) registers</span>
01910                     <span class="comment">// are SP, then a standard stack allocation was performed</span>
01911                     <span class="comment">// and the negated displacement value is the stack frame</span>
01912                     <span class="comment">// size. The amount of stack allocation possible using</span>
01913                     <span class="comment">// the lda instruction ranges from 16 to 32768 bytes and</span>
01914                     <span class="comment">// the amount of stack allocation possible using the ldah</span>
01915                     <span class="comment">// instruction ranges from 65536 to 2GB in multiples of</span>
01916                     <span class="comment">// 65536 bytes. It is rare for the ldah instruction to be</span>
01917                     <span class="comment">// used in this manner.</span>
01918                     <span class="comment">//</span>
01919                     <span class="comment">// The prologue instruction sequence is:</span>
01920                     <span class="comment">//</span>
01921                     <span class="comment">// ==&gt;  lda   sp, -N(sp)    // allocate stack frame</span>
01922                     <span class="comment">//</span>
01923 
01924                     FrameSize = -Offset16;
01925                     <span class="keywordflow">goto</span> StackAllocation;
01926 
01927                 } <span class="keywordflow">else</span> {
01928 
01929                     <span class="comment">//</span>
01930                     <span class="comment">// The destination register is SP and the base register</span>
01931                     <span class="comment">// is not SP, so this instruction must be the second</span>
01932                     <span class="comment">// half of an instruction pair to allocate a large size</span>
01933                     <span class="comment">// (&gt;32768 bytes) stack frame. Save the displacement value</span>
01934                     <span class="comment">// as the partial decrement value and postpone adjusting</span>
01935                     <span class="comment">// the value of SP until the first instruction of the pair</span>
01936                     <span class="comment">// is encountered.</span>
01937                     <span class="comment">//</span>
01938                     <span class="comment">// The prologue instruction sequence is:</span>
01939                     <span class="comment">//</span>
01940                     <span class="comment">//      ldah  Rx, -N(sp)    // prepare new SP (upper)</span>
01941                     <span class="comment">// ==&gt;  lda   sp, sN(Rx)    // allocate stack frame</span>
01942                     <span class="comment">//</span>
01943 
01944                     DecrementRegister = Rb;
01945                     DecrementOffset = Offset16;
01946                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01947                 }
01948 
01949             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Ra == DecrementRegister) {
01950                 <span class="keywordflow">if</span> (Rb == DecrementRegister) {
01951 
01952                     <span class="comment">//</span>
01953                     <span class="comment">// Both the destination and base registers are the</span>
01954                     <span class="comment">// decrement register, so this instruction exists as the</span>
01955                     <span class="comment">// second half of a two instruction pair to load a</span>
01956                     <span class="comment">// 31-bit immediate value into the decrement register.</span>
01957                     <span class="comment">// Save the displacement value as the partial decrement</span>
01958                     <span class="comment">// value.</span>
01959                     <span class="comment">//</span>
01960                     <span class="comment">// The prologue instruction sequence is:</span>
01961                     <span class="comment">//</span>
01962                     <span class="comment">//      ldah  Rx, +N(zero)      // set frame size (upper)</span>
01963                     <span class="comment">// ==&gt;  lda   Rx, sN(Rx)        // set frame size (+lower)</span>
01964                     <span class="comment">//      ...</span>
01965                     <span class="comment">//      subq  sp, Rx, sp        // allocate stack frame</span>
01966                     <span class="comment">//</span>
01967 
01968                     DecrementOffset += Offset16;
01969                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01970 
01971                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rb == ZERO_REG) {
01972 
01973                     <span class="comment">//</span>
01974                     <span class="comment">// The destination register is the decrement register and</span>
01975                     <span class="comment">// the base register is zero, so this instruction exists</span>
01976                     <span class="comment">// to load an immediate value into the decrement register.</span>
01977                     <span class="comment">// The stack frame size is the new displacement value added</span>
01978                     <span class="comment">// to the previous displacement value, if any.</span>
01979                     <span class="comment">//</span>
01980                     <span class="comment">// The prologue instruction sequence is:</span>
01981                     <span class="comment">//</span>
01982                     <span class="comment">// ==&gt;  lda   Rx, +N(zero)      // set frame size</span>
01983                     <span class="comment">//      ...</span>
01984                     <span class="comment">//      subq  sp, Rx, sp        // allocate stack frame</span>
01985                     <span class="comment">// or</span>
01986                     <span class="comment">//</span>
01987                     <span class="comment">// ==&gt;  ldah  Rx, +N(zero)      // set frame size (upper)</span>
01988                     <span class="comment">//      lda   Rx, sN(Rx)        // set frame size (+lower)</span>
01989                     <span class="comment">//      ...</span>
01990                     <span class="comment">//      subq  sp, Rx, sp        // allocate stack frame</span>
01991                     <span class="comment">//</span>
01992 
01993                     FrameSize = (Offset16 + DecrementOffset);
01994                     <span class="keywordflow">goto</span> StackAllocation;
01995 
01996                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rb == SP_REG) {
01997 
01998                     <span class="comment">//</span>
01999                     <span class="comment">// The destination (Ra) register is SP and the base (Rb)</span>
02000                     <span class="comment">// register is the decrement register, so a two</span>
02001                     <span class="comment">// instruction, large size (&gt;32768 bytes) stack frame</span>
02002                     <span class="comment">// allocation was performed. Add the new displacement</span>
02003                     <span class="comment">// value to the previous displacement value. The negated</span>
02004                     <span class="comment">// displacement value is the stack frame size.</span>
02005                     <span class="comment">//</span>
02006                     <span class="comment">// The prologue instruction sequence is:</span>
02007                     <span class="comment">//</span>
02008                     <span class="comment">// ==&gt;  ldah  Rx, -N(sp)    // prepare new SP (upper)</span>
02009                     <span class="comment">//      lda   sp, sN(Rx)    // allocate stack frame</span>
02010                     <span class="comment">//</span>
02011 
02012                     FrameSize = -(Offset16 + (LONG)DecrementOffset);
02013                     <span class="keywordflow">goto</span> StackAllocation;
02014                 }
02015             }
02016             <span class="keywordflow">break</span>;
02017 
02018         <span class="keywordflow">case</span> ARITH_OP :
02019 
02020             <span class="keywordflow">if</span> ((Function == ADDQ_FUNC) &amp;&amp;
02021                 (Instruction.OpReg.RbvType != RBV_REGISTER_FORMAT)) {
02022 
02023                 <span class="comment">//</span>
02024                 <span class="comment">// Add Quadword (immediate) instruction.</span>
02025                 <span class="comment">//</span>
02026                 <span class="comment">// If the first source register is zero, and the second</span>
02027                 <span class="comment">// operand is a literal, and the destination register is</span>
02028                 <span class="comment">// the decrement register, then the instruction exists</span>
02029                 <span class="comment">// to load an unsigned immediate value less than 256 into</span>
02030                 <span class="comment">// the decrement register. The immediate value is the stack</span>
02031                 <span class="comment">// frame size.</span>
02032                 <span class="comment">//</span>
02033                 <span class="comment">// The prologue instruction sequence is:</span>
02034                 <span class="comment">//</span>
02035                 <span class="comment">// ==&gt;  addq  zero, N, Rx       // set frame size</span>
02036                 <span class="comment">//      ...</span>
02037                 <span class="comment">//      subq  sp, Rx, sp        // allocate stack frame</span>
02038                 <span class="comment">//</span>
02039 
02040                 <span class="keywordflow">if</span> ((Ra == ZERO_REG) &amp;&amp; (Rc == DecrementRegister)) {
02041                     FrameSize = Literal8;
02042                     <span class="keywordflow">goto</span> StackAllocation;
02043                 }
02044 
02045             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Function == SUBQ_FUNC) &amp;&amp;
02046                        (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT)) {
02047 
02048                 <span class="comment">//</span>
02049                 <span class="comment">// Subtract Quadword (register) instruction.</span>
02050                 <span class="comment">//</span>
02051                 <span class="comment">// If both source operands are registers and the first</span>
02052                 <span class="comment">// source (minuend) register and the destination</span>
02053                 <span class="comment">// (difference) register are both SP, then a register value</span>
02054                 <span class="comment">// stack allocation was performed and the second source</span>
02055                 <span class="comment">// (subtrahend) register value will be added to SP when its</span>
02056                 <span class="comment">// value is known. Until that time save the register number of</span>
02057                 <span class="comment">// this decrement register.</span>
02058                 <span class="comment">//</span>
02059                 <span class="comment">// The prologue instruction sequence is:</span>
02060                 <span class="comment">//</span>
02061                 <span class="comment">//      ldiq  Rx, N             // set frame size</span>
02062                 <span class="comment">//      ...</span>
02063                 <span class="comment">// ==&gt;  subq  sp, Rx, sp        // allocate stack frame</span>
02064                 <span class="comment">//</span>
02065 
02066                 <span class="keywordflow">if</span> ((Ra == SP_REG) &amp;&amp; (Rc == SP_REG)) {
02067                     DecrementRegister = Rb;
02068                     DecrementOffset = 0;
02069                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
02070                 }
02071             }
02072             <span class="keywordflow">break</span>;
02073 
02074         <span class="keywordflow">case</span> BIT_OP :
02075 
02076             <span class="comment">//</span>
02077             <span class="comment">// If the second operand is a register the bit set instruction</span>
02078             <span class="comment">// may be a register move instruction, otherwise if the second</span>
02079             <span class="comment">// operand is a literal, the bit set instruction may be a load</span>
02080             <span class="comment">// immediate value instruction.</span>
02081             <span class="comment">//</span>
02082 
02083             <span class="keywordflow">if</span> ((Function == BIS_FUNC) &amp;&amp; (Rc != ZERO_REG)) {
02084                 <span class="keywordflow">if</span> (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT) {
02085 
02086                     <span class="comment">//</span>
02087                     <span class="comment">// Bit Set (register move) instruction.</span>
02088                     <span class="comment">//</span>
02089                     <span class="comment">// If both source registers are the same register, or</span>
02090                     <span class="comment">// one of the source registers is zero, then this is a</span>
02091                     <span class="comment">// register move operation. Restore the value of the</span>
02092                     <span class="comment">// source register by copying the current destination</span>
02093                     <span class="comment">// register value back to the source register.</span>
02094                     <span class="comment">//</span>
02095                     <span class="comment">// The prologue instruction sequence is:</span>
02096                     <span class="comment">//</span>
02097                     <span class="comment">// ==&gt;  bis   Rx, Rx, Ry        // copy register Rx</span>
02098                     <span class="comment">// or</span>
02099                     <span class="comment">//</span>
02100                     <span class="comment">// ==&gt;  bis   Rx, zero, Ry      // copy register Rx</span>
02101                     <span class="comment">// or</span>
02102                     <span class="comment">//</span>
02103                     <span class="comment">// ==&gt;  bis   zero, Rx, Ry      // copy register Rx</span>
02104                     <span class="comment">//</span>
02105 
02106                     <span class="keywordflow">if</span> (Ra == ZERO_REG) {
02107 
02108                         <span class="comment">//</span>
02109                         <span class="comment">// Map the third case above to the first case.</span>
02110                         <span class="comment">//</span>
02111 
02112                         Ra = Rb;
02113 
02114                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rb == ZERO_REG) {
02115 
02116                         <span class="comment">//</span>
02117                         <span class="comment">// Map the second case above to the first case.</span>
02118                         <span class="comment">//</span>
02119 
02120                         Rb = Ra;
02121                     }
02122 
02123                     <span class="keywordflow">if</span> ((Ra == Rb) &amp;&amp; (Ra != ZERO_REG)) {
02124                         IntegerRegister[Ra] = IntegerRegister[Rc];
02125 
02126                         <span class="comment">//</span>
02127                         <span class="comment">// If the destination register is RA and this is the</span>
02128                         <span class="comment">// first time that RA is being restored, then set the</span>
02129                         <span class="comment">// address of where control left the previous frame.</span>
02130                         <span class="comment">// Otherwise, if this is the second time RA is being</span>
02131                         <span class="comment">// restored, then the first one was an interrupt or</span>
02132                         <span class="comment">// exception address and the return PC should not</span>
02133                         <span class="comment">// have been biased by 4.</span>
02134                         <span class="comment">//</span>
02135 
02136                         <span class="keywordflow">if</span> (Ra == RA_REG) {
02137                             <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02138                                 NextPc = (ULONG_PTR)ContextRecord-&gt;IntRa - 4;
02139                                 RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02140 
02141                             } <span class="keywordflow">else</span> {
02142                                 NextPc += 4;
02143                                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a5">_RtlpFoundTrapFrame</a>(NextPc);
02144                             }
02145 
02146                         <span class="comment">//</span>
02147                         <span class="comment">// If the source register is SP and this is the first</span>
02148                         <span class="comment">// time SP is set, then this is a frame pointer set</span>
02149                         <span class="comment">// instruction. Reset the frame pointers to this new</span>
02150                         <span class="comment">// value of SP.</span>
02151                         <span class="comment">//</span>
02152 
02153                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Ra == SP_REG) &amp;&amp; (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
02154                             EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
02155                             EstablisherFrame-&gt;Real = (ULONG_PTR)ContextRecord-&gt;IntSp;
02156                             RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02157                         }
02158 
02159                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
02160                     }
02161 
02162                 } <span class="keywordflow">else</span> {
02163 
02164                     <span class="comment">//</span>
02165                     <span class="comment">// Bit Set (load immediate) instruction.</span>
02166                     <span class="comment">//</span>
02167                     <span class="comment">// If the first source register is zero, and the second</span>
02168                     <span class="comment">// operand is a literal, and the destination register is</span>
02169                     <span class="comment">// the decrement register, then this instruction exists</span>
02170                     <span class="comment">// to load an unsigned immediate value less than 256 into</span>
02171                     <span class="comment">// the decrement register. The decrement register value is</span>
02172                     <span class="comment">// the stack frame size.</span>
02173                     <span class="comment">//</span>
02174                     <span class="comment">// The prologue instruction sequence is:</span>
02175                     <span class="comment">//</span>
02176                     <span class="comment">// ==&gt;  bis   zero, N, Rx       // set frame size</span>
02177                     <span class="comment">//      ...</span>
02178                     <span class="comment">//      subq  sp, Rx, sp        // allocate stack frame</span>
02179                     <span class="comment">//</span>
02180 
02181                     <span class="keywordflow">if</span> ((Ra == ZERO_REG) &amp;&amp; (Rc == DecrementRegister)) {
02182                         FrameSize = Literal8;
02183 StackAllocation:
02184                         <span class="comment">//</span>
02185                         <span class="comment">// Add the frame size to SP to reverse the stack frame</span>
02186                         <span class="comment">// allocation, leave the real frame pointer as is, set</span>
02187                         <span class="comment">// the virtual frame pointer with the updated SP value,</span>
02188                         <span class="comment">// and clear the decrement register.</span>
02189                         <span class="comment">//</span>
02190 
02191                         ContextRecord-&gt;IntSp += FrameSize;
02192                         EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
02193                         DecrementRegister = ZERO_REG;
02194                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
02195                     }
02196                 }
02197             }
02198             <span class="keywordflow">break</span>;
02199 
02200         <span class="keywordflow">case</span> STT_OP :
02201 
02202             <span class="comment">//</span>
02203             <span class="comment">// Store T-Floating (quadword integer) instruction.</span>
02204             <span class="comment">//</span>
02205             <span class="comment">// If the base register is SP, then reload the source register</span>
02206             <span class="comment">// value from the value stored on the stack.</span>
02207             <span class="comment">//</span>
02208             <span class="comment">// The prologue instruction sequence is:</span>
02209             <span class="comment">//</span>
02210             <span class="comment">// ==&gt;  stt   Fx, N(sp)         // save floating register Fx</span>
02211             <span class="comment">//</span>
02212 
02213             <span class="keywordflow">if</span> ((Rb == SP_REG) &amp;&amp; (Ra != FZERO_REG)) {
02214 
02215                 <span class="comment">//</span>
02216                 <span class="comment">// Reload the register by retrieving the value previously</span>
02217                 <span class="comment">// stored on the stack.</span>
02218                 <span class="comment">//</span>
02219 
02220                 Address = Offset16 + (LONG_PTR)ContextRecord-&gt;IntSp;
02221                 FloatingRegister[Ra] = *((PULONGLONG)Address);
02222 
02223                 <span class="comment">//</span>
02224                 <span class="comment">// If a context pointer record is specified, then record</span>
02225                 <span class="comment">// the address where the destination register contents are</span>
02226                 <span class="comment">// stored.</span>
02227                 <span class="comment">//</span>
02228 
02229                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
02230                     ContextPointers-&gt;FloatingContext[Ra] = (PULONGLONG)Address;
02231                 }
02232                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
02233             }
02234             <span class="keywordflow">break</span>;
02235 
02236         <span class="keywordflow">case</span> FPOP_OP :
02237 
02238             <span class="comment">//</span>
02239             <span class="comment">// N.B. The floating operate function field is not the same as</span>
02240             <span class="comment">// the integer operate nor the jump function fields.</span>
02241             <span class="comment">//</span>
02242 
02243             <span class="keywordflow">if</span> (Instruction.FpOp.Function == CPYS_FUNC) {
02244 
02245                 <span class="comment">//</span>
02246                 <span class="comment">// Copy Sign (floating-point move) instruction.</span>
02247                 <span class="comment">//</span>
02248                 <span class="comment">// If both source registers are the same register, then this is</span>
02249                 <span class="comment">// a floating-point register move operation. Restore the value</span>
02250                 <span class="comment">// of the source register by copying the current destination</span>
02251                 <span class="comment">// register value to the source register.</span>
02252                 <span class="comment">//</span>
02253                 <span class="comment">// The prologue instruction sequence is:</span>
02254                 <span class="comment">//</span>
02255                 <span class="comment">// ==&gt;  cpys  Fx, Fx, Fy        // copy floating register Fx</span>
02256                 <span class="comment">//</span>
02257 
02258                 <span class="keywordflow">if</span> ((Ra == Rb) &amp;&amp; (Ra != FZERO_REG)) {
02259                     FloatingRegister[Ra] = FloatingRegister[Rc];
02260                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
02261                 }
02262             }
02263 
02264         <span class="keywordflow">default</span> :
02265             <span class="keywordflow">break</span>;
02266         }
02267     }
02268     
02269     <span class="comment">// Check for exlicit stack adjust amount</span>
02270     
02271     <span class="keywordflow">if</span> (StackAdjust) {
02272         ContextRecord-&gt;IntSp += StackAdjust;
02273     }
02274 
02275     <span class="keywordflow">if</span> (FixedReturn != 0) {
02276         NextPc = FixedReturn;
02277     }
02278     
02279     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a6">_RtlpVirtualUnwindExit</a>(NextPc, ContextRecord, EstablisherFrame);
02280     <span class="keywordflow">return</span> NextPc;
02281 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="alpha/exdsptch.c::sprintf" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int __cdecl sprintf           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>...</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a7" doxytag="alpha/exdsptch.c::DynamicFunctionTable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> LIST_ENTRY <a class="el" href="../../d7/d9/ia64_2exdsptch_8c.html#a8">DynamicFunctionTable</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00137">137</a> of file <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html">alpha/exdsptch.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02869">RtlAddFunctionTable()</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02971">RtlDeleteFunctionTable()</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l02849">RtlGetFunctionTableListHead()</a>, and <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l03022">RtlLookupDynamicFunctionEntry()</a>.    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:43:35 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
