<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: heapdll.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>heapdll.c File Reference</h1><code>#include "<a class="el" href="../../d6/d8/ntrtlp_8h-source.html">ntrtlp.h</a>"</code><br>
<code>#include "<a class="el" href="../../d4/d8/heap_8h-source.html">heap.h</a>"</code><br>
<code>#include "<a class="el" href="../../d0/d9/heappriv_8h-source.html">heappriv.h</a>"</code><br>

<p>
<a href="../../d6/d8/heapdll_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">_RTL_HEAP_USAGE_INTERNAL</a></td></tr>

<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a0">RTLP_STATIC_HEAP_LIST_SIZE</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">_RTL_HEAP_USAGE_INTERNAL</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a1">RTL_HEAP_USAGE_INTERNAL</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">_RTL_HEAP_USAGE_INTERNAL</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a2">PRTL_HEAP_USAGE_INTERNAL</a></td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a7">RtlpGrowBlockInPlace</a> (IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap, IN ULONG Flags, IN <a class="el" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock, IN SIZE_T <a class="el" href="../../d9/d7/w98_2lh__open_2pi__mem_8h.html#a0">Size</a>, IN SIZE_T AllocationIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a8">RtlDebugReAllocateHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress, IN SIZE_T <a class="el" href="../../d9/d7/w98_2lh__open_2pi__mem_8h.html#a0">Size</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a9">RtlDebugGetUserInfoHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress, OUT PVOID *UserValue OPTIONAL, OUT PULONG UserFlags OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a10">RtlDebugSetUserValueHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress, IN PVOID UserValue)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a11">RtlDebugSetUserFlagsHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress, IN ULONG UserFlagsReset, IN ULONG UserFlagsSet)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SIZE_T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a12">RtlDebugCompactHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a13">RtlDebugCreateTagHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PWSTR TagPrefix OPTIONAL, IN PWSTR TagNames)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PWSTR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a14">RtlDebugQueryTagHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a> TagIndex, IN BOOLEAN ResetCounters, OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a15">RtlDebugUsageHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN OUT PRTL_HEAP_USAGE Usage)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a16">RtlDebugWalkHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN OUT PRTL_HEAP_WALK_ENTRY Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a17">RtlpAllocateTags</a> (<a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap, ULONG NumberOfTags)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PRTL_HEAP_USAGE_ENTRY&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a18">RtlpFreeHeapUsageEntry</a> (<a class="el" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">PRTL_HEAP_USAGE_INTERNAL</a> <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>, PRTL_HEAP_USAGE_ENTRY p)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a19">RtlpAllocateHeapUsageEntry</a> (<a class="el" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">PRTL_HEAP_USAGE_INTERNAL</a> <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>, PRTL_HEAP_USAGE_ENTRY *pp)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a20">RtlInitializeHeapManager</a> (VOID)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a21">RtlProtectHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN BOOLEAN MakeReadOnly)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a22">RtlLockHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a23">RtlUnlockHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a24">RtlReAllocateHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress, IN SIZE_T <a class="el" href="../../d9/d7/w98_2lh__open_2pi__mem_8h.html#a0">Size</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a25">RtlGetUserInfoHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress, OUT PVOID *UserValue OPTIONAL, OUT PULONG UserFlags OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a26">RtlSetUserValueHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress, IN PVOID UserValue)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a27">RtlSetUserFlagsHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress, IN ULONG UserFlagsReset, IN ULONG UserFlagsSet)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a28">RtlCreateTagHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PWSTR TagPrefix OPTIONAL, IN PWSTR TagNames)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PWSTR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a29">RtlQueryTagHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a> TagIndex, IN BOOLEAN ResetCounters, OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a30">RtlExtendHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID Base, IN SIZE_T <a class="el" href="../../d9/d7/w98_2lh__open_2pi__mem_8h.html#a0">Size</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SIZE_T NTAPI&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a31">RtlCompactHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a32">RtlValidateHeap</a> (PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN PVOID BaseAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a33">RtlValidateProcessHeaps</a> (VOID)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a34">RtlGetProcessHeaps</a> (ULONG NumberOfHeapsToReturn, PVOID *ProcessHeaps)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a35">RtlEnumProcessHeaps</a> (PRTL_ENUM_HEAPS_ROUTINE EnumRoutine, PVOID Parameter)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a36">RtlUsageHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN ULONG Flags, IN OUT PRTL_HEAP_USAGE Usage)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a37">RtlWalkHeap</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, IN OUT PRTL_HEAP_WALK_ENTRY Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a38">RtlpCheckHeapSignature</a> (IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap, IN PCHAR Caller)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a39">RtlpCoalesceHeap</a> (IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a40">RtlpAddHeapToProcessList</a> (IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a41">RtlpRemoveHeapFromProcessList</a> (IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PWSTR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a42">RtlpGetTagName</a> (<a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap, <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a> TagIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a43">RtlpUpdateTagEntry</a> (<a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap, <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a> TagIndex, SIZE_T OldSize, SIZE_T NewSize, <a class="el" href="../../d9/d9/heappriv_8h.html#a24">HEAP_TAG_ACTION</a> <a class="el" href="../../d9/d3/rules_8c.html#a7">Action</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a44">RtlpResetTags</a> (<a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a45">RtlpDestroyTags</a> (<a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a46">RtlpHeapIsLocked</a> (IN PVOID <a class="el" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>)</td></tr>

<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d4/d6/struct__HEAP__LOCK.html">HEAP_LOCK</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a4">RtlpProcessHeapsListBuffer</a> [RTLP_STATIC_HEAP_LIST_SIZE]</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a5">RtlpGlobalTagHeap</a> = NULL</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>WCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d9/heapdll_8c.html#a6">RtlpPseudoTagNameBuffer</a> [24]</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a0" doxytag="heapdll.c::RTLP_STATIC_HEAP_LIST_SIZE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define RTLP_STATIC_HEAP_LIST_SIZE&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00059">59</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00179">RtlInitializeHeapManager()</a>.    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a2" doxytag="heapdll.c::PRTL_HEAP_USAGE_INTERNAL" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">_RTL_HEAP_USAGE_INTERNAL</a> * <a class="el" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">PRTL_HEAP_USAGE_INTERNAL</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02976">RtlUsageHeap()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="heapdll.c::RTL_HEAP_USAGE_INTERNAL" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">_RTL_HEAP_USAGE_INTERNAL</a>  <a class="el" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">RTL_HEAP_USAGE_INTERNAL</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a31" doxytag="heapdll.c::RtlCompactHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SIZE_T NTAPI RtlCompactHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02401">2401</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00234">HEAP_MAXIMUM_SEGMENTS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00265">_HEAP_SEGMENT::LargestUnCommittedRange</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01260">RtlDebugCompactHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04312">RtlpCoalesceHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00355">_HEAP::Segments</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00174">_HEAP_FREE_ENTRY::Size</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01260">RtlDebugCompactHeap()</a>.
<p>
<pre class="fragment"><div>02408                    :
02409 
02410     This routine compacts <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified heap by coalescing all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> free block.
02411     It also determines <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> largest available free block and
02412     returns its, in bytes, back to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller.
02413 
02414 Arguments:
02415 
02416     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified
02417 
02418     Flags - Supplies a set of flags used to augment those already
02419         enforced by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
02420 
02421 Return Value:
02422 
02423     SIZE_T - Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> largest free block
02424         available in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
02425 
02426 --*/
02427 
02428 {
02429     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
02430     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock;
02431     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
02432     UCHAR SegmentIndex;
02433     SIZE_T LargestFreeSize;
02434     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02435 
02436     <span class="comment">//</span>
02437     <span class="comment">//  Augment the heap flags</span>
02438     <span class="comment">//</span>
02439 
02440     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
02441 
02442     <span class="comment">//</span>
02443     <span class="comment">//  Check if this is a debug version of heap</span>
02444     <span class="comment">//</span>
02445 
02446     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
02447 
02448         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a12">RtlDebugCompactHeap</a>( HeapHandle, Flags );
02449     }
02450 
02451     <span class="keywordflow">try</span> {
02452 
02453         <span class="comment">//</span>
02454         <span class="comment">//  Lock the heap</span>
02455         <span class="comment">//</span>
02456 
02457         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
02458 
02459             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02460 
02461             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02462         }
02463 
02464         LargestFreeSize = 0;
02465 
02466         <span class="keywordflow">try</span> {
02467 
02468             <span class="comment">//</span>
02469             <span class="comment">//  Coalesce the heap into its largest free blocks possible</span>
02470             <span class="comment">//  and get the largest free block in the heap</span>
02471             <span class="comment">//</span>
02472 
02473             FreeBlock = <a class="code" href="../../d9/d9/heappriv_8h.html#a45">RtlpCoalesceHeap</a>( (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)HeapHandle );
02474 
02475             <span class="comment">//</span>
02476             <span class="comment">//  If there is a free block then compute its byte size</span>
02477             <span class="comment">//</span>
02478 
02479             <span class="keywordflow">if</span> (FreeBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02480 
02481                 LargestFreeSize = FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
02482             }
02483 
02484             <span class="comment">//</span>
02485             <span class="comment">//  Scan every segment in the heap looking at its largest uncommitted</span>
02486             <span class="comment">//  range.  Remember the largest range if its bigger than anything</span>
02487             <span class="comment">//  we've found so far</span>
02488             <span class="comment">//</span>
02489 
02490             <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
02491 
02492                 Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
02493 
02494                 <span class="keywordflow">if</span> (Segment &amp;&amp; Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o4">LargestUnCommittedRange</a> &gt; LargestFreeSize) {
02495 
02496                     LargestFreeSize = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o4">LargestUnCommittedRange</a>;
02497                 }
02498             }
02499 
02500         } except( EXCEPTION_EXECUTE_HANDLER ) {
02501 
02502             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
02503         }
02504 
02505     } finally {
02506 
02507         <span class="comment">//</span>
02508         <span class="comment">//  Unlock the heap</span>
02509         <span class="comment">//</span>
02510 
02511         <span class="keywordflow">if</span> (LockAcquired) {
02512 
02513             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02514         }
02515     }
02516 
02517     <span class="comment">//</span>
02518     <span class="comment">//  And return the largest free size to our caller</span>
02519     <span class="comment">//</span>
02520 
02521     <span class="keywordflow">return</span> LargestFreeSize;
02522 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="heapdll.c::RtlCreateTagHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlCreateTagHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PWSTR TagPrefix&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PWSTR&nbsp;</td>
          <td class="mdname" nowrap> <em>TagNames</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01603">1603</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d4/d6/config_2utils_2regutil_8c-source.html#l00022">RtlAllocateHeap</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01421">RtlDebugCreateTagHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05225">RtlpAllocateTags()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00462">RtlpGlobalTagHeap</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00306">_HEAP_TAG_ENTRY::TagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00308">_HEAP_TAG_ENTRY::TagName</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d2/d9/csrinit_8c-source.html#l00106">CsrClientConnectToServer()</a>, <a class="el" href="../../d2/d9/csrinit_8c-source.html#l00359">CsrpConnectToServer()</a>, <a class="el" href="../../d1/d9/heaptag_8c-source.html#l00191">LdrpDefineDllTag()</a>, <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00616">LdrpInitializeProcess()</a>, <a class="el" href="../../d2/d0/theap_8c-source.html#l00077">main()</a>, and <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01421">RtlDebugCreateTagHeap()</a>.
<p>
<pre class="fragment"><div>01612                    :
01613 
01614     This routine create a tag heap <span class="keywordflow">for</span> either <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified heap or
01615     <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> global tag heap.
01616 
01617 Arguments:
01618 
01619     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Optionally supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap that we
01620         want modified.  If null then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> global tag heap <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used
01621 
01622     Flags - Supplies a list of flags to augment <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> flags already
01623         enforced by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
01624 
01625     TagPrefix - Optionally supplies a null terminated wchar string
01626         of a prefix to add to each tag
01627 
01628     TagNames - Supplies a list of tag names separated by null and terminated
01629         by a <span class="keywordtype">double</span> null.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first name in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list start with
01630         a <span class="stringliteral">"!"</span> then <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> interpreted as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap name.  The syntax
01631         <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag name <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
01632 
01633             [!&lt;heapname&gt; nul ] {&lt;tagname&gt; nul}* nul
01634 
01635 Return Value:
01636 
01637     ULONG - returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> index of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last tag create shifted to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d3/fetypes_8h.html#a457a417">high</a>
01638         order word.
01639 
01640 --*/
01641 
01642 {
01643     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01644     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01645     ULONG TagIndex;
01646     ULONG NumberOfTags, MaxTagNameLength, TagPrefixLength;
01647     PWSTR s, s1, HeapName;
01648     <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> TagEntry;
01649     ULONG Result;
01650 
01651     <span class="comment">//</span>
01652     <span class="comment">//  Check if tagging is disable and so this call is a noop</span>
01653     <span class="comment">//</span>
01654 
01655     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
01656 
01657         <span class="keywordflow">return</span> 0;
01658     }
01659 
01660     <span class="comment">//</span>
01661     <span class="comment">//  If the processes global tag heap has not been created yet then</span>
01662     <span class="comment">//  allocate a global tag heap</span>
01663     <span class="comment">//</span>
01664 
01665     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01666 
01667         <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( RtlProcessHeap( ), HEAP_ZERO_MEMORY, <span class="keyword">sizeof</span>( <a class="code" href="../../d5/d5/struct__HEAP.html">HEAP</a> ));
01668 
01669         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01670 
01671             <span class="keywordflow">return</span> 0;
01672         }
01673     }
01674 
01675     <span class="keywordflow">try</span> {
01676 
01677         <span class="comment">//</span>
01678         <span class="comment">//  If the user passed in a heap then we'll use the lock from that</span>
01679         <span class="comment">//  heap to synchronize our work.  Otherwise we're unsynchronized</span>
01680         <span class="comment">//</span>
01681 
01682         <span class="keywordflow">if</span> (Heap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01683 
01684             <span class="comment">//</span>
01685             <span class="comment">//  Tagging is not part of the guard page heap package</span>
01686             <span class="comment">//</span>
01687 
01688             <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle, 0 );
01689 
01690             <span class="comment">//</span>
01691             <span class="comment">//  Check if we should be calling the debug version of the heap package</span>
01692             <span class="comment">//</span>
01693 
01694             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
01695 
01696                 Result = <a class="code" href="../../d5/d9/heapdll_8c.html#a13">RtlDebugCreateTagHeap</a>( HeapHandle, Flags, TagPrefix, TagNames );
01697                 leave;
01698             }
01699 
01700             <span class="comment">//</span>
01701             <span class="comment">//  Augment the flags and lock the specified heap</span>
01702             <span class="comment">//</span>
01703 
01704             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
01705 
01706             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01707 
01708                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01709 
01710                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01711             }
01712         }
01713 
01714         <span class="comment">//</span>
01715         <span class="comment">//  We start off with zero tags</span>
01716         <span class="comment">//</span>
01717 
01718         TagIndex = 0;
01719         NumberOfTags = 0;
01720 
01721         <span class="comment">//</span>
01722         <span class="comment">//  With tag names that start with "!" we assume what follows</span>
01723         <span class="comment">//  is a heap name.</span>
01724         <span class="comment">//</span>
01725 
01726         <span class="keywordflow">if</span> (*TagNames == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'!'</span>) {
01727 
01728             HeapName = TagNames + 1;
01729 
01730             <span class="comment">//</span>
01731             <span class="comment">//  Move up to the following tag name after the heap name</span>
01732             <span class="comment">//  separated by a null</span>
01733             <span class="comment">//</span>
01734 
01735             <span class="keywordflow">while</span> (*TagNames++) { NOTHING; }
01736 
01737         } <span class="keywordflow">else</span> {
01738 
01739             HeapName = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01740         }
01741 
01742         <span class="comment">//</span>
01743         <span class="comment">//  Gobble up each tag name keeping count of how many we find</span>
01744         <span class="comment">//</span>
01745 
01746         s = TagNames;
01747 
01748         <span class="keywordflow">while</span> (*s) {
01749 
01750             <span class="keywordflow">while</span> (*s++) { NOTHING; }
01751 
01752             NumberOfTags += 1;
01753         }
01754 
01755         <span class="comment">//</span>
01756         <span class="comment">//  Now we will only continue on if we were supplied tag names</span>
01757         <span class="comment">//</span>
01758 
01759         <span class="keywordflow">if</span> (NumberOfTags &gt; 0) {
01760 
01761             <span class="comment">//</span>
01762             <span class="comment">//  Allocate heap entries for the number of tags we need and</span>
01763             <span class="comment">//  only proceed if this allocation succeeded.   The following</span>
01764             <span class="comment">//  call also makes room for the heap name as tag index 0.  Note</span>
01765             <span class="comment">//  that is heap is null then we assume we're using the global</span>
01766             <span class="comment">//  tag heap</span>
01767             <span class="comment">//</span>
01768 
01769             TagEntry = <a class="code" href="../../d5/d9/heapdll_8c.html#a17">RtlpAllocateTags</a>( Heap, NumberOfTags );
01770 
01771             <span class="keywordflow">if</span> (TagEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01772 
01773                 MaxTagNameLength = (<span class="keyword">sizeof</span>( TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a> ) / <span class="keyword">sizeof</span>( WCHAR )) - 1;
01774 
01775                 TagIndex = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o3">TagIndex</a>;
01776 
01777                 <span class="comment">//</span>
01778                 <span class="comment">//  If the first tag index is zero then we'll make this tag entry</span>
01779                 <span class="comment">//  the heap name.</span>
01780                 <span class="comment">//</span>
01781 
01782                 <span class="keywordflow">if</span> (TagIndex == 0) {
01783 
01784                     <span class="keywordflow">if</span> (HeapName != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
01785 
01786                         <span class="comment">//</span>
01787                         <span class="comment">//  Copy over the heap name and pad it out with nulls up</span>
01788                         <span class="comment">//  to the end of the name buffer</span>
01789                         <span class="comment">//</span>
01790 
01791                         wcsncpy( TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>, HeapName, MaxTagNameLength );
01792                     }
01793 
01794                     <span class="comment">//</span>
01795                     <span class="comment">//  Whether we add a heap name or not we'll move on to the</span>
01796                     <span class="comment">//  next tag entry and index</span>
01797                     <span class="comment">//</span>
01798 
01799                     TagEntry += 1;
01800 
01801                     TagIndex = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o3">TagIndex</a>;
01802 
01803                 <span class="comment">//</span>
01804                 <span class="comment">//  This isn't the first index for a specified heap, but see if</span>
01805                 <span class="comment">//  it is the first index for the global heap.  If so then put</span>
01806                 <span class="comment">//  name of the global tags into the 0 index</span>
01807                 <span class="comment">//</span>
01808 
01809                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex == HEAP_GLOBAL_TAG) {
01810 
01811                     wcsncpy( TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>, L<span class="stringliteral">"GlobalTags"</span>, MaxTagNameLength );
01812 
01813                     TagEntry += 1;
01814 
01815                     TagIndex = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o3">TagIndex</a>;
01816                 }
01817 
01818                 <span class="comment">//</span>
01819                 <span class="comment">//  Now we've taken case of the 0 index we'll go on to the rest of</span>
01820                 <span class="comment">//  the tags.  If there is tag prefix and it is not zero length</span>
01821                 <span class="comment">//  then we'll use this tag prefix provided that is leaves us at</span>
01822                 <span class="comment">//  least 4 characters for the tag name itself.  Otherwise we'll</span>
01823                 <span class="comment">//  ignore the tag prefix (by setting the variable to null).</span>
01824                 <span class="comment">//</span>
01825 
01826                 <span class="keywordflow">if</span> ((ARGUMENT_PRESENT( TagPrefix )) &amp;&amp;
01827                     (TagPrefixLength = wcslen( TagPrefix ))) {
01828 
01829                     <span class="keywordflow">if</span> (TagPrefixLength &gt;= MaxTagNameLength-4) {
01830 
01831                         TagPrefix = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01832 
01833                     } <span class="keywordflow">else</span> {
01834 
01835                         MaxTagNameLength -= TagPrefixLength;
01836                     }
01837 
01838                 } <span class="keywordflow">else</span> {
01839 
01840                     TagPrefix = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01841                 }
01842 
01843                 <span class="comment">//</span>
01844                 <span class="comment">//  For every tag name (note that this varable has already been</span>
01845                 <span class="comment">//  advanced beyond the heap name) we'll put it in a tag entry</span>
01846                 <span class="comment">//  by copying in the prefix and then appending on the tag itself</span>
01847                 <span class="comment">//</span>
01848                 <span class="comment">//   s points to the current users supplied tag name</span>
01849                 <span class="comment">//  s1 points to the tag name buffer in the current tag entry</span>
01850                 <span class="comment">//</span>
01851 
01852                 s = TagNames;
01853 
01854                 <span class="keywordflow">while</span> (*s) {
01855 
01856                     s1 = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>;
01857 
01858                     <span class="comment">//</span>
01859                     <span class="comment">//  Copy in the optional tag prefix and update s1</span>
01860                     <span class="comment">//</span>
01861 
01862                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( TagPrefix )) {
01863 
01864                         wcscpy( s1, TagPrefix );
01865 
01866                         s1 += TagPrefixLength;
01867                     }
01868 
01869                     <span class="comment">//</span>
01870                     <span class="comment">//  Copy over the remaining tag name padding it with nulls</span>
01871                     <span class="comment">//  up to the end of the name buffer</span>
01872                     <span class="comment">//</span>
01873 
01874                     wcsncpy( s1, s, MaxTagNameLength );
01875 
01876                     <span class="comment">//</span>
01877                     <span class="comment">//  Skip to the next tag name</span>
01878                     <span class="comment">//</span>
01879 
01880                     <span class="keywordflow">while</span> (*s++) { NOTHING; }
01881 
01882                     <span class="comment">//</span>
01883                     <span class="comment">//  Skip to the next tag entry</span>
01884                     <span class="comment">//</span>
01885 
01886                     TagEntry += 1;
01887                 }
01888             }
01889         }
01890 
01891         Result = TagIndex &lt;&lt; HEAP_TAG_SHIFT;
01892 
01893     } finally {
01894 
01895         <span class="comment">//</span>
01896         <span class="comment">//  Unlock the heap</span>
01897         <span class="comment">//</span>
01898 
01899         <span class="keywordflow">if</span> (LockAcquired) {
01900 
01901             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01902         }
01903     }
01904 
01905     <span class="comment">//</span>
01906     <span class="comment">//  And return to our caller.  The answer we return is the last tag index</span>
01907     <span class="comment">//  stored in the high word of a ulong result</span>
01908     <span class="comment">//</span>
01909 
01910     <span class="keywordflow">return</span> Result;
01911 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="heapdll.c::RtlDebugCompactHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SIZE_T RtlDebugCompactHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01260">1260</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02401">RtlCompactHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03512">RtlpDebugPageHeapCompact()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00112">RtlpValidateHeapHeaders()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02401">RtlCompactHeap()</a>.
<p>
<pre class="fragment"><div>01267                    :
01268 
01269 Arguments:
01270 
01271 Return Value:
01272 
01273 --*/
01274 
01275 {
01276     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01277     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01278     SIZE_T LargestFreeSize;
01279 
01280     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
01281                                     <a class="code" href="../../d7/d9/heappage_8h.html#a16">RtlpDebugPageHeapCompact</a>( HeapHandle, Flags ));
01282 
01283     LargestFreeSize = 0;
01284 
01285     <span class="keywordflow">try</span> {
01286 
01287         <span class="keywordflow">try</span> {
01288 
01289             <span class="comment">//</span>
01290             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
01291             <span class="comment">//</span>
01292 
01293             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlCompactHeap"</span> )) {
01294 
01295                 LargestFreeSize = 0;
01296                 leave;
01297             }
01298 
01299             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
01300 
01301             <span class="comment">//</span>
01302             <span class="comment">//  Lock the heap</span>
01303             <span class="comment">//</span>
01304 
01305             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01306 
01307                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01308 
01309                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01310 
01311                 Flags |= HEAP_NO_SERIALIZE;
01312             }
01313 
01314             <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
01315 
01316             LargestFreeSize = <a class="code" href="../../d5/d9/heapdll_8c.html#a31">RtlCompactHeap</a>( HeapHandle, Flags );
01317 
01318             <a class="code" href="../../d9/d9/heappriv_8h.html#a50">RtlpValidateHeapHeaders</a>( Heap, TRUE );
01319 
01320         } except( EXCEPTION_EXECUTE_HANDLER ) {
01321 
01322             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01323         }
01324 
01325     } finally {
01326 
01327         <span class="keywordflow">if</span> (LockAcquired) {
01328 
01329             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01330         }
01331     }
01332 
01333     <span class="keywordflow">return</span> LargestFreeSize;
01334 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="heapdll.c::RtlDebugCreateTagHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS RtlDebugCreateTagHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PWSTR TagPrefix&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PWSTR&nbsp;</td>
          <td class="mdname" nowrap> <em>TagNames</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01421">1421</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01603">RtlCreateTagHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00112">RtlpValidateHeapHeaders()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01603">RtlCreateTagHeap()</a>.
<p>
<pre class="fragment"><div>01430                    :
01431 
01432 Arguments:
01433 
01434 Return Value:
01435 
01436 --*/
01437 
01438 {
01439     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01440     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01441     ULONG TagIndex;
01442 
01443     TagIndex = 0;
01444 
01445     <span class="keywordflow">try</span> {
01446 
01447         <span class="keywordflow">try</span> {
01448 
01449             <span class="comment">//</span>
01450             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
01451             <span class="comment">//</span>
01452 
01453             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlCreateTagHeap"</span> )) {
01454 
01455                 Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
01456 
01457                 <span class="comment">//</span>
01458                 <span class="comment">//  Lock the heap</span>
01459                 <span class="comment">//</span>
01460 
01461                 <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01462 
01463                     <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01464 
01465                     LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01466 
01467                     Flags |= HEAP_NO_SERIALIZE;
01468                 }
01469 
01470                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE )) {
01471 
01472                     TagIndex = <a class="code" href="../../d5/d9/heapdll_8c.html#a28">RtlCreateTagHeap</a>( HeapHandle, Flags, TagPrefix, TagNames );
01473                 }
01474 
01475                 <a class="code" href="../../d9/d9/heappriv_8h.html#a50">RtlpValidateHeapHeaders</a>( Heap, TRUE );
01476             }
01477 
01478         } except( EXCEPTION_EXECUTE_HANDLER ) {
01479 
01480             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01481         }
01482 
01483     } finally {
01484 
01485         <span class="keywordflow">if</span> (LockAcquired) {
01486 
01487             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01488         }
01489     }
01490 
01491     <span class="keywordflow">return</span> TagIndex;
01492 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="heapdll.c::RtlDebugGetUserInfoHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlDebugGetUserInfoHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *UserValue&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG UserFlags&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00919">919</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01192">RtlGetUserInfoHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03683">RtlpDebugPageHeapGetUserInfo()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01696">RtlpValidateHeapEntry()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01192">RtlGetUserInfoHeap()</a>.
<p>
<pre class="fragment"><div>00929                    :
00930 
00931 Arguments:
00932 
00933 Return Value:
00934 
00935 --*/
00936 
00937 {
00938     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00939     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
00940     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00941     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00942 
00943     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
00944                                     <a class="code" href="../../d7/d9/heappage_8h.html#a22">RtlpDebugPageHeapGetUserInfo</a>( HeapHandle, Flags, BaseAddress, UserValue, UserFlags ));
00945 
00946     <span class="keywordflow">try</span> {
00947 
00948         <span class="keywordflow">try</span> {
00949 
00950             <span class="comment">//</span>
00951             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
00952             <span class="comment">//</span>
00953 
00954             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlGetUserInfoHeap"</span> )) {
00955 
00956                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00957                 leave;
00958             }
00959 
00960             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
00961 
00962             <span class="comment">//</span>
00963             <span class="comment">//  Lock the heap</span>
00964             <span class="comment">//</span>
00965 
00966             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
00967 
00968                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00969 
00970                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00971 
00972                 Flags |= HEAP_NO_SERIALIZE;
00973             }
00974 
00975             <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
00976 
00977             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
00978 
00979             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a47">RtlpValidateHeapEntry</a>( Heap, BusyBlock, <span class="stringliteral">"RtlGetUserInfoHeap"</span> )) {
00980 
00981                 Result = <a class="code" href="../../d5/d9/heapdll_8c.html#a25">RtlGetUserInfoHeap</a>( HeapHandle, Flags, BaseAddress, UserValue, UserFlags );
00982             }
00983 
00984         } except( EXCEPTION_EXECUTE_HANDLER ) {
00985 
00986             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
00987         }
00988 
00989     } finally {
00990 
00991         <span class="keywordflow">if</span> (LockAcquired) {
00992 
00993             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00994         }
00995     }
00996 
00997     <span class="keywordflow">return</span> Result;
00998 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="heapdll.c::RtlDebugQueryTagHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PWSTR RtlDebugQueryTagHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>TagIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>ResetCounters</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PRTL_HEAP_TAG_INFO TagInfo&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01498">1498</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01919">RtlQueryTagHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01919">RtlQueryTagHeap()</a>.
<p>
<pre class="fragment"><div>01508                    :
01509 
01510 Arguments:
01511 
01512 Return Value:
01513 
01514 --*/
01515 
01516 {
01517     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01518     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01519     PWSTR Result;
01520 
01521     Result = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01522 
01523     <span class="keywordflow">try</span> {
01524 
01525         <span class="keywordflow">try</span> {
01526 
01527             <span class="comment">//</span>
01528             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
01529             <span class="comment">//</span>
01530 
01531             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlQueryTagHeap"</span> )) {
01532 
01533                 Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
01534 
01535                 <span class="comment">//</span>
01536                 <span class="comment">//  Lock the heap</span>
01537                 <span class="comment">//</span>
01538 
01539                 <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01540 
01541                     <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01542 
01543                     LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01544 
01545                     Flags |= HEAP_NO_SERIALIZE;
01546                 }
01547 
01548                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE )) {
01549 
01550                     Result = <a class="code" href="../../d5/d9/heapdll_8c.html#a29">RtlQueryTagHeap</a>( HeapHandle, Flags, TagIndex, ResetCounters, TagInfo );
01551                 }
01552             }
01553 
01554         } except( EXCEPTION_EXECUTE_HANDLER ) {
01555 
01556             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01557         }
01558 
01559     } finally {
01560 
01561         <span class="keywordflow">if</span> (LockAcquired) {
01562 
01563             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01564         }
01565     }
01566 
01567     <span class="keywordflow">return</span> Result;
01568 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="heapdll.c::RtlDebugReAllocateHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID RtlDebugReAllocateHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>Size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00603">603</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00351">_HEAP::AlignMask</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00350">_HEAP::AlignRound</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00113">_HEAP_ENTRY_EXTRA::AllocatorBackTraceIndex</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00056">EXCEPTION_CONTINUE_SEARCH</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00392">HEAP_CAPTURE_STACK_BACKTRACES</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00440">_HEAP_STOP_ON_TAG::HeapAndTagIndex</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00134">HeapDebugBreak</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00443">_HEAP_STOP_ON_TAG::HeapIndex</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00332">_HEAP::MaximumAllocationSize</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00333">_HEAP::ProcessHeapsListIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00451">_HEAP_STOP_ON_VALUES::ReAllocAddress</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00452">_HEAP_STOP_ON_VALUES::ReAllocTag</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l02895">RtlpDebugPageHeapReAllocate()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06008">RtlpGetExtraStuffPointer()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05425">RtlpGetTagName()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00463">RtlpHeapStopOn</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01696">RtlpValidateHeapEntry()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00112">RtlpValidateHeapHeaders()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00518">RtlReAllocateHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00091">_HEAP_ENTRY::SmallTagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00442">_HEAP_STOP_ON_TAG::TagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00121">_HEAP_ENTRY_EXTRA::TagIndex</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00518">RtlReAllocateHeap()</a>.
<p>
<pre class="fragment"><div>00612                    :
00613 
00614 Arguments:
00615 
00616 Return Value:
00617 
00618 --*/
00619 
00620 {
00621     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00622     SIZE_T AllocationSize;
00623     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
00624     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
00625     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00626     PVOID ReturnValue = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00627     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> TagIndex;
00628 
00629     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
00630                                     <a class="code" href="../../d7/d9/heappage_8h.html#a12">RtlpDebugPageHeapReAllocate</a>( HeapHandle, Flags, BaseAddress, Size ));
00631 
00632     <span class="keywordflow">try</span> {
00633 
00634         <span class="keywordflow">try</span> {
00635 
00636             <span class="comment">//</span>
00637             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
00638             <span class="comment">//</span>
00639 
00640             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlReAllocateHeap"</span> )) {
00641 
00642                 ReturnValue = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00643                 leave;
00644             }
00645 
00646             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | HEAP_SETTABLE_USER_VALUE | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
00647 
00648             <span class="comment">//</span>
00649             <span class="comment">//  Verify that the size did not wrap or exceed the limit for this heap.</span>
00650             <span class="comment">//</span>
00651 
00652             AllocationSize = (((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> ? <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> : 1) + Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o19">AlignRound</a>) &amp; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o20">AlignMask</a>) +
00653                              <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">HEAP_ENTRY_EXTRA</a> );
00654 
00655             <span class="keywordflow">if</span> (AllocationSize &lt; Size || AllocationSize &gt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o10">MaximumAllocationSize</a>) {
00656 
00657                 <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Invalid allocation size - %lx (exceeded %x)\n"</span>,
00658                                  Size,
00659                                  Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o10">MaximumAllocationSize</a> ));
00660 
00661                 <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00662 
00663                 ReturnValue = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00664                 leave;
00665             }
00666 
00667             <span class="comment">//</span>
00668             <span class="comment">//  Lock the heap</span>
00669             <span class="comment">//</span>
00670 
00671             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
00672 
00673                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00674 
00675                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00676 
00677                 Flags |= HEAP_NO_SERIALIZE;
00678             }
00679 
00680             <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
00681             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
00682 
00683             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a47">RtlpValidateHeapEntry</a>( Heap, BusyBlock, <span class="stringliteral">"RtlReAllocateHeap"</span> )) {
00684 
00685                 <span class="keywordflow">if</span> ((ULONG_PTR)BaseAddress == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o2">ReAllocAddress</a>) {
00686 
00687                     <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"About to reallocate block at %lx to 0x%x bytes\n"</span>,
00688                                      <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o2">ReAllocAddress</a>,
00689                                      Size ));
00690 
00691                     <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00692 
00693                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>() &amp;&amp; <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o3">ReAllocTag</a>.<a class="code" href="../../d9/d6/struct__HEAP__STOP__ON__TAG.html#o0">HeapAndTagIndex</a> != 0) {
00694 
00695                     <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
00696 
00697                         ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
00698                         TagIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>;
00699 
00700                     } <span class="keywordflow">else</span> {
00701 
00702                         TagIndex = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a>;
00703                     }
00704 
00705                     <span class="keywordflow">if</span> ((TagIndex != 0) &amp;&amp;
00706                         (TagIndex == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o3">ReAllocTag</a>.<a class="code" href="../../d9/d6/struct__HEAP__STOP__ON__TAG.html#o1">TagIndex</a>) &amp;&amp;
00707                         (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o11">ProcessHeapsListIndex</a> == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o3">ReAllocTag</a>.<a class="code" href="../../d9/d6/struct__HEAP__STOP__ON__TAG.html#o2">HeapIndex</a>)) {
00708 
00709                         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"About to rellocate block at %lx to 0x%x bytes with tag %ws\n"</span>,
00710                                          BaseAddress,
00711                                          Size,
00712                                          <a class="code" href="../../d9/d9/heappriv_8h.html#a51">RtlpGetTagName</a>( Heap, TagIndex )));
00713 
00714                         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00715                     }
00716                 }
00717 
00718                 ReturnValue = <a class="code" href="../../d5/d9/heapdll_8c.html#a24">RtlReAllocateHeap</a>( HeapHandle, Flags, BaseAddress, Size );
00719 
00720                 <span class="keywordflow">if</span> (ReturnValue != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00721 
00722                     BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)ReturnValue - 1;
00723 
00724                     <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
00725 
00726                         ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
00727 
00728 <span class="preprocessor">    #if i386</span>
00729 <span class="preprocessor"></span>
00730                         <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a24">HEAP_CAPTURE_STACK_BACKTRACES</a>) {
00731 
00732                             ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o0">AllocatorBackTraceIndex</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)RtlLogStackBackTrace();
00733 
00734                         } <span class="keywordflow">else</span> {
00735 
00736                             ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o0">AllocatorBackTraceIndex</a> = 0;
00737                         }
00738 
00739 <span class="preprocessor">    #endif // i386</span>
00740 <span class="preprocessor"></span>
00741                         TagIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>;
00742 
00743                     } <span class="keywordflow">else</span> {
00744 
00745                         TagIndex = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a>;
00746                     }
00747                 }
00748 
00749                 <a class="code" href="../../d9/d9/heappriv_8h.html#a50">RtlpValidateHeapHeaders</a>( Heap, TRUE );
00750                 <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
00751             }
00752 
00753             <span class="keywordflow">if</span> (ReturnValue != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00754 
00755                 <span class="keywordflow">if</span> ((ULONG_PTR)ReturnValue == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o2">ReAllocAddress</a>) {
00756 
00757                     <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Just reallocated block at %lx to 0x%x bytes\n"</span>,
00758                                      <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o2">ReAllocAddress</a>,
00759                                      Size ));
00760 
00761                     <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00762 
00763                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) &amp;&amp;
00764                            (TagIndex == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o3">ReAllocTag</a>.<a class="code" href="../../d9/d6/struct__HEAP__STOP__ON__TAG.html#o1">TagIndex</a>) &amp;&amp;
00765                            (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o11">ProcessHeapsListIndex</a> == <a class="code" href="../../d3/d9/heap_8h.html#a65">RtlpHeapStopOn</a>.<a class="code" href="../../d2/d7/struct__HEAP__STOP__ON__VALUES.html#o3">ReAllocTag</a>.<a class="code" href="../../d9/d6/struct__HEAP__STOP__ON__TAG.html#o2">HeapIndex</a>)) {
00766 
00767                     <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Just reallocated block at %lx to 0x%x bytes with tag %ws\n"</span>,
00768                                      ReturnValue,
00769                                      Size,
00770                                      <a class="code" href="../../d9/d9/heappriv_8h.html#a51">RtlpGetTagName</a>( Heap, TagIndex )));
00771 
00772                     <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00773                 }
00774             }
00775 
00776         } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
00777                                                            EXCEPTION_EXECUTE_HANDLER ) {
00778 
00779             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
00780 
00781             ReturnValue = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00782         }
00783 
00784     } finally {
00785 
00786         <span class="keywordflow">if</span> (LockAcquired) {
00787 
00788             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00789         }
00790     }
00791 
00792     <span class="keywordflow">return</span> ReturnValue;
00793 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="heapdll.c::RtlDebugSetUserFlagsHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlDebugSetUserFlagsHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>UserFlagsReset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>UserFlagsSet</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01086">1086</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03740">RtlpDebugPageHeapSetUserFlags()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01696">RtlpValidateHeapEntry()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01480">RtlSetUserFlagsHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01480">RtlSetUserFlagsHeap()</a>.
<p>
<pre class="fragment"><div>01096                    :
01097 
01098 Arguments:
01099 
01100 Return Value:
01101 
01102 --*/
01103 
01104 {
01105     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01106     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
01107     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01108     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01109 
01110     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
01111                                     <a class="code" href="../../d7/d9/heappage_8h.html#a23">RtlpDebugPageHeapSetUserFlags</a>( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet ));
01112 
01113     <span class="keywordflow">if</span> ((UserFlagsReset &amp; ~HEAP_SETTABLE_USER_FLAGS) ||
01114         (UserFlagsSet &amp; ~HEAP_SETTABLE_USER_FLAGS)) {
01115 
01116         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01117     }
01118 
01119     <span class="keywordflow">try</span> {
01120 
01121         <span class="keywordflow">try</span> {
01122 
01123             <span class="comment">//</span>
01124             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
01125             <span class="comment">//</span>
01126 
01127             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlSetUserFlagsHeap"</span> )) {
01128 
01129                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01130                 leave;
01131             }
01132 
01133             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
01134 
01135             <span class="comment">//</span>
01136             <span class="comment">//  Lock the heap</span>
01137             <span class="comment">//</span>
01138 
01139             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01140 
01141                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01142 
01143                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01144 
01145                 Flags |= HEAP_NO_SERIALIZE;
01146             }
01147 
01148             <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
01149 
01150             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
01151 
01152             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a47">RtlpValidateHeapEntry</a>( Heap, BusyBlock, <span class="stringliteral">"RtlSetUserFlagsHeap"</span> )) {
01153 
01154                 Result = <a class="code" href="../../d5/d9/heapdll_8c.html#a27">RtlSetUserFlagsHeap</a>( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet );
01155 
01156                 <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
01157             }
01158 
01159         } except( EXCEPTION_EXECUTE_HANDLER ) {
01160 
01161             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01162         }
01163 
01164     } finally {
01165 
01166         <span class="keywordflow">if</span> (LockAcquired) {
01167 
01168             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01169         }
01170     }
01171 
01172     <span class="keywordflow">return</span> Result;
01173 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="heapdll.c::RtlDebugSetUserValueHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlDebugSetUserValueHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>UserValue</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01002">1002</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03631">RtlpDebugPageHeapSetUserValue()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01696">RtlpValidateHeapEntry()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01356">RtlSetUserValueHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01356">RtlSetUserValueHeap()</a>.
<p>
<pre class="fragment"><div>01011                    :
01012 
01013 Arguments:
01014 
01015 Return Value:
01016 
01017 --*/
01018 
01019 {
01020     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01021     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
01022     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01023     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01024 
01025     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
01026                                     <a class="code" href="../../d7/d9/heappage_8h.html#a21">RtlpDebugPageHeapSetUserValue</a>( HeapHandle, Flags, BaseAddress, UserValue ));
01027 
01028     <span class="keywordflow">try</span> {
01029 
01030         <span class="keywordflow">try</span> {
01031 
01032             <span class="comment">//</span>
01033             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
01034             <span class="comment">//</span>
01035 
01036             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlSetUserValueHeap"</span> )) {
01037 
01038                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01039                 leave;
01040             }
01041 
01042             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
01043 
01044             <span class="comment">//</span>
01045             <span class="comment">//  Lock the heap</span>
01046             <span class="comment">//</span>
01047 
01048             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01049 
01050                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01051 
01052                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01053 
01054                 Flags |= HEAP_NO_SERIALIZE;
01055             }
01056 
01057             <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
01058 
01059             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
01060 
01061             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a47">RtlpValidateHeapEntry</a>( Heap, BusyBlock, <span class="stringliteral">"RtlSetUserValueHeap"</span> )) {
01062 
01063                 Result = <a class="code" href="../../d5/d9/heapdll_8c.html#a26">RtlSetUserValueHeap</a>( HeapHandle, Flags, BaseAddress, UserValue );
01064 
01065                 <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
01066             }
01067 
01068         } except( EXCEPTION_EXECUTE_HANDLER ) {
01069 
01070             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01071         }
01072 
01073     } finally {
01074 
01075         <span class="keywordflow">if</span> (LockAcquired) {
01076 
01077             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01078         }
01079     }
01080 
01081     <span class="keywordflow">return</span> Result;
01082 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="heapdll.c::RtlDebugUsageHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS RtlDebugUsageHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PRTL_HEAP_USAGE&nbsp;</td>
          <td class="mdname" nowrap> <em>Usage</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01572">1572</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00391">HEAP_SKIP_VALIDATION_CHECKS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03846">RtlpDebugPageHeapUsage()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02976">RtlUsageHeap()</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d2/d0/hivedmp_8c-source.html#l00066">Usage()</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02976">RtlUsageHeap()</a>.
<p>
<pre class="fragment"><div>01580                    :
01581 
01582 Arguments:
01583 
01584 Return Value:
01585 
01586 --*/
01587 
01588 {
01589     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01590     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01591     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01592 
01593     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
01594                                     <a class="code" href="../../d7/d9/heappage_8h.html#a28">RtlpDebugPageHeapUsage</a>( HeapHandle, Flags, Usage ));
01595 
01596     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
01597 
01598     <span class="keywordflow">try</span> {
01599 
01600         <span class="keywordflow">try</span> {
01601 
01602             <span class="comment">//</span>
01603             <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
01604             <span class="comment">//</span>
01605 
01606             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlUsageHeap"</span> )) {
01607 
01608                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
01609                 leave;
01610             }
01611 
01612             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a> | <a class="code" href="../../d3/d9/heap_8h.html#a23">HEAP_SKIP_VALIDATION_CHECKS</a>;
01613 
01614             <span class="comment">//</span>
01615             <span class="comment">//  Lock the heap</span>
01616             <span class="comment">//</span>
01617 
01618             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01619 
01620                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01621 
01622                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01623 
01624                 Flags |= HEAP_NO_SERIALIZE;
01625             }
01626 
01627             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE )) {
01628 
01629                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
01630 
01631             } <span class="keywordflow">else</span> {
01632 
01633                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d9/heapdll_8c.html#a36">RtlUsageHeap</a>( HeapHandle, Flags, Usage );
01634             }
01635 
01636         } except( EXCEPTION_EXECUTE_HANDLER ) {
01637 
01638             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
01639         }
01640 
01641     } finally {
01642 
01643         <span class="keywordflow">if</span> (LockAcquired) {
01644 
01645             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01646         }
01647     }
01648 
01649     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01650 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="heapdll.c::RtlDebugWalkHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlDebugWalkHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PRTL_HEAP_WALK_ENTRY&nbsp;</td>
          <td class="mdname" nowrap> <em>Entry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01654">1654</a> of file <a class="el" href="../../d5/d8/heapdbg_8c-source.html">heapdbg.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, and <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l03714">RtlWalkHeap()</a>.
<p>
<pre class="fragment"><div>01661                    :
01662 
01663 Arguments:
01664 
01665 Return Value:
01666 
01667 --*/
01668 
01669 {
01670     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01671     BOOLEAN Result;
01672 
01673     <span class="comment">//</span>
01674     <span class="comment">//  Assumed the caller has serialized via RtlLockHeap or their own locking mechanism.</span>
01675     <span class="comment">//</span>
01676 
01677     Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01678 
01679     <span class="keywordflow">try</span> {
01680 
01681         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlWalkHeap"</span> )) {
01682 
01683             Result = <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, FALSE );
01684         }
01685 
01686     } except( EXCEPTION_EXECUTE_HANDLER ) {
01687 
01688         <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01689     }
01690 
01691     <span class="keywordflow">return</span> Result;
01692 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="heapdll.c::RtlEnumProcessHeaps" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS RtlEnumProcessHeaps           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">PRTL_ENUM_HEAPS_ROUTINE&nbsp;</td>
          <td class="mdname" nowrap> <em>EnumRoutine</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Parameter</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02896">2896</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d6/struct__HEAP__LOCK.html#o2">_HEAP_LOCK::Lock</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00053">RtlpProcessHeapsListLock</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, and <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>.
<p>
Referenced by <a class="el" href="../../d2/d2/dll_2query_8c-source.html#l00769">RtlQueryProcessHeapInformation()</a>.
<p>
<pre class="fragment"><div>02903                    :
02904 
02905     This routine cycles through all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heaps in a process and
02906     invokes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified call back routine <span class="keywordflow">for</span> that heap
02907 
02908 Arguments:
02909 
02910     EnumRoutine - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> callback to invoke <span class="keywordflow">for</span> each heap
02911         in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> process
02912 
02913     Parameter - Provides an additional parameter to pass to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02914         callback routine
02915 
02916 Return Value:
02917 
02918     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - returns success or <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first error status returned
02919         by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> callback routine
02920 
02921 --*/
02922 
02923 {
02924     PPEB Peb = NtCurrentPeb();
02925     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02926     ULONG i;
02927 
02928     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02929 
02930     <span class="comment">//</span>
02931     <span class="comment">//  Lock the heap</span>
02932     <span class="comment">//</span>
02933 
02934     <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
02935 
02936     <span class="keywordflow">try</span> {
02937 
02938         <span class="comment">//</span>
02939         <span class="comment">//  For each heap in the process invoke the callback routine</span>
02940         <span class="comment">//  and if the callback returns anything other than success</span>
02941         <span class="comment">//  then break out and return immediately to our caller</span>
02942         <span class="comment">//</span>
02943 
02944         <span class="keywordflow">for</span> (i=0; i&lt;Peb-&gt;NumberOfHeaps; i++) {
02945 
02946             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*EnumRoutine)( (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)(Peb-&gt;ProcessHeaps[ i ]), Parameter );
02947 
02948             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
02949 
02950                 <span class="keywordflow">break</span>;
02951             }
02952         }
02953 
02954     } finally {
02955 
02956         <span class="comment">//</span>
02957         <span class="comment">//  Unlock the heap</span>
02958         <span class="comment">//</span>
02959 
02960         <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
02961     }
02962 
02963     <span class="comment">//</span>
02964     <span class="comment">//  And return to our caller</span>
02965     <span class="comment">//</span>
02966 
02967     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02968 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="heapdll.c::RtlExtendHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS RtlExtendHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Base</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>Size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02132">2132</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00234">HEAP_MAXIMUM_SEGMENTS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00281">HEAP_SEGMENT_USER_ALLOCATED</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00270">_HEAP_SEGMENT::LastValidEntry</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d6/d2/queryvm_8c-source.html#l00061">NtQueryVirtualMemory()</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03817">RtlpDebugPageHeapExtend()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04732">RtlpInitializeHeapSegment()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00355">_HEAP::Segments</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>02141                    :
02142 
02143     This routine grows <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified heap by adding a <span class="keyword">new</span> segment to its
02144     storage.  The memory <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> segment <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> supplied by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller.
02145 
02146 Arguments:
02147 
02148     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified
02149 
02150     Flags - Supplies a set of flags used to augment those already
02151         enforced by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
02152 
02153     Base - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> starting address <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> segment being added
02154         to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input heap
02155 
02156     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> segment. Note that <span class="keyword">this</span>
02157         routine will actually use more memory than specified by <span class="keyword">this</span>
02158         variable.  It will use whatever <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> committed and reserved provided
02159         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> amount <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> greater than or equal to <span class="stringliteral">"Size"</span>
02160 
02161 Return Value:
02162 
02163     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - An appropriate status value
02164 
02165 --*/
02166 
02167 {
02168     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
02169     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02170     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
02171     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02172     UCHAR SegmentIndex, EmptySegmentIndex;
02173     SIZE_T CommitSize;
02174     SIZE_T ReserveSize;
02175     ULONG SegmentFlags;
02176     PVOID CommittedBase;
02177     PVOID UnCommittedBase;
02178     MEMORY_BASIC_INFORMATION MemoryInformation;
02179 
02180     <span class="comment">//</span>
02181     <span class="comment">//  Check if the guard page version of heap can do the work</span>
02182     <span class="comment">//</span>
02183 
02184     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
02185                                     <a class="code" href="../../d7/d9/heappage_8h.html#a25">RtlpDebugPageHeapExtend</a>( HeapHandle, Flags, Base, Size ));
02186 
02187     <span class="comment">//</span>
02188     <span class="comment">//  See what Mm thinks about the base address we were passed in.</span>
02189     <span class="comment">//  The address must not be free.</span>
02190     <span class="comment">//</span>
02191 
02192     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/queryvm_8c.html#a4">NtQueryVirtualMemory</a>( NtCurrentProcess(),
02193                                    Base,
02194                                    MemoryBasicInformation,
02195                                    &amp;MemoryInformation,
02196                                    <span class="keyword">sizeof</span>( MemoryInformation ),
02197                                    NULL );
02198 
02199     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
02200 
02201         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02202     }
02203 
02204     <span class="keywordflow">if</span> (MemoryInformation.State == MEM_FREE) {
02205 
02206         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
02207     }
02208 
02209     <span class="comment">//</span>
02210     <span class="comment">//  If what we were passed in as a base address is not on a page boundary then</span>
02211     <span class="comment">//  adjust the information supplied by MM to the page boundary right after</span>
02212     <span class="comment">//  the input base address</span>
02213     <span class="comment">//</span>
02214 
02215     <span class="keywordflow">if</span> (MemoryInformation.BaseAddress != Base) {
02216 
02217         MemoryInformation.BaseAddress = (PCHAR)MemoryInformation.BaseAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02218         MemoryInformation.RegionSize -= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02219     }
02220 
02221     <span class="keywordflow">try</span> {
02222 
02223         <span class="comment">//</span>
02224         <span class="comment">//  Lock the heap</span>
02225         <span class="comment">//</span>
02226 
02227         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
02228 
02229             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02230 
02231             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02232         }
02233 
02234         <span class="comment">//</span>
02235         <span class="comment">//  Scan the heap's segment list for a free segment.  And make sure the address</span>
02236         <span class="comment">//  of all the segment does not contain the input base address</span>
02237         <span class="comment">//</span>
02238 
02239         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
02240 
02241         EmptySegmentIndex = <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>;
02242 
02243         <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
02244 
02245             Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
02246 
02247             <span class="keywordflow">if</span> (Segment) {
02248 
02249                 <span class="keywordflow">if</span> (((ULONG_PTR)Base &gt;= (ULONG_PTR)Segment) &amp;&amp;
02250                     ((ULONG_PTR)Base &lt; (ULONG_PTR)(Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>))) {
02251 
02252                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
02253 
02254                     <span class="keywordflow">break</span>;
02255                 }
02256 
02257             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Segment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
02258                        (EmptySegmentIndex == <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>)) {
02259 
02260                 EmptySegmentIndex = SegmentIndex;
02261 
02262                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02263             }
02264         }
02265 
02266         <span class="comment">//</span>
02267         <span class="comment">//  At this point if status is success then the empty segment index</span>
02268         <span class="comment">//  is available for us to use and base address doesn't overlap an</span>
02269         <span class="comment">//  existing segment.</span>
02270         <span class="comment">//</span>
02271 
02272         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
02273 
02274             <span class="comment">//</span>
02275             <span class="comment">//  Indicate that this segment is user supplied</span>
02276             <span class="comment">//</span>
02277 
02278             SegmentFlags = <a class="code" href="../../d3/d9/heap_8h.html#a18">HEAP_SEGMENT_USER_ALLOCATED</a>;
02279 
02280             CommittedBase = MemoryInformation.BaseAddress;
02281 
02282             <span class="comment">//</span>
02283             <span class="comment">//  If the start of the memory supplied by the use is already</span>
02284             <span class="comment">//  committed then check the state of the following</span>
02285             <span class="comment">//  uncommitted piece of memory to see if it is reserved</span>
02286             <span class="comment">//</span>
02287 
02288             <span class="keywordflow">if</span> (MemoryInformation.State == MEM_COMMIT) {
02289 
02290                 CommitSize = MemoryInformation.RegionSize;
02291 
02292                 UnCommittedBase = (PCHAR)CommittedBase + CommitSize;
02293 
02294                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/queryvm_8c.html#a4">NtQueryVirtualMemory</a>( NtCurrentProcess(),
02295                                                UnCommittedBase,
02296                                                MemoryBasicInformation,
02297                                                &amp;MemoryInformation,
02298                                                <span class="keyword">sizeof</span>( MemoryInformation ),
02299                                                NULL );
02300 
02301                 ReserveSize = CommitSize;
02302 
02303                 <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) &amp;&amp;
02304                     (MemoryInformation.State == MEM_RESERVE)) {
02305 
02306                     ReserveSize += MemoryInformation.RegionSize;
02307                 }
02308 
02309             } <span class="keywordflow">else</span> {
02310 
02311                 <span class="comment">//</span>
02312                 <span class="comment">//  Otherwise the user hasn't committed anything in the</span>
02313                 <span class="comment">//  the address they gave us and we know it is not free</span>
02314                 <span class="comment">//  so it must be reserved.</span>
02315                 <span class="comment">//</span>
02316 
02317                 UnCommittedBase = CommittedBase;
02318 
02319                 ReserveSize = MemoryInformation.RegionSize;
02320             }
02321 
02322             <span class="comment">//</span>
02323             <span class="comment">//  Now if the reserved size is smaller than a page size or</span>
02324             <span class="comment">//  the user specified size is greater than the reserved size</span>
02325             <span class="comment">//  then the buffer we're given is too small to be a segment</span>
02326             <span class="comment">//  of heap</span>
02327             <span class="comment">//</span>
02328 
02329             <span class="keywordflow">if</span> ((ReserveSize &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) ||
02330                 (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; ReserveSize)) {
02331 
02332                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_BUFFER_TOO_SMALL;
02333 
02334             } <span class="keywordflow">else</span> {
02335 
02336                 <span class="comment">//</span>
02337                 <span class="comment">//  Otherwise the size is okay, now check if we need</span>
02338                 <span class="comment">//  to do the commit of the base.  If so we'll commit</span>
02339                 <span class="comment">//  one page</span>
02340 
02341                 <span class="keywordflow">if</span> (UnCommittedBase == CommittedBase) {
02342 
02343                     CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02344 
02345                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
02346                                                       (PVOID *)&amp;Segment,
02347                                                       0,
02348                                                       &amp;CommitSize,
02349                                                       MEM_COMMIT,
02350                                                       PAGE_READWRITE );
02351                 }
02352             }
02353 
02354             <span class="comment">//</span>
02355             <span class="comment">//  At this point the if status is good then memory is all set up</span>
02356             <span class="comment">//  with at least one page of committed memory to start with.  So</span>
02357             <span class="comment">//  initialize the heap segment and we're done.</span>
02358             <span class="comment">//</span>
02359 
02360             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
02361 
02362                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a33">RtlpInitializeHeapSegment</a>( Heap,
02363                                                Segment,
02364                                                EmptySegmentIndex,
02365                                                0,
02366                                                Segment,
02367                                                (PCHAR)Segment + CommitSize,
02368                                                (PCHAR)Segment + ReserveSize )) {
02369 
02370                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
02371                 }
02372             }
02373         }
02374 
02375     } finally {
02376 
02377         <span class="comment">//</span>
02378         <span class="comment">//  Unlock the heap</span>
02379         <span class="comment">//</span>
02380 
02381         <span class="keywordflow">if</span> (LockAcquired) {
02382 
02383             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02384         }
02385     }
02386 
02387     <span class="comment">//</span>
02388     <span class="comment">//  And return to our caller</span>
02389     <span class="comment">//</span>
02390 
02391     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02392 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="heapdll.c::RtlGetProcessHeaps" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlGetProcessHeaps           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfHeapsToReturn</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>ProcessHeaps</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02803">2803</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d6/struct__HEAP__LOCK.html#o2">_HEAP_LOCK::Lock</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l00189">RtlpDebugPageHeap</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03458">RtlpDebugPageHeapGetProcessHeaps()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00053">RtlpProcessHeapsListLock</a>, and <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02680">RtlValidateProcessHeaps()</a>.
<p>
<pre class="fragment"><div>02810                    :
02811 
02812     This routine determines how many individual heaps there are in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02813     current process and fills an array with pointers to each heap.
02814 
02815 Arguments:
02816 
02817     NumberOfHeapsToReturn - Indicates how many heaps <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller
02818         <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> willing to accept in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> second parameter
02819 
02820     ProcessHeaps - Supplies a pointer to an array of heap pointer
02821         to be filled in by <span class="keyword">this</span> routine.  The maximum size of <span class="keyword">this</span>
02822         array <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first parameter
02823 
02824 Return Value:
02825 
02826     ULONG - Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> smaller of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual number of heaps in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02827         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> process or <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> output buffer
02828 
02829 --*/
02830 
02831 {
02832     PPEB Peb = NtCurrentPeb();
02833     ULONG NumberOfHeapsToCopy;
02834     ULONG TotalHeaps;
02835 
02836     <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
02837 
02838     <span class="keywordflow">try</span> {
02839 
02840         <span class="comment">//</span>
02841         <span class="comment">//  Return no more than the number of heaps currently in use</span>
02842         <span class="comment">//</span>
02843 
02844         TotalHeaps = Peb-&gt;NumberOfHeaps;
02845 
02846         <span class="keywordflow">if</span> (TotalHeaps &gt; NumberOfHeapsToReturn) {
02847 
02848             NumberOfHeapsToCopy = NumberOfHeapsToReturn;
02849 
02850         } <span class="keywordflow">else</span> {
02851 
02852             NumberOfHeapsToCopy = TotalHeaps;
02853 
02854         }
02855 
02856         <span class="comment">//</span>
02857         <span class="comment">//  Return the heap pointers to the caller</span>
02858         <span class="comment">//</span>
02859 
02860         RtlMoveMemory( ProcessHeaps,
02861                        Peb-&gt;ProcessHeaps,
02862                        NumberOfHeapsToCopy * <span class="keyword">sizeof</span>( *ProcessHeaps ));
02863 
02864         ProcessHeaps += NumberOfHeapsToCopy;
02865         NumberOfHeapsToReturn -= NumberOfHeapsToCopy;
02866 
02867     } finally {
02868 
02869         <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
02870     }
02871 
02872 <span class="preprocessor">#ifdef DEBUG_PAGE_HEAP</span>
02873 <span class="preprocessor"></span>
02874     <span class="comment">//</span>
02875     <span class="comment">//  If we have debugging page heaps, go return what we can from them</span>
02876     <span class="comment">//</span>
02877 
02878     <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d9/heappage_8c.html#a36">RtlpDebugPageHeap</a> ) {
02879 
02880         TotalHeaps +=
02881             <a class="code" href="../../d7/d9/heappage_8h.html#a15">RtlpDebugPageHeapGetProcessHeaps</a>( NumberOfHeapsToReturn, ProcessHeaps );
02882 
02883     }
02884 
02885 <span class="preprocessor">#endif</span>
02886 <span class="preprocessor"></span>
02887     <span class="keywordflow">return</span> TotalHeaps;
02888 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="heapdll.c::RtlGetUserInfoHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlGetUserInfoHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *UserValue&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG UserFlags&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01192">1192</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00244">HEAP_ENTRY_SETTABLE_FLAGS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00919">RtlDebugGetUserInfoHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06008">RtlpGetExtraStuffPointer()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00128">_HEAP_ENTRY_EXTRA::Settable</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00919">RtlDebugGetUserInfoHeap()</a>, and <a class="el" href="../../d7/d8/heappage_8c-source.html#l04722">RtlpDphNormalHeapGetUserInfo()</a>.
<p>
<pre class="fragment"><div>01202                    :
01203 
01204     This routine returns to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> set of user flags
01205     and user values <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified heap entry.  The user value
01206     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> set via a set call and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user flags <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> part of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01207     user settable flags used when communicating with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap <span class="keyword">package</span>
01208 <span class="keyword">    </span>and can also be set via a set call
01209 
01210 Arguments:
01211 
01212     HeapHandle - Supplies a pointer to the heap being queried
01213 
01214     Flags - Supplies a set of flags to agument those already in the heap
01215 
01216     BaseAddress - Supplies a pointer to the users heap entry being
01217         queried
01218 
01219     UserValue - Optionally supplies a pointer to recieve the heap entry
01220         value
01221 
01222     UserFlasg - Optionally supplies a pointer to recieve the heap flags
01223 
01224 Return Value:
01225 
01226     BOOLEAN - TRUE if the query is successful and FALSE otherwise
01227 
01228 --*/
01229 
01230 {
01231     PHEAP Heap = (PHEAP)HeapHandle;
01232     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
01233     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
01234     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01235     BOOLEAN Result;
01236 
01237     <span class="comment">//</span>
01238     <span class="comment">//  Build up a set of real flags to use in this operation</span>
01239     <span class="comment">//</span>
01240 
01241     Flags |= Heap-&gt;ForceFlags;
01242 
01243     <span class="comment">//</span>
01244     <span class="comment">//  Check if we should be going the debug route</span>
01245     <span class="comment">//</span>
01246 
01247     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
01248 
01249         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a9">RtlDebugGetUserInfoHeap</a>( HeapHandle, Flags, BaseAddress, UserValue, UserFlags );
01250     }
01251 
01252     Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01253 
01254     <span class="keywordflow">try</span> {
01255 
01256         <span class="keywordflow">try</span> {
01257 
01258             <span class="comment">//</span>
01259             <span class="comment">//  Lock the heap</span>
01260             <span class="comment">//</span>
01261 
01262             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01263 
01264                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;LockVariable );
01265 
01266                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01267             }
01268 
01269             <span class="comment">//</span>
01270             <span class="comment">//  Backup the pointer to the heap entry</span>
01271             <span class="comment">//</span>
01272 
01273             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
01274 
01275             <span class="comment">//</span>
01276             <span class="comment">//  If the entry is not in use then it is an error</span>
01277             <span class="comment">//</span>
01278 
01279             <span class="keywordflow">if</span> (!(BusyBlock-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>)) {
01280 
01281                 <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
01282 
01283             } <span class="keywordflow">else</span> {
01284 
01285                 <span class="comment">//</span>
01286                 <span class="comment">//  The heap entry is in use so now check if there is</span>
01287                 <span class="comment">//  any extra information present</span>
01288                 <span class="comment">//</span>
01289 
01290                 <span class="keywordflow">if</span> (BusyBlock-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
01291 
01292                     <span class="comment">//</span>
01293                     <span class="comment">//  Get a pointer to the extra information and if the</span>
01294                     <span class="comment">//  user asked for user values then that field from the</span>
01295                     <span class="comment">//  extra stuff</span>
01296                     <span class="comment">//</span>
01297 
01298                     ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
01299 
01300                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( UserValue )) {
01301 
01302                         *UserValue = (PVOID)ExtraStuff-&gt;Settable;
01303                     }
01304                 }
01305 
01306                 <span class="comment">//</span>
01307                 <span class="comment">//  If the user asked for user flags then return the flags</span>
01308                 <span class="comment">//  from the heap entry that are user setable</span>
01309                 <span class="comment">//</span>
01310 
01311                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( UserFlags )) {
01312 
01313                     *UserFlags = (BusyBlock-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a16">HEAP_ENTRY_SETTABLE_FLAGS</a>) &lt;&lt; 4;
01314                 }
01315 
01316                 <span class="comment">//</span>
01317                 <span class="comment">//  Now that the assignments are done we can say that</span>
01318                 <span class="comment">//  we were successful</span>
01319                 <span class="comment">//</span>
01320 
01321                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01322             }
01323 
01324         } except( EXCEPTION_EXECUTE_HANDLER ) {
01325 
01326             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01327 
01328             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01329         }
01330 
01331     } finally {
01332 
01333         <span class="comment">//</span>
01334         <span class="comment">//  Unlock the heap</span>
01335         <span class="comment">//</span>
01336 
01337         <span class="keywordflow">if</span> (LockAcquired) {
01338 
01339             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;LockVariable );
01340         }
01341     }
01342 
01343     <span class="comment">//</span>
01344     <span class="comment">//  And return to our caller</span>
01345     <span class="comment">//</span>
01346 
01347     <span class="keywordflow">return</span> Result;
01348 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="heapdll.c::RtlInitializeHeapManager" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS RtlInitializeHeapManager           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">VOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00179">179</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00394">CHECK_HEAP_TAIL_SIZE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00134">HeapDebugBreak</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d4/d6/struct__HEAP__LOCK.html#o2">_HEAP_LOCK::Lock</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00077">RtlInitializeLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00059">RTLP_STATIC_HEAP_LIST_SIZE</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00061">RtlpProcessHeapsListBuffer</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00053">RtlpProcessHeapsListLock</a>, and <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>.
<p>
Referenced by <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00575">LdrpForkProcess()</a>, <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00616">LdrpInitializeProcess()</a>, and <a class="el" href="../../d2/d0/theap_8c-source.html#l00077">main()</a>.
<p>
<pre class="fragment"><div>00185                    :
00186 
00187     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to initialize <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap manager <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current process
00188 
00189 Arguments:
00190 
00191     None.
00192 
00193 Return Value:
00194 
00195     None.
00196 
00197 --*/
00198 
00199 {
00200     PPEB Peb = NtCurrentPeb();
00201 
00202 <span class="preprocessor">#if DBG</span>
00203 <span class="preprocessor"></span>
00204     <span class="comment">//</span>
00205     <span class="comment">//  Sanity check the sizes of the header entry structures</span>
00206     <span class="comment">//</span>
00207 
00208     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> ) != <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">HEAP_ENTRY_EXTRA</a> )) {
00209 
00210         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Heap header and extra header sizes disagree\n"</span> ));
00211 
00212         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00213     }
00214 
00215     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> ) != <a class="code" href="../../d3/d9/heap_8h.html#a25">CHECK_HEAP_TAIL_SIZE</a>) {
00216 
00217         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Heap header and tail fill sizes disagree\n"</span> ));
00218 
00219         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00220     }
00221 
00222     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>( <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a> ) != (2 * <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> ))) {
00223 
00224         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Heap header and free header sizes disagree\n"</span> ));
00225 
00226         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00227     }
00228 
00229 <span class="preprocessor">#endif // DBG</span>
00230 <span class="preprocessor"></span>
00231     <span class="comment">//</span>
00232     <span class="comment">//  Initialize the heap specific structures in the current peb</span>
00233     <span class="comment">//</span>
00234 
00235     Peb-&gt;NumberOfHeaps = 0;
00236     Peb-&gt;MaximumNumberOfHeaps = <a class="code" href="../../d5/d9/heapdll_8c.html#a0">RTLP_STATIC_HEAP_LIST_SIZE</a>;
00237     Peb-&gt;ProcessHeaps = <a class="code" href="../../d5/d9/heapdll_8c.html#a4">RtlpProcessHeapsListBuffer</a>;
00238 
00239 <span class="preprocessor">#ifdef NTHEAP_ENABLED</span>
00240 <span class="preprocessor"></span>    {
00241         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) RtlInitializeNtHeapManager();
00242     }
00243 <span class="preprocessor">#endif // NTHEAP_ENABLED</span>
00244 <span class="preprocessor"></span>
00245     <span class="comment">//</span>
00246     <span class="comment">//  Initialize the lock and return to our caller</span>
00247     <span class="comment">//</span>
00248 
00249     <span class="keywordflow">return</span> <a class="code" href="../../d9/d9/heappriv_8h.html#a2">RtlInitializeLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
00250 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="heapdll.c::RtlLockHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlLockHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>HeapHandle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00390">390</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00383">_HEAP::LookasideLockCount</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03595">RtlpDebugPageHeapLock()</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>00396                    :
00397 
00398     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used by lock access to a specific heap structure
00399 
00400 Arguments:
00401 
00402     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being locked
00403 
00404 Return Value:
00405 
00406     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> now locked and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise (i.e.,
00407         the heap is ill-formed).  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned even <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00408         not lockable.
00409 
00410 --*/
00411 
00412 {
00413     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00414 
00415     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00416 
00417     <span class="comment">//</span>
00418     <span class="comment">//  Check for the heap protected by guard pages</span>
00419     <span class="comment">//</span>
00420 
00421     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
00422                                     <a class="code" href="../../d7/d9/heappage_8h.html#a19">RtlpDebugPageHeapLock</a>( HeapHandle ));
00423 
00424     <span class="comment">//</span>
00425     <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
00426     <span class="comment">//</span>
00427 
00428     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlLockHeap"</span> )) {
00429 
00430         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00431     }
00432 
00433     <span class="comment">//</span>
00434     <span class="comment">//  Lock the heap.  And disable the lookaside list by incrementing</span>
00435     <span class="comment">//  its lock count.</span>
00436     <span class="comment">//</span>
00437 
00438     <span class="keywordflow">if</span> (!(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_NO_SERIALIZE)) {
00439 
00440         <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00441 
00442         Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o34">LookasideLockCount</a> += 1;
00443     }
00444 
00445     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00446 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="heapdll.c::RtlpAddHeapToProcessList" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpAddHeapToProcessList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Heap</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04457">4457</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d6/struct__HEAP__LOCK.html#o2">_HEAP_LOCK::Lock</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d4/d6/config_2utils_2regutil_8c-source.html#l00022">RtlAllocateHeap</a>, <a class="el" href="../../d4/d6/config_2utils_2regutil_8c-source.html#l00023">RtlFreeHeap</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00061">RtlpProcessHeapsListBuffer</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00053">RtlpProcessHeapsListLock</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l00191">RtlCreateHeap()</a>.
<p>
<pre class="fragment"><div>04463                    :
04464 
04465     This routine adds <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified heap to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap list <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
04466     current process
04467 
04468 Arguments:
04469 
04470     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being added
04471 
04472 Return Value:
04473 
04474     None.
04475 
04476 --*/
04477 
04478 {
04479     PPEB Peb = NtCurrentPeb();
04480     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> *NewList;
04481 
04482     <span class="comment">//</span>
04483     <span class="comment">//  Lock the processes heap list</span>
04484     <span class="comment">//</span>
04485 
04486     <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
04487 
04488     <span class="keywordflow">try</span> {
04489 
04490         <span class="comment">//</span>
04491         <span class="comment">//  If the processes heap list is already full then we'll</span>
04492         <span class="comment">//  double the size of the heap list for the process</span>
04493         <span class="comment">//</span>
04494 
04495         <span class="keywordflow">if</span> (Peb-&gt;NumberOfHeaps == Peb-&gt;MaximumNumberOfHeaps) {
04496 
04497             <span class="comment">//</span>
04498             <span class="comment">//  Double the size</span>
04499             <span class="comment">//</span>
04500 
04501             Peb-&gt;MaximumNumberOfHeaps *= 2;
04502 
04503             <span class="comment">//</span>
04504             <span class="comment">//  Allocate space for the new list</span>
04505             <span class="comment">//</span>
04506 
04507             NewList = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( RtlProcessHeap(),
04508                                        0,
04509                                        Peb-&gt;MaximumNumberOfHeaps * <span class="keyword">sizeof</span>( *NewList ));
04510 
04511             <span class="keywordflow">if</span> (NewList == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04512 
04513                 leave;
04514             }
04515 
04516             <span class="comment">//</span>
04517             <span class="comment">//  Copy over the old buffer to the new buffer</span>
04518             <span class="comment">//</span>
04519 
04520             RtlMoveMemory( NewList,
04521                            Peb-&gt;ProcessHeaps,
04522                            Peb-&gt;NumberOfHeaps * <span class="keyword">sizeof</span>( *NewList ));
04523 
04524             <span class="comment">//</span>
04525             <span class="comment">//  Check if we should free the previous heap list buffer</span>
04526             <span class="comment">//</span>
04527 
04528             <span class="keywordflow">if</span> (Peb-&gt;ProcessHeaps != <a class="code" href="../../d5/d9/heapdll_8c.html#a4">RtlpProcessHeapsListBuffer</a>) {
04529 
04530                 <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( RtlProcessHeap(), 0, Peb-&gt;ProcessHeaps );
04531             }
04532 
04533             <span class="comment">//</span>
04534             <span class="comment">//  Set the new list</span>
04535             <span class="comment">//</span>
04536 
04537             Peb-&gt;ProcessHeaps = NewList;
04538         }
04539 
04540         <span class="comment">//</span>
04541         <span class="comment">//  Add the input heap to the next free heap list slot, and note that</span>
04542         <span class="comment">//  the processes heap list index is really one beyond the actualy</span>
04543         <span class="comment">//  index used to get the processes heap</span>
04544         <span class="comment">//</span>
04545 
04546         Peb-&gt;ProcessHeaps[ Peb-&gt;NumberOfHeaps++ ] = Heap;
04547         Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o11">ProcessHeapsListIndex</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Peb-&gt;NumberOfHeaps;
04548 
04549     } finally {
04550 
04551         <span class="comment">//</span>
04552         <span class="comment">//  Unlock the processes heap list</span>
04553         <span class="comment">//</span>
04554 
04555         <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
04556     }
04557 
04558     <span class="comment">//</span>
04559     <span class="comment">//  And return to our caller</span>
04560     <span class="comment">//</span>
04561 
04562     <span class="keywordflow">return</span>;
04563 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="heapdll.c::RtlpAllocateHeapUsageEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS RtlpAllocateHeapUsageEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">PRTL_HEAP_USAGE_INTERNAL</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>PRTL_HEAP_USAGE_ENTRY *&nbsp;</td>
          <td class="mdname" nowrap> <em>pp</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05954">5954</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d4/d5/allocvm_8c-source.html#l00075">NtAllocateVirtualMemory()</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, and <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02976">RtlUsageHeap()</a>.
<p>
<pre class="fragment"><div>05961                    :
05962 
05963     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to allocate an <span class="keyword">new</span> heap usage entry
05964     from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> internal heap usage buffer
05965 
05966 Arguments:
05967 
05968     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> internal heap usage
05969         buffer from which to allocate an entry
05970 
05971     pp - Receives a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly allocated heap
05972         usage entry.  If pp <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> already pointing to an existing
05973         heap usage entry then on <span class="keywordflow">return</span> we'll have <span class="keyword">this</span> old
05974         entry point to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> entry, but still <span class="keywordflow">return</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span>
05975         entry.
05976 
05977 Return Value:
05978 
05979     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - An appropriate status value
05980 
05981 --*/
05982 
05983 {
05984     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05985     PRTL_HEAP_USAGE_ENTRY p;
05986     PVOID CommitAddress;
05987     SIZE_T PageSize;
05988 
05989     <span class="comment">//</span>
05990     <span class="comment">//  Check if the free list is empty and then we have to allocate more</span>
05991     <span class="comment">//  memory for the free list</span>
05992     <span class="comment">//</span>
05993 
05994     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05995 
05996         <span class="comment">//</span>
05997         <span class="comment">//  We cannot grow the buffer any larger than the reserved size</span>
05998         <span class="comment">//</span>
05999 
06000         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;CommittedSize &gt;= <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;ReservedSize) {
06001 
06002             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
06003         }
06004 
06005         <span class="comment">//</span>
06006         <span class="comment">//  Try and add one page of committed memory to the buffer</span>
06007         <span class="comment">//  starting right after the currently committed space</span>
06008         <span class="comment">//</span>
06009 
06010         PageSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
06011 
06012         CommitAddress = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base + <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;CommittedSize;
06013 
06014         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d6/allocvm_8c.html#a7">NtAllocateVirtualMemory</a>( NtCurrentProcess(),
06015                                           &amp;CommitAddress,
06016                                           0,
06017                                           &amp;PageSize,
06018                                           MEM_COMMIT,
06019                                           PAGE_READWRITE );
06020 
06021         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
06022 
06023             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06024         }
06025 
06026         <span class="comment">//</span>
06027         <span class="comment">//  Update the committed buffer size</span>
06028         <span class="comment">//</span>
06029 
06030         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;CommittedSize += PageSize;
06031 
06032         <span class="comment">//</span>
06033         <span class="comment">//  Add the newly allocated space to the free list and</span>
06034         <span class="comment">//  build up the free list</span>
06035         <span class="comment">//</span>
06036 
06037         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList = CommitAddress;
06038 
06039         p = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList;
06040 
06041         <span class="keywordflow">while</span> (PageSize != 0) {
06042 
06043             p-&gt;Next = (p+1);
06044             p += 1;
06045             PageSize -= <span class="keyword">sizeof</span>( *p );
06046         }
06047 
06048         <span class="comment">//</span>
06049         <span class="comment">//  Null terminate the next pointer in the last free entry</span>
06050         <span class="comment">//</span>
06051 
06052         p -= 1;
06053         p-&gt;Next = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06054     }
06055 
06056     <span class="comment">//</span>
06057     <span class="comment">//  At this point the free list contains at least one entry</span>
06058     <span class="comment">//  so simply pop the entry.</span>
06059     <span class="comment">//</span>
06060 
06061     p = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList;
06062 
06063     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList = p-&gt;Next;
06064 
06065     p-&gt;Next = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06066 
06067     <span class="comment">//</span>
06068     <span class="comment">//  Now if the caller supplied an existing heap entry then</span>
06069     <span class="comment">//  we'll make the old heap entry point to this new entry</span>
06070     <span class="comment">//</span>
06071 
06072     <span class="keywordflow">if</span> (*pp) {
06073 
06074         (*pp)-&gt;Next = p;
06075     }
06076 
06077     <span class="comment">//</span>
06078     <span class="comment">//  And then return the new entry to our caller</span>
06079     <span class="comment">//</span>
06080 
06081     *pp = p;
06082 
06083     <span class="keywordflow">return</span> STATUS_SUCCESS;
06084 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="heapdll.c::RtlpAllocateTags" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> RtlpAllocateTags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfTags</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05225">5225</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00307">_HEAP_TAG_ENTRY::CreatorBackTraceIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00392">HEAP_CAPTURE_STACK_BACKTRACES</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00387">HEAP_SIGNATURE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00338">_HEAP::MaximumTagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00337">_HEAP::NextAvailableTagIndex</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d4/d5/allocvm_8c-source.html#l00075">NtAllocateVirtualMemory()</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00462">RtlpGlobalTagHeap</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00321">_HEAP::Signature</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00339">_HEAP::TagEntries</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00306">_HEAP_TAG_ENTRY::TagIndex</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01603">RtlCreateTagHeap()</a>.
<p>
<pre class="fragment"><div>05232                    :
05233 
05234     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to allocate space <span class="keywordflow">for</span> additional tags within
05235     a heap
05236 
05237 Arguments:
05238 
05239     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified.  If not specified
05240         then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> processes global tag heap <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used
05241 
05242     NumberOfTags - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of tags that we want stored in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
05243         heap.  This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number to grow <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag list by.
05244 
05245 Return Value:
05246 
05247     <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> - Returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> next available tag entry in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
05248         heap
05249 
05250 --*/
05251 
05252 {
05253     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05254     ULONG TagIndex;
05255     SIZE_T ReserveSize;
05256     SIZE_T CommitSize;
05257     <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> TagEntry;
05258     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> CreatorBackTraceIndex;
05259     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MaximumTagIndex;
05260     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> TagIndexFlag;
05261 
05262     <span class="comment">//</span>
05263     <span class="comment">//  Check if the process has a global tag heap.  If not then there is</span>
05264     <span class="comment">//  nothing for us to do</span>
05265     <span class="comment">//</span>
05266 
05267     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05268 
05269         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05270     }
05271 
05272     <span class="comment">//</span>
05273     <span class="comment">//  If the user didn't give us a heap then use the processes global</span>
05274     <span class="comment">//  tag heap</span>
05275     <span class="comment">//</span>
05276 
05277     <span class="keywordflow">if</span> (Heap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05278 
05279         <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o1">Signature</a> = <a class="code" href="../../d3/d9/heap_8h.html#a19">HEAP_SIGNATURE</a>;
05280 
05281         <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> = HEAP_NO_SERIALIZE;
05282 
05283         TagIndexFlag = HEAP_GLOBAL_TAG;
05284 
05285         Heap = <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>;
05286 
05287     } <span class="keywordflow">else</span> {
05288 
05289         TagIndexFlag = 0;
05290     }
05291 
05292     <span class="comment">//</span>
05293     <span class="comment">//  Grab the stack backtrace if possible and if we should</span>
05294     <span class="comment">//</span>
05295 
05296     CreatorBackTraceIndex = 0;
05297 
05298 <span class="preprocessor">#if i386</span>
05299 <span class="preprocessor"></span>
05300     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a24">HEAP_CAPTURE_STACK_BACKTRACES</a>) {
05301 
05302         CreatorBackTraceIndex = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)RtlLogStackBackTrace();
05303     }
05304 
05305 <span class="preprocessor">#endif // i386</span>
05306 <span class="preprocessor"></span>
05307     <span class="comment">//</span>
05308     <span class="comment">//  If the heap does not already have tag entries then we'll</span>
05309     <span class="comment">//  reserve space for them</span>
05310     <span class="comment">//</span>
05311 
05312     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05313 
05314         MaximumTagIndex = HEAP_MAXIMUM_TAG &amp; ~HEAP_GLOBAL_TAG;
05315 
05316         ReserveSize = MaximumTagIndex * <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">HEAP_TAG_ENTRY</a> );
05317 
05318         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d6/allocvm_8c.html#a7">NtAllocateVirtualMemory</a>( NtCurrentProcess(),
05319                                           &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>,
05320                                           0,
05321                                           &amp;ReserveSize,
05322                                           MEM_RESERVE,
05323                                           PAGE_READWRITE );
05324 
05325         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
05326 
05327             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05328         }
05329 
05330         Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o15">MaximumTagIndex</a> = MaximumTagIndex;
05331 
05332         Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a> = 0;
05333 
05334         <span class="comment">//</span>
05335         <span class="comment">// Add one for zero tag, as that is always reserved for heap name</span>
05336         <span class="comment">//</span>
05337 
05338         NumberOfTags += 1;
05339     }
05340 
05341     <span class="comment">//</span>
05342     <span class="comment">//  At this point we have a space reserved for tag entries.  If the number</span>
05343     <span class="comment">//  of tags that we need to grow is too large then tell the user we can't</span>
05344     <span class="comment">//  do it.</span>
05345     <span class="comment">//</span>
05346 
05347     <span class="keywordflow">if</span> (NumberOfTags &gt; (ULONG)(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o15">MaximumTagIndex</a> - Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>)) {
05348 
05349         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05350     }
05351 
05352     <span class="comment">//</span>
05353     <span class="comment">//  Get a pointer to the next available tag entry, and for</span>
05354     <span class="comment">//  every tag entry that we want to grow by we'll commit</span>
05355     <span class="comment">//  the page containing the tag entry.  We only need to do</span>
05356     <span class="comment">//  this for every page just once.  We'll determine this</span>
05357     <span class="comment">//  by seeing when the tag entry crosses a page boundary</span>
05358     <span class="comment">//</span>
05359 
05360     TagEntry = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> + Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>;
05361 
05362     <span class="keywordflow">for</span> (TagIndex = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>;
05363          TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a> + NumberOfTags;
05364          TagIndex++ ) {
05365 
05366         <span class="keywordflow">if</span> (((((ULONG_PTR)TagEntry + <span class="keyword">sizeof</span>(*TagEntry)) &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>-1)) &lt;=
05367             <span class="keyword">sizeof</span>(*TagEntry))) {
05368 
05369             CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05370 
05371             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d6/allocvm_8c.html#a7">NtAllocateVirtualMemory</a>( NtCurrentProcess(),
05372                                               &amp;TagEntry,
05373                                               0,
05374                                               &amp;CommitSize,
05375                                               MEM_COMMIT,
05376                                               PAGE_READWRITE );
05377 
05378             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
05379 
05380                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05381             }
05382         }
05383 
05384         <span class="comment">//</span>
05385         <span class="comment">//  Bias the tag index if this is the global tag heap</span>
05386         <span class="comment">//</span>
05387 
05388         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o3">TagIndex</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)TagIndex | TagIndexFlag;
05389 
05390         <span class="comment">//</span>
05391         <span class="comment">//  Set the stack back trace</span>
05392         <span class="comment">//</span>
05393 
05394         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o4">CreatorBackTraceIndex</a> = CreatorBackTraceIndex;
05395 
05396         <span class="comment">//</span>
05397         <span class="comment">//  Move on to the next tag entry</span>
05398         <span class="comment">//</span>
05399 
05400         TagEntry += 1;
05401     }
05402 
05403     <span class="comment">//</span>
05404     <span class="comment">//  At this point we've build the new tag list so now pop off the next</span>
05405     <span class="comment">//  available tag entry</span>
05406     <span class="comment">//</span>
05407 
05408     TagEntry = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> + Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>;
05409 
05410     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a> += (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)NumberOfTags;
05411 
05412     <span class="comment">//</span>
05413     <span class="comment">//  And return to our caller</span>
05414     <span class="comment">//</span>
05415 
05416     <span class="keywordflow">return</span> TagEntry;
05417 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="heapdll.c::RtlpCheckHeapSignature" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlpCheckHeapSignature           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>Caller</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">4250</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00387">HEAP_SIGNATURE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00134">HeapDebugBreak</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00444">RtlDebugAllocateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01260">RtlDebugCompactHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01421">RtlDebugCreateTagHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00388">RtlDebugDestroyHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00797">RtlDebugFreeHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00919">RtlDebugGetUserInfoHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01498">RtlDebugQueryTagHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00603">RtlDebugReAllocateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01086">RtlDebugSetUserFlagsHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01002">RtlDebugSetUserValueHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01177">RtlDebugSizeHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01572">RtlDebugUsageHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01654">RtlDebugWalkHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01338">RtlDebugZeroHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00390">RtlLockHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00323">RtlpSerializeHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00454">RtlUnlockHeap()</a>, and <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02530">RtlValidateHeap()</a>.
<p>
<pre class="fragment"><div>04257                    :
04258 
04259     This routine verifies that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being called with a properly identified
04260     heap.
04261 
04262 Arguments:
04263 
04264     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being checked
04265 
04266     Caller - Supplies a string that can be used to identify <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller
04267 
04268 Return Value:
04269 
04270     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap signature <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> present, and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise
04271 
04272 --*/
04273 
04274 {
04275     <span class="comment">//</span>
04276     <span class="comment">//  If the heap signature matches then that is the only</span>
04277     <span class="comment">//  checking we do</span>
04278     <span class="comment">//</span>
04279 
04280     <span class="keywordflow">if</span> (Heap-&gt;Signature == <a class="code" href="../../d3/d9/heap_8h.html#a19">HEAP_SIGNATURE</a>) {
04281 
04282         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04283 
04284     } <span class="keywordflow">else</span> {
04285 
04286         <span class="comment">//</span>
04287         <span class="comment">//  We have a bad heap signature.  Print out some information, break</span>
04288         <span class="comment">//  into the debugger, and then return false</span>
04289         <span class="comment">//</span>
04290 
04291         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Invalid heap signature for heap at %x"</span>, Heap ));
04292 
04293         <span class="keywordflow">if</span> (Caller != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04294 
04295             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">", passed to %s"</span>, Caller );
04296         }
04297 
04298         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"\n"</span> );
04299 
04300         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( &amp;Heap-&gt;Signature );
04301 
04302         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04303     }
04304 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="heapdll.c::RtlpCoalesceHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> RtlpCoalesceHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Heap</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04312">4312</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00200">_HEAP_FREE_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00233">HEAP_MAXIMUM_FREELISTS</a>, <a class="el" href="../../d8/d9/exts_8h-source.html#l00092">n</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00182">_HEAP_FREE_ENTRY::PreviousSize</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05312">RtlpCoalesceFreeBlocks()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05527">RtlpDeCommitFreeBlock()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05849">RtlpInsertFreeBlock()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00174">_HEAP_FREE_ENTRY::Size</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02401">RtlCompactHeap()</a>, and <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05024">RtlpExtendHeap()</a>.
<p>
<pre class="fragment"><div>04318                    :
04319 
04320     This routine scans through heap and coalesces its free blocks
04321 
04322 Arguments:
04323 
04324     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified
04325 
04326 Return Value:
04327 
04328     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> - returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> largest free block
04329         in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
04330 
04331 --*/
04332 
04333 {
04334     SIZE_T OldFreeSize;
04335     SIZE_T FreeSize;
04336     ULONG <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
04337     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock, LargestFreeBlock;
04338     PLIST_ENTRY FreeListHead, Next;
04339 
04340     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
04341 
04342     LargestFreeBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04343 
04344     <span class="comment">//</span>
04345     <span class="comment">//  For every free list in the heap, going from smallest to</span>
04346     <span class="comment">//  largest and skipping the zero index one we will</span>
04347     <span class="comment">//  scan the free list coalesceing the free blocks</span>
04348     <span class="comment">//</span>
04349 
04350     FreeListHead = &amp;Heap-&gt;FreeLists[ 1 ];
04351 
04352     <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>;
04353 
04354     <span class="keywordflow">while</span> (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>--) {
04355 
04356         <span class="comment">//</span>
04357         <span class="comment">//  Scan the individual free list</span>
04358         <span class="comment">//</span>
04359 
04360         Next = FreeListHead-&gt;Blink;
04361 
04362         <span class="keywordflow">while</span> (FreeListHead != Next) {
04363 
04364             <span class="comment">//</span>
04365             <span class="comment">//  Get a pointer to the current free list entry, and remember its</span>
04366             <span class="comment">//  next and size</span>
04367             <span class="comment">//</span>
04368 
04369             FreeBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a>, FreeList );
04370 
04371             Next = Next-&gt;Flink;
04372             OldFreeSize = FreeSize = FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
04373 
04374             <span class="comment">//</span>
04375             <span class="comment">//  Coalesce the block</span>
04376             <span class="comment">//</span>
04377 
04378             FreeBlock = <a class="code" href="../../d9/d9/heappriv_8h.html#a34">RtlpCoalesceFreeBlocks</a>( Heap,
04379                                                 FreeBlock,
04380                                                 &amp;FreeSize,
04381                                                 TRUE );
04382 
04383             <span class="comment">//</span>
04384             <span class="comment">//  If the new free size is not equal to the old free size</span>
04385             <span class="comment">//  then we actually did some changes otherwise the coalesce</span>
04386             <span class="comment">//  calll was essentialy a noop</span>
04387             <span class="comment">//</span>
04388 
04389             <span class="keywordflow">if</span> (FreeSize != OldFreeSize) {
04390 
04391                 <span class="comment">//</span>
04392                 <span class="comment">//  Check if we should decommit this block because it is too</span>
04393                 <span class="comment">//  large and it is either at the beginning or end of a</span>
04394                 <span class="comment">//  committed run.  Otherwise just insert the new sized</span>
04395                 <span class="comment">//  block into its corresponding free list.  We'll hit this</span>
04396                 <span class="comment">//  block again when we visit larger free lists.</span>
04397                 <span class="comment">//</span>
04398 
04399                 <span class="keywordflow">if</span> (FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> &gt;= (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>)
04400 
04401                         &amp;&amp;
04402 
04403                     (FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> == 0 ||
04404                      (FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>))) {
04405 
04406                     <a class="code" href="../../d9/d9/heappriv_8h.html#a35">RtlpDeCommitFreeBlock</a>( Heap, FreeBlock, FreeSize );
04407 
04408                 } <span class="keywordflow">else</span> {
04409 
04410                     <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, FreeBlock, FreeSize );
04411                 }
04412 
04413                 Next = FreeListHead-&gt;Blink;
04414 
04415             } <span class="keywordflow">else</span> {
04416 
04417                 <span class="comment">//</span>
04418                 <span class="comment">//  Remember the largest free block we've found so far</span>
04419                 <span class="comment">//</span>
04420 
04421                 <span class="keywordflow">if</span> ((LargestFreeBlock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
04422                     (LargestFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> &lt; FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>)) {
04423 
04424                     LargestFreeBlock = FreeBlock;
04425                 }
04426             }
04427         }
04428 
04429         <span class="comment">//</span>
04430         <span class="comment">//  Go to the next free list.  When we hit the largest dedicated</span>
04431         <span class="comment">//  size free list we'll fall back to the [0] index list</span>
04432         <span class="comment">//</span>
04433 
04434         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> == 1) {
04435 
04436             FreeListHead = &amp;Heap-&gt;FreeLists[ 0 ];
04437 
04438         } <span class="keywordflow">else</span> {
04439 
04440             FreeListHead++;
04441         }
04442     }
04443 
04444     <span class="comment">//</span>
04445     <span class="comment">//  And return to our caller</span>
04446     <span class="comment">//</span>
04447 
04448     <span class="keywordflow">return</span> LargestFreeBlock;
04449 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="heapdll.c::RtlpDestroyTags" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpDestroyTags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Heap</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05893">5893</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d4/d6/freevm_8c-source.html#l00066">NtFreeVirtualMemory()</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d4/d8/heap_8h-source.html#l00339">_HEAP::TagEntries</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l01133">RtlDestroyHeap()</a>.
<p>
<pre class="fragment"><div>05899                    :
05900 
05901     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to completely remove all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> normal tag entries
05902     in use by a heap
05903 
05904 Arguments:
05905 
05906     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified
05907 
05908 Return Value:
05909 
05910     None.
05911 
05912 --*/
05913 
05914 {
05915     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05916     SIZE_T RegionSize;
05917 
05918     <span class="comment">//</span>
05919     <span class="comment">//  We will only do the action if the heap has some tag entries</span>
05920     <span class="comment">//</span>
05921 
05922     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05923 
05924         <span class="comment">//</span>
05925         <span class="comment">//  Release all the memory used by the tag entries</span>
05926         <span class="comment">//</span>
05927 
05928         RegionSize = 0;
05929 
05930         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d7/freevm_8c.html#a6">NtFreeVirtualMemory</a>( NtCurrentProcess(),
05931                                       &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>,
05932                                       &amp;RegionSize,
05933                                       MEM_RELEASE );
05934 
05935         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
05936 
05937             Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05938         }
05939     }
05940 
05941     <span class="comment">//</span>
05942     <span class="comment">//  And return to our caller</span>
05943     <span class="comment">//</span>
05944 
05945     <span class="keywordflow">return</span>;
05946 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="heapdll.c::RtlpFreeHeapUsageEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PRTL_HEAP_USAGE_ENTRY RtlpFreeHeapUsageEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">PRTL_HEAP_USAGE_INTERNAL</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>PRTL_HEAP_USAGE_ENTRY&nbsp;</td>
          <td class="mdname" nowrap> <em>p</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l06092">6092</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, and <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02976">RtlUsageHeap()</a>.
<p>
<pre class="fragment"><div>06099                    :
06100 
06101     This routine moves a heap usage entry from its current
06102     list onto <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> free list and returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
06103     next heap usage entry in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> like doing a pop
06104     of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list denoted by <span class="stringliteral">"p"</span>
06105 
06106 Arguments:
06107 
06108     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> internal heap usage buffer
06109         being modified
06110 
06111     p - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entry being <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a100">moved</a>.  Okay <span class="keywordflow">if</span>
06112         <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>'s null
06113 
06114 Return Value:
06115 
06116     PRTL_HEAP_USAGE_ENTRY - Returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> next heap usage
06117         entry
06118 
06119 --*/
06120 
06121 {
06122     PRTL_HEAP_USAGE_ENTRY pTmp;
06123 
06124     <span class="comment">//</span>
06125     <span class="comment">//  Check if we have a non null heap entry and if so then add</span>
06126     <span class="comment">//  the entry to the front of the free list and return the next</span>
06127     <span class="comment">//  entry in the list</span>
06128     <span class="comment">//</span>
06129 
06130     <span class="keywordflow">if</span> (p != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06131 
06132         pTmp = p-&gt;Next;
06133 
06134         p-&gt;Next = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList;
06135 
06136         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList = p;
06137 
06138     } <span class="keywordflow">else</span> {
06139 
06140         pTmp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06141     }
06142 
06143     <span class="keywordflow">return</span> pTmp;
06144 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="heapdll.c::RtlpGetTagName" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PWSTR RtlpGetTagName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>TagIndex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05425">5425</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00233">HEAP_MAXIMUM_FREELISTS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00405">HEAP_NUMBER_OF_PSEUDO_TAG</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00337">_HEAP::NextAvailableTagIndex</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00365">_HEAP::PseudoTagEntries</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00462">RtlpGlobalTagHeap</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00075">RtlpPseudoTagNameBuffer</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00339">_HEAP::TagEntries</a>, and <a class="el" href="../../d4/d8/heap_8h-source.html#l00308">_HEAP_TAG_ENTRY::TagName</a>.
<p>
Referenced by <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00444">RtlDebugAllocateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00797">RtlDebugFreeHeap()</a>, and <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00603">RtlDebugReAllocateHeap()</a>.
<p>
<pre class="fragment"><div>05432                    :
05433 
05434     This routine returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag denoted by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap, tagindex
05435     tuple.
05436 
05437     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> called by heapdbg when doing a debug <a class="code" href="../../d0/d1/rtdeltre_8c.html#a5">print</a> to
05438     generate a tag name <span class="keywordflow">for</span> printing
05439 
05440 Arguments:
05441 
05442     Heap - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag being queried
05443 
05444     TagIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> index <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag being queried
05445 
05446 Return Value:
05447 
05448     PWSTR - returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> indicated tag
05449 
05450 --*/
05451 
05452 {
05453     <span class="comment">//</span>
05454     <span class="comment">//  If the processes global tag heap has not been initialized then</span>
05455     <span class="comment">//  not tag has a name</span>
05456     <span class="comment">//</span>
05457 
05458     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05459 
05460         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05461     }
05462 
05463     <span class="comment">//</span>
05464     <span class="comment">//  We only deal with non zero tag indices</span>
05465     <span class="comment">//</span>
05466 
05467     <span class="keywordflow">if</span> (TagIndex != 0) {
05468 
05469         <span class="comment">//</span>
05470         <span class="comment">//  If the tag index is for a pseudo tag then we clear the</span>
05471         <span class="comment">//  the psuedo bit and generate a pseudo tag name</span>
05472         <span class="comment">//</span>
05473 
05474         <span class="keywordflow">if</span> (TagIndex &amp; HEAP_PSEUDO_TAG_FLAG) {
05475 
05476             TagIndex &amp;= ~HEAP_PSEUDO_TAG_FLAG;
05477 
05478             <span class="comment">//</span>
05479             <span class="comment">//  Check that the tag index is valid and that the heap</span>
05480             <span class="comment">//  has some psuedo tag entries</span>
05481             <span class="comment">//</span>
05482 
05483             <span class="keywordflow">if</span> ((TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a32">HEAP_NUMBER_OF_PSEUDO_TAG</a>) &amp;&amp;
05484                 (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05485 
05486                 <span class="comment">//</span>
05487                 <span class="comment">//  A pseudo tag index of zero denote objects</span>
05488                 <span class="comment">//</span>
05489 
05490                 <span class="keywordflow">if</span> (TagIndex == 0) {
05491 
05492                     swprintf( RtlpPseudoTagNameBuffer, L<span class="stringliteral">"Objects&gt;%4u"</span>,
05493                               HEAP_MAXIMUM_FREELISTS &lt;&lt; HEAP_GRANULARITY_SHIFT );
05494 
05495                 <span class="comment">//</span>
05496                 <span class="comment">//  A psuedo tag index less than the free list maximum</span>
05497                 <span class="comment">//  denotes the dedicated free list</span>
05498                 <span class="comment">//</span>
05499 
05500                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>) {
05501 
05502                     swprintf( RtlpPseudoTagNameBuffer, L<span class="stringliteral">"Objects=%4u"</span>, TagIndex &lt;&lt; HEAP_GRANULARITY_SHIFT );
05503 
05504                 <span class="comment">//</span>
05505                 <span class="comment">//  Otherwise the pseudo tag is for the big allocations</span>
05506                 <span class="comment">//</span>
05507 
05508                 } <span class="keywordflow">else</span> {
05509 
05510                     swprintf( RtlpPseudoTagNameBuffer, L<span class="stringliteral">"VirtualAlloc"</span> );
05511                 }
05512 
05513                 <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a6">RtlpPseudoTagNameBuffer</a>;
05514             }
05515 
05516         <span class="comment">//</span>
05517         <span class="comment">//  Otherwise if the tag index is for a global tag then we pull</span>
05518         <span class="comment">//  the name off of the global heap.  Provided the index is valid</span>
05519         <span class="comment">//  and the heap does have some tag entries</span>
05520         <span class="comment">//</span>
05521 
05522         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex &amp; HEAP_GLOBAL_TAG) {
05523 
05524             TagIndex &amp;= ~HEAP_GLOBAL_TAG;
05525 
05526             <span class="keywordflow">if</span> ((TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05527                 (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05528 
05529                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ].<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>;
05530             }
05531 
05532         <span class="comment">//</span>
05533         <span class="comment">//  Otherwise we'll pull the name off of the input heap</span>
05534         <span class="comment">//  provided the index is valid and the heap does have some</span>
05535         <span class="comment">//  tag entries</span>
05536         <span class="comment">//</span>
05537 
05538         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05539                    (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05540 
05541             <span class="keywordflow">return</span> Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ].<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>;
05542         }
05543     }
05544 
05545     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05546 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="heapdll.c::RtlpGrowBlockInPlace" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlpGrowBlockInPlace           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>BusyBlock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>Size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>AllocationIndex</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04693">4693</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00397">ALLOC_HEAP_FILL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00395">CHECK_HEAP_TAIL_FILL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00394">CHECK_HEAP_TAIL_SIZE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00200">_HEAP_FREE_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00244">HEAP_ENTRY_SETTABLE_FLAGS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00231">HEAP_MAXIMUM_BLOCK_SIZE</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00277">_HEAP_SEGMENT::LastEntryInSegment</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00182">_HEAP_FREE_ENTRY::PreviousSize</a>, <a class="el" href="../../d9/d9/heappriv_8h.html#a60a31">ReAllocationAction</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00030">ROUND_UP_TO_POWER2</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05312">RtlpCoalesceFreeBlocks()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l04422">RtlpFindAndCommitPages()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05849">RtlpInsertFreeBlock()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00322">RtlpInsertFreeBlockDirect</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00465">RtlpRemoveFreeBlock</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05554">RtlpUpdateTagEntry()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00112">RtlpValidateHeapHeaders()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00189">_HEAP_FREE_ENTRY::SegmentIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00174">_HEAP_FREE_ENTRY::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00121">_HEAP_ENTRY_EXTRA::TagIndex</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00518">RtlReAllocateHeap()</a>.
<p>
<pre class="fragment"><div>04703                    :
04704 
04705     This routine will <span class="keywordflow">try</span> and grow a heap allocation block at its current
04706     location
04707 
04708 Arguments:
04709 
04710     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified
04711 
04712     Flags - Supplies a set of flags to augment those already enforced by
04713         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
04714 
04715     BusyBlock - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block being resized
04716 
04717     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, needed by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> resized block
04718 
04719     AllocationIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> allocation index <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> resized block
04720         Note that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size variable has not been rounded up to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> next
04721         granular block size, but that allocation index has.
04722 
04723 Return Value:
04724 
04725     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block has been resized and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise
04726 
04727 --*/
04728 
04729 {
04730     SIZE_T FreeSize;
04731     SIZE_T OldSize;
04732     UCHAR EntryFlags, FreeFlags;
04733     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock, SplitBlock, SplitBlock2;
04734     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> OldExtraStuff, NewExtraStuff;
04735 
04736     <span class="comment">//</span>
04737     <span class="comment">//  Check if the allocation index is too large for even the nondedicated</span>
04738     <span class="comment">//  free list (i.e., too large for list [0])</span>
04739     <span class="comment">//</span>
04740 
04741     <span class="keywordflow">if</span> (AllocationIndex &gt; Heap-&gt;VirtualMemoryThreshold) {
04742 
04743         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04744     }
04745 
04746     <span class="comment">//</span>
04747     <span class="comment">//  Get the flags for the current block and a pointer to the next</span>
04748     <span class="comment">//  block following the current block</span>
04749     <span class="comment">//</span>
04750 
04751     EntryFlags = BusyBlock-&gt;Flags;
04752 
04753     FreeBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)(BusyBlock + BusyBlock-&gt;Size);
04754 
04755     <span class="comment">//</span>
04756     <span class="comment">//  If the current block is the last entry before an uncommitted range</span>
04757     <span class="comment">//  we'll try and extend the uncommitted range to fit our new allocation</span>
04758     <span class="comment">//</span>
04759 
04760     <span class="keywordflow">if</span> (EntryFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
04761 
04762         <span class="comment">//</span>
04763         <span class="comment">//  Calculate how must more we need beyond the current block</span>
04764         <span class="comment">//  size</span>
04765         <span class="comment">//</span>
04766 
04767         FreeSize = (AllocationIndex - BusyBlock-&gt;Size) &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
04768         FreeSize = <a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( FreeSize, PAGE_SIZE );
04769 
04770         <span class="comment">//</span>
04771         <span class="comment">//  Try and commit memory at the desired location</span>
04772         <span class="comment">//</span>
04773 
04774         FreeBlock = <a class="code" href="../../d9/d9/heappriv_8h.html#a37">RtlpFindAndCommitPages</a>( Heap,
04775                                             Heap-&gt;Segments[ BusyBlock-&gt;SegmentIndex ],
04776                                             &amp;FreeSize,
04777                                             (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock );
04778 
04779         <span class="comment">//</span>
04780         <span class="comment">//  Check if the commit succeeded</span>
04781         <span class="comment">//</span>
04782 
04783         <span class="keywordflow">if</span> (FreeBlock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04784 
04785             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04786         }
04787 
04788         <span class="comment">//</span>
04789         <span class="comment">//  New coalesce this newly committed space with whatever is free</span>
04790         <span class="comment">//  around it</span>
04791         <span class="comment">//</span>
04792 
04793         FreeSize = FreeSize &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
04794 
04795         FreeBlock = <a class="code" href="../../d9/d9/heappriv_8h.html#a34">RtlpCoalesceFreeBlocks</a>( Heap, FreeBlock, &amp;FreeSize, FALSE );
04796 
04797         FreeFlags = FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
04798 
04799         <span class="comment">//</span>
04800         <span class="comment">//  If the newly allocated space plus the current block size is still</span>
04801         <span class="comment">//  not big enough for our resize effort then put this newly</span>
04802         <span class="comment">//  allocated block into the appropriate free list and tell our caller</span>
04803         <span class="comment">//  that a resize wasn't possible</span>
04804         <span class="comment">//</span>
04805 
04806         <span class="keywordflow">if</span> ((FreeSize + BusyBlock-&gt;Size) &lt; AllocationIndex) {
04807 
04808             <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, FreeBlock, FreeSize );
04809 
04810             Heap-&gt;TotalFreeSize += FreeSize;
04811 
04812             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>(Flags)) {
04813 
04814                 <a class="code" href="../../d9/d9/heappriv_8h.html#a50">RtlpValidateHeapHeaders</a>( Heap, TRUE );
04815             }
04816 
04817             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04818         }
04819 
04820         <span class="comment">//</span>
04821         <span class="comment">//  We were able to generate enough space for the resize effort, so</span>
04822         <span class="comment">//  now free size will be the index for the current block plus the</span>
04823         <span class="comment">//  new free space</span>
04824         <span class="comment">//</span>
04825 
04826         FreeSize += BusyBlock-&gt;Size;
04827 
04828     } <span class="keywordflow">else</span> {
04829 
04830         <span class="comment">//</span>
04831         <span class="comment">//  The following block is present so grab its flags and see if</span>
04832         <span class="comment">//  it is free or busy.  If busy then we cannot grow the current</span>
04833         <span class="comment">//  block</span>
04834         <span class="comment">//</span>
04835 
04836         FreeFlags = FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
04837 
04838         <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
04839 
04840             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04841         }
04842 
04843         <span class="comment">//</span>
04844         <span class="comment">//  Compute the index if we combine current block with its following</span>
04845         <span class="comment">//  free block and check if it is big enough</span>
04846         <span class="comment">//</span>
04847 
04848         FreeSize = BusyBlock-&gt;Size + FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
04849 
04850         <span class="keywordflow">if</span> (FreeSize &lt; AllocationIndex) {
04851 
04852             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04853         }
04854 
04855         <span class="comment">//</span>
04856         <span class="comment">//  The two blocks together are big enough so now remove the free</span>
04857         <span class="comment">//  block from its free list, and update the heap's total free size</span>
04858         <span class="comment">//</span>
04859 
04860         <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, FreeBlock );
04861 
04862         Heap-&gt;TotalFreeSize -= FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
04863     }
04864 
04865     <span class="comment">//</span>
04866     <span class="comment">//  At this point we have a busy block followed by a free block that</span>
04867     <span class="comment">//  together have enough space for the resize.  The free block has been</span>
04868     <span class="comment">//  removed from its list and free size is the index of the two combined</span>
04869     <span class="comment">//  blocks.</span>
04870     <span class="comment">//</span>
04871     <span class="comment">//  Calculate the number of bytes in use in the old block</span>
04872     <span class="comment">//</span>
04873 
04874     OldSize = (BusyBlock-&gt;Size &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) - BusyBlock-&gt;UnusedBytes;
04875 
04876     <span class="comment">//</span>
04877     <span class="comment">//  Calculate the index for whatever excess we'll have when we combine</span>
04878     <span class="comment">//  the two blocks</span>
04879     <span class="comment">//</span>
04880 
04881     FreeSize -= AllocationIndex;
04882 
04883     <span class="comment">//</span>
04884     <span class="comment">//  If the excess is not too much then put it back in our allocation</span>
04885     <span class="comment">//  (i.e., we don't want small free pieces left over)</span>
04886     <span class="comment">//</span>
04887 
04888     <span class="keywordflow">if</span> (FreeSize &lt;= 2) {
04889 
04890         AllocationIndex += FreeSize;
04891 
04892         FreeSize = 0;
04893     }
04894 
04895     <span class="comment">//</span>
04896     <span class="comment">//  If the busy block has an extra stuff struct present then copy over the</span>
04897     <span class="comment">//  extra stuff</span>
04898     <span class="comment">//</span>
04899 
04900     <span class="keywordflow">if</span> (EntryFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
04901 
04902         OldExtraStuff = (<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a>)(BusyBlock + BusyBlock-&gt;Size - 1);
04903         NewExtraStuff = (<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a>)(BusyBlock + AllocationIndex - 1);
04904 
04905         *NewExtraStuff = *OldExtraStuff;
04906 
04907         <span class="comment">//</span>
04908         <span class="comment">//  If heap tagging is enabled then update the heap tag from the extra</span>
04909         <span class="comment">//  stuff struct</span>
04910         <span class="comment">//</span>
04911 
04912         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
04913 
04914             NewExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> =
04915                 <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
04916                                     NewExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>,
04917                                     BusyBlock-&gt;Size,
04918                                     AllocationIndex,
04919                                     ReAllocationAction );
04920         }
04921 
04922     <span class="comment">//</span>
04923     <span class="comment">//  Otherwise extra stuff is not in use so see if heap tagging is enabled</span>
04924     <span class="comment">//  and if so then update small tag index</span>
04925     <span class="comment">//</span>
04926 
04927     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
04928 
04929         BusyBlock-&gt;SmallTagIndex = (UCHAR)
04930             <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
04931                                 BusyBlock-&gt;SmallTagIndex,
04932                                 BusyBlock-&gt;Size,
04933                                 AllocationIndex,
04934                                 ReAllocationAction );
04935     }
04936 
04937     <span class="comment">//</span>
04938     <span class="comment">//  Check if we will have any free space to give back.</span>
04939     <span class="comment">//</span>
04940 
04941     <span class="keywordflow">if</span> (FreeSize == 0) {
04942 
04943         <span class="comment">//</span>
04944         <span class="comment">//  No following free space so update the flags, size and byte counts</span>
04945         <span class="comment">//  for the resized block.  If the free block was a last entry</span>
04946         <span class="comment">//  then the busy block must also now be a last entry.</span>
04947         <span class="comment">//</span>
04948 
04949         BusyBlock-&gt;Flags |= FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
04950 
04951         BusyBlock-&gt;Size = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
04952 
04953         BusyBlock-&gt;UnusedBytes = (UCHAR)
04954             ((AllocationIndex &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
04955 
04956         <span class="comment">//</span>
04957         <span class="comment">//  Update the previous size field of the following block if it exists</span>
04958         <span class="comment">//</span>
04959 
04960         <span class="keywordflow">if</span> (!(FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
04961 
04962             (BusyBlock + BusyBlock-&gt;Size)-&gt;PreviousSize = BusyBlock-&gt;Size;
04963 
04964         } <span class="keywordflow">else</span> {
04965 
04966             <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
04967 
04968             Segment = Heap-&gt;Segments[BusyBlock-&gt;SegmentIndex];
04969             Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = BusyBlock;
04970         }
04971 
04972     <span class="comment">//</span>
04973     <span class="comment">//  Otherwise there is some free space to return to the heap</span>
04974     <span class="comment">//</span>
04975 
04976     } <span class="keywordflow">else</span> {
04977 
04978         <span class="comment">//</span>
04979         <span class="comment">//  Update the size and byte counts for the resized block.</span>
04980         <span class="comment">//</span>
04981 
04982         BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
04983 
04984         BusyBlock-&gt;UnusedBytes = (UCHAR)
04985             ((AllocationIndex &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
04986 
04987         <span class="comment">//</span>
04988         <span class="comment">//  Determine where the new free block starts and fill in its fields</span>
04989         <span class="comment">//</span>
04990 
04991         SplitBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BusyBlock + AllocationIndex);
04992 
04993         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
04994 
04995         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a> = BusyBlock-&gt;SegmentIndex;
04996 
04997         <span class="comment">//</span>
04998         <span class="comment">//  If this new free block will be the last entry then update its</span>
04999         <span class="comment">//  flags and size and put it into the appropriate free list</span>
05000         <span class="comment">//</span>
05001 
05002         <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
05003 
05004             <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
05005 
05006             Segment = Heap-&gt;Segments[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
05007             Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
05008 
05009             SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = FreeFlags;
05010             SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
05011 
05012             <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize );
05013 
05014             Heap-&gt;TotalFreeSize += FreeSize;
05015 
05016         <span class="comment">//</span>
05017         <span class="comment">//  The free block is followed by another valid block</span>
05018         <span class="comment">//</span>
05019 
05020         } <span class="keywordflow">else</span> {
05021 
05022             <span class="comment">//</span>
05023             <span class="comment">//  Point to the block following our new free block</span>
05024             <span class="comment">//</span>
05025 
05026             SplitBlock2 = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize);
05027 
05028             <span class="comment">//</span>
05029             <span class="comment">//  If the block following the new free block is busy then</span>
05030             <span class="comment">//  update the flags and size for the new free block, update</span>
05031             <span class="comment">//  the following blocks previous size, and put the free block</span>
05032             <span class="comment">//  into the appropriate free list</span>
05033             <span class="comment">//</span>
05034 
05035             <span class="keywordflow">if</span> (SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
05036 
05037                 SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = FreeFlags &amp; (~<a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>);
05038                 SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
05039 
05040                 <span class="comment">//</span>
05041                 <span class="comment">//  **** note that this test must be true because we are</span>
05042                 <span class="comment">//  **** already in the else clause of the</span>
05043                 <span class="comment">//  **** if (FreeFlags &amp; HEAP_ENTRY_LAST_ENTRY) statement</span>
05044                 <span class="comment">//</span>
05045 
05046                 <span class="keywordflow">if</span> (!(FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
05047 
05048                     ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize)-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
05049 
05050                 } <span class="keywordflow">else</span> {
05051 
05052                     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
05053 
05054                     Segment = Heap-&gt;Segments[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
05055                     Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
05056                 }
05057 
05058                 <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize );
05059 
05060                 Heap-&gt;TotalFreeSize += FreeSize;
05061 
05062             <span class="comment">//</span>
05063             <span class="comment">//  Otherwise the following block is also free so we can combine</span>
05064             <span class="comment">//  these two blocks</span>
05065             <span class="comment">//</span>
05066 
05067             } <span class="keywordflow">else</span> {
05068 
05069                 <span class="comment">//</span>
05070                 <span class="comment">//  Remember the new free flags from the following block</span>
05071                 <span class="comment">//</span>
05072 
05073                 FreeFlags = SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
05074 
05075                 <span class="comment">//</span>
05076                 <span class="comment">//  Remove the following block from its free list</span>
05077                 <span class="comment">//</span>
05078 
05079                 <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, SplitBlock2 );
05080 
05081                 Heap-&gt;TotalFreeSize -= SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
05082 
05083                 <span class="comment">//</span>
05084                 <span class="comment">//  Calculate the size of the new combined free block</span>
05085                 <span class="comment">//</span>
05086 
05087                 FreeSize += SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
05088 
05089                 <span class="comment">//</span>
05090                 <span class="comment">//  Give the new the its new flags</span>
05091                 <span class="comment">//</span>
05092 
05093                 SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = FreeFlags;
05094 
05095                 <span class="comment">//</span>
05096                 <span class="comment">//  If the combited block is not too large for the dedicated</span>
05097                 <span class="comment">//  free lists then that where we'll put it</span>
05098                 <span class="comment">//</span>
05099 
05100                 <span class="keywordflow">if</span> (FreeSize &lt;= <a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>) {
05101 
05102                     SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
05103 
05104                     <span class="comment">//</span>
05105                     <span class="comment">//  If present update the previous size for the following block</span>
05106                     <span class="comment">//</span>
05107 
05108                     <span class="keywordflow">if</span> (!(FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
05109 
05110                         ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize)-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
05111 
05112                     } <span class="keywordflow">else</span> {
05113 
05114                         <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
05115 
05116                         Segment = Heap-&gt;Segments[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
05117                         Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
05118                     }
05119 
05120                     <span class="comment">//</span>
05121                     <span class="comment">//  Insert the new combined free block into the free list</span>
05122                     <span class="comment">//</span>
05123 
05124                     <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize );
05125 
05126                     Heap-&gt;TotalFreeSize += FreeSize;
05127 
05128                 } <span class="keywordflow">else</span> {
05129 
05130                     <span class="comment">//</span>
05131                     <span class="comment">//  Otherwise the new free block is too large to go into</span>
05132                     <span class="comment">//  a dedicated free list so put it in the general free list</span>
05133                     <span class="comment">//  which might involve breaking it apart.</span>
05134                     <span class="comment">//</span>
05135 
05136                     <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, SplitBlock, FreeSize );
05137                 }
05138             }
05139         }
05140     }
05141 
05142     <span class="comment">//</span>
05143     <span class="comment">//  At this point the block has been resized and any extra space has been</span>
05144     <span class="comment">//  returned to the free list</span>
05145     <span class="comment">//</span>
05146     <span class="comment">//  Check if we should zero out the new space</span>
05147     <span class="comment">//</span>
05148 
05149     <span class="keywordflow">if</span> (Flags &amp; HEAP_ZERO_MEMORY) {
05150 
05151         <span class="comment">//</span>
05152         <span class="comment">//  **** this test is sort of bogus because we're resizing and the new</span>
05153         <span class="comment">//  **** size by definition must be larger than the old size</span>
05154         <span class="comment">//</span>
05155 
05156         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; OldSize) {
05157 
05158             RtlZeroMemory( (PCHAR)(BusyBlock + 1) + OldSize,
05159                            Size - OldSize );
05160         }
05161 
05162     <span class="comment">//</span>
05163     <span class="comment">//  Check if we should be filling in heap after it as</span>
05164     <span class="comment">//  been freed, and if so then fill in the newly allocated</span>
05165     <span class="comment">//  space beyond the old bytes.</span>
05166     <span class="comment">//</span>
05167 
05168     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Heap-&gt;Flags &amp; HEAP_FREE_CHECKING_ENABLED) {
05169 
05170         SIZE_T PartialBytes, ExtraSize;
05171 
05172         PartialBytes = OldSize &amp; (<span class="keyword">sizeof</span>( ULONG ) - 1);
05173 
05174         <span class="keywordflow">if</span> (PartialBytes) {
05175 
05176             PartialBytes = 4 - PartialBytes;
05177         }
05178 
05179         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; (OldSize + PartialBytes)) {
05180 
05181             ExtraSize = (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - (OldSize + PartialBytes)) &amp; ~(<span class="keyword">sizeof</span>( ULONG ) - 1);
05182 
05183             <span class="keywordflow">if</span> (ExtraSize != 0) {
05184 
05185                 RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
05186                                     ExtraSize,
05187                                     ALLOC_HEAP_FILL );
05188             }
05189         }
05190     }
05191 
05192     <span class="comment">//</span>
05193     <span class="comment">//  If we are going tailing checking then fill in the space right beyond</span>
05194     <span class="comment">//  the new allocation</span>
05195     <span class="comment">//</span>
05196 
05197     <span class="keywordflow">if</span> (Heap-&gt;Flags &amp; HEAP_TAIL_CHECKING_ENABLED) {
05198 
05199         RtlFillMemory( (PCHAR)(BusyBlock + 1) + Size,
05200                        CHECK_HEAP_TAIL_SIZE,
05201                        CHECK_HEAP_TAIL_FILL );
05202     }
05203 
05204     <span class="comment">//</span>
05205     <span class="comment">//  Give the resized block any user settable flags send in by the</span>
05206     <span class="comment">//  caller</span>
05207     <span class="comment">//</span>
05208 
05209     BusyBlock-&gt;Flags &amp;= ~<a class="code" href="../../d3/d9/heap_8h.html#a16">HEAP_ENTRY_SETTABLE_FLAGS</a>;
05210     BusyBlock-&gt;Flags |= ((Flags &amp; HEAP_SETTABLE_USER_FLAGS) &gt;&gt; 4);
05211 
05212     <span class="comment">//</span>
05213     <span class="comment">//  And return to our caller</span>
05214     <span class="comment">//</span>
05215 
05216     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05217 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a46" doxytag="heapdll.c::RtlpHeapIsLocked" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlpHeapIsLocked           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>HeapHandle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l06152">6152</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d6/struct__HEAP__LOCK.html#o2">_HEAP_LOCK::Lock</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d7/d8/heappage_8c-source.html#l03883">RtlpDebugPageHeapIsLocked()</a>.
<p>
Referenced by <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l01462">LdrShutdownProcess()</a>.
<p>
<pre class="fragment"><div>06158                    :
06159 
06160     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to determine <span class="keywordflow">if</span> a heap <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> locked
06161 
06162 Arguments:
06163 
06164     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being queried
06165 
06166 Return Value:
06167 
06168     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> locked and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise
06169 
06170 --*/
06171 
06172 {
06173     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap;
06174 
06175     <span class="comment">//</span>
06176     <span class="comment">//  Check if this is guard page version of heap</span>
06177     <span class="comment">//</span>
06178 
06179     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
06180                                     <a class="code" href="../../d7/d9/heappage_8h.html#a29">RtlpDebugPageHeapIsLocked</a>( HeapHandle ));
06181 
06182     Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
06183 
06184     <span class="comment">//</span>
06185     <span class="comment">//  The heap is locked if there is a lock variable, and it has an</span>
06186     <span class="comment">//  owning thread or the lockcount is not -1</span>
06187     <span class="comment">//</span>
06188 
06189     <span class="keywordflow">return</span> (( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp;
06190             ( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a>-&gt;<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a>.CriticalSection.OwningThread ||
06191               Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a>-&gt;<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a>.CriticalSection.LockCount != -1 ));
06192 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a41" doxytag="heapdll.c::RtlpRemoveHeapFromProcessList" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpRemoveHeapFromProcessList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Heap</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04571">4571</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d6/struct__HEAP__LOCK.html#o2">_HEAP_LOCK::Lock</a>, <a class="el" href="../../d8/d9/exts_8h-source.html#l00092">n</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00053">RtlpProcessHeapsListLock</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00076">RtlpUpdateHeapListIndex()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l01133">RtlDestroyHeap()</a>.
<p>
<pre class="fragment"><div>04577                    :
04578 
04579     This routine removes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified heap to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap list <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
04580     current process
04581 
04582 Arguments:
04583 
04584     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being removed
04585 
04586 Return Value:
04587 
04588     None.
04589 
04590 --*/
04591 
04592 {
04593     PPEB Peb = NtCurrentPeb();
04594     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> *p, *p1;
04595     ULONG <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
04596 
04597     <span class="comment">//</span>
04598     <span class="comment">//  Lock the current processes heap list lock</span>
04599     <span class="comment">//</span>
04600 
04601     <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
04602 
04603     <span class="keywordflow">try</span> {
04604 
04605         <span class="comment">//</span>
04606         <span class="comment">//  We only want to the the work if the current process actually has some</span>
04607         <span class="comment">//  heaps, the index stored in the heap is within the range for active</span>
04608         <span class="comment">//  heaps.  Note that the heaps stored index is bias by one.</span>
04609         <span class="comment">//</span>
04610 
04611         <span class="keywordflow">if</span> ((Peb-&gt;NumberOfHeaps != 0) &amp;&amp;
04612             (Heap-&gt;ProcessHeapsListIndex != 0) &amp;&amp;
04613             (Heap-&gt;ProcessHeapsListIndex &lt;= Peb-&gt;NumberOfHeaps)) {
04614 
04615             <span class="comment">//</span>
04616             <span class="comment">//  Establish a pointer into the array of process heaps at the</span>
04617             <span class="comment">//  current heap location and one beyond</span>
04618             <span class="comment">//</span>
04619 
04620             p = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> *)&amp;Peb-&gt;ProcessHeaps[ Heap-&gt;ProcessHeapsListIndex - 1 ];
04621 
04622             p1 = p + 1;
04623 
04624             <span class="comment">//</span>
04625             <span class="comment">//  Calculate the number of heaps that exist beyond the current</span>
04626             <span class="comment">//  heap in the array including the current heap location</span>
04627             <span class="comment">//</span>
04628 
04629             <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = Peb-&gt;NumberOfHeaps - (Heap-&gt;ProcessHeapsListIndex - 1);
04630 
04631             <span class="comment">//</span>
04632             <span class="comment">//  For every heap beyond the current one that we are removing</span>
04633             <span class="comment">//  we'll move that heap down to the previous index.</span>
04634             <span class="comment">//</span>
04635 
04636             <span class="keywordflow">while</span> (--<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>) {
04637 
04638                 <span class="comment">//</span>
04639                 <span class="comment">//  Copy the heap process array entry of the next entry to</span>
04640                 <span class="comment">//  the current entry, and move p1 to the next next entry</span>
04641                 <span class="comment">//</span>
04642 
04643                 *p = *p1++;
04644 
04645                 <span class="comment">//</span>
04646                 <span class="comment">//  This is simply a debugging call</span>
04647                 <span class="comment">//</span>
04648 
04649                 <a class="code" href="../../d9/d9/heappriv_8h.html#a49">RtlpUpdateHeapListIndex</a>( (*p)-&gt;ProcessHeapsListIndex,
04650                                          (USHORT)((*p)-&gt;ProcessHeapsListIndex - 1));
04651 
04652                 <span class="comment">//</span>
04653                 <span class="comment">//  Assign the moved heap its new heap index</span>
04654                 <span class="comment">//</span>
04655 
04656                 (*p)-&gt;ProcessHeapsListIndex -= 1;
04657 
04658                 <span class="comment">//</span>
04659                 <span class="comment">//  Move on to the next heap entry</span>
04660                 <span class="comment">//</span>
04661 
04662                 p += 1;
04663             }
04664 
04665             <span class="comment">//</span>
04666             <span class="comment">//  Zero out the last process heap pointer, update the count, and</span>
04667             <span class="comment">//  make the heap we just removed realize it has been removed by</span>
04668             <span class="comment">//  zeroing out its process heap list index</span>
04669             <span class="comment">//</span>
04670 
04671             Peb-&gt;ProcessHeaps[ --Peb-&gt;NumberOfHeaps ] = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04672             Heap-&gt;ProcessHeapsListIndex = 0;
04673         }
04674 
04675     } finally {
04676 
04677         <span class="comment">//</span>
04678         <span class="comment">//  Unlock the current processes heap list lock</span>
04679         <span class="comment">//</span>
04680 
04681         <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
04682     }
04683 
04684     <span class="keywordflow">return</span>;
04685 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a44" doxytag="heapdll.c::RtlpResetTags" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpResetTags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Heap</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05802">5802</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00303">_HEAP_TAG_ENTRY::Allocs</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00312">_HEAP_PSEUDO_TAG_ENTRY::Allocs</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00304">_HEAP_TAG_ENTRY::Frees</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00313">_HEAP_PSEUDO_TAG_ENTRY::Frees</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00405">HEAP_NUMBER_OF_PSEUDO_TAG</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00337">_HEAP::NextAvailableTagIndex</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00365">_HEAP::PseudoTagEntries</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00305">_HEAP_TAG_ENTRY::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00314">_HEAP_PSEUDO_TAG_ENTRY::Size</a>, and <a class="el" href="../../d4/d8/heap_8h-source.html#l00339">_HEAP::TagEntries</a>.
<p>
<pre class="fragment"><div>05808                    :
05809 
05810     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to reset all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag entries in a heap
05811 
05812 Arguments:
05813 
05814     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified
05815 
05816 Return Value:
05817 
05818     None.
05819 
05820 --*/
05821 
05822 {
05823     <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> TagEntry;
05824     <a class="code" href="../../d7/d6/struct__HEAP__PSEUDO__TAG__ENTRY.html">PHEAP_PSEUDO_TAG_ENTRY</a> PseudoTagEntry;
05825     ULONG i;
05826 
05827     <span class="comment">//</span>
05828     <span class="comment">//  We only have work to do if the heap has any allocated tag entries</span>
05829     <span class="comment">//</span>
05830 
05831     TagEntry = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>;
05832 
05833     <span class="keywordflow">if</span> (TagEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05834 
05835         <span class="comment">//</span>
05836         <span class="comment">//  For every tag entry in the heap we will zero out its counters</span>
05837         <span class="comment">//</span>
05838 
05839         <span class="keywordflow">for</span> (i=0; i&lt;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>; i++) {
05840 
05841             TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a> = 0;
05842             TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a> = 0;
05843             TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> = 0;
05844 
05845             <span class="comment">//</span>
05846             <span class="comment">//  Advance to the next tag entry</span>
05847             <span class="comment">//</span>
05848 
05849             TagEntry += 1;
05850         }
05851     }
05852 
05853     <span class="comment">//</span>
05854     <span class="comment">//  We will only reset the pseudo tags if they exist</span>
05855     <span class="comment">//</span>
05856 
05857     PseudoTagEntry = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a>;
05858 
05859     <span class="keywordflow">if</span> (PseudoTagEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05860 
05861         <span class="comment">//</span>
05862         <span class="comment">//  For every pseudo tag entry in the heap we will zero out its</span>
05863         <span class="comment">//  counters</span>
05864         <span class="comment">//</span>
05865 
05866         <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="../../d3/d9/heap_8h.html#a32">HEAP_NUMBER_OF_PSEUDO_TAG</a>; i++) {
05867 
05868             PseudoTagEntry-&gt;<a class="code" href="../../d7/d6/struct__HEAP__PSEUDO__TAG__ENTRY.html#o0">Allocs</a> = 0;
05869             PseudoTagEntry-&gt;<a class="code" href="../../d7/d6/struct__HEAP__PSEUDO__TAG__ENTRY.html#o1">Frees</a> = 0;
05870             PseudoTagEntry-&gt;<a class="code" href="../../d7/d6/struct__HEAP__PSEUDO__TAG__ENTRY.html#o2">Size</a> = 0;
05871 
05872             <span class="comment">//</span>
05873             <span class="comment">//  Advance to the next pseudo tag entry</span>
05874             <span class="comment">//</span>
05875 
05876             PseudoTagEntry += 1;
05877         }
05878     }
05879 
05880     <span class="comment">//</span>
05881     <span class="comment">//  And return to our caller</span>
05882     <span class="comment">//</span>
05883 
05884     <span class="keywordflow">return</span>;
05885 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="heapdll.c::RtlProtectHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlProtectHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>MakeReadOnly</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00258">258</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00267">_HEAP_SEGMENT::BaseAddress</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00234">HEAP_MAXIMUM_SEGMENTS</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00270">_HEAP_SEGMENT::LastValidEntry</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00355">_HEAP::Segments</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, and <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>.
<p>
<pre class="fragment"><div>00265                    :
00266 
00267     This routine will change <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> protection on all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pages in a heap
00268     to be either readonly or readwrite
00269 
00270 Arguments:
00271 
00272     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being altered
00273 
00274     MakeReadOnly - Specifies <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be <a class="code" href="../../d3/d0/user32_8def.html#a107">made</a> readonly or
00275         readwrite
00276 
00277 Return Value:
00278 
00279     None.
00280 
00281 --*/
00282 
00283 {
00284     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap;
00285     UCHAR SegmentIndex;
00286     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
00287     MEMORY_BASIC_INFORMATION VaInfo;
00288     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00289     PVOID Address;
00290     PVOID ProtectAddress;
00291     SIZE_T <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00292     ULONG OldProtect;
00293     ULONG NewProtect;
00294 
00295     Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00296 
00297     <span class="comment">//</span>
00298     <span class="comment">//  For every valid segment in the heap we will zoom through all its</span>
00299     <span class="comment">//  regions and for those that are committed we'll change it protection</span>
00300     <span class="comment">//</span>
00301 
00302     <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
00303 
00304         Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
00305 
00306         <span class="keywordflow">if</span> ( Segment ) {
00307 
00308             <span class="comment">//</span>
00309             <span class="comment">//  Starting from the first address for the segment and going to</span>
00310             <span class="comment">//  the last address in the segment we'll step through by regions</span>
00311             <span class="comment">//</span>
00312 
00313             Address = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o5">BaseAddress</a>;
00314 
00315             <span class="keywordflow">while</span> ((ULONG_PTR)Address &lt; (ULONG_PTR)(Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>)) {
00316 
00317                 <span class="comment">//</span>
00318                 <span class="comment">//  Query the current region to get its state and size</span>
00319                 <span class="comment">//</span>
00320 
00321                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryVirtualMemory( NtCurrentProcess(),
00322                                                Address,
00323                                                MemoryBasicInformation,
00324                                                &amp;VaInfo,
00325                                                <span class="keyword">sizeof</span>(VaInfo),
00326                                                NULL );
00327 
00328                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00329 
00330                     <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"VirtualQuery Failed 0x%08x %x\n"</span>, Address, Status ));
00331 
00332                     <span class="keywordflow">return</span>;
00333                 }
00334 
00335                 <span class="comment">//</span>
00336                 <span class="comment">//  If we found a commited block then set its protection</span>
00337                 <span class="comment">//</span>
00338 
00339                 <span class="keywordflow">if</span> (VaInfo.State == MEM_COMMIT) {
00340 
00341                     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = VaInfo.RegionSize;
00342 
00343                     ProtectAddress = Address;
00344 
00345                     <span class="keywordflow">if</span> (MakeReadOnly) {
00346 
00347                         NewProtect = PAGE_READONLY;
00348 
00349                     } <span class="keywordflow">else</span> {
00350 
00351                         NewProtect = PAGE_READWRITE;
00352                     }
00353 
00354                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwProtectVirtualMemory( NtCurrentProcess(),
00355                                                      &amp;ProtectAddress,
00356                                                      &amp;Size,
00357                                                      NewProtect,
00358                                                      &amp;OldProtect );
00359 
00360                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00361 
00362                         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"VirtualProtect Failed 0x%08x %x\n"</span>, Address, Status ));
00363 
00364                         <span class="keywordflow">return</span>;
00365                     }
00366                 }
00367 
00368                 <span class="comment">//</span>
00369                 <span class="comment">//  Now calculate the address of the next region in the segment</span>
00370                 <span class="comment">//</span>
00371 
00372                 Address = (PVOID)((PCHAR)Address + VaInfo.RegionSize);
00373             }
00374         }
00375     }
00376 
00377     <span class="comment">//</span>
00378     <span class="comment">//  And return to our caller</span>
00379     <span class="comment">//</span>
00380 
00381     <span class="keywordflow">return</span>;
00382 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="heapdll.c::RtlpUpdateTagEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a> RtlpUpdateTagEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>TagIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>OldSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>NewSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="../../d9/d9/heappriv_8h.html#a24">HEAP_TAG_ACTION</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Action</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05554">5554</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d8/d9/cmdat2_8c-source.html#l00090">Action</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00303">_HEAP_TAG_ENTRY::Allocs</a>, <a class="el" href="../../d9/d9/heappriv_8h.html#a60a29">FreeAction</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00304">_HEAP_TAG_ENTRY::Frees</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00233">HEAP_MAXIMUM_FREELISTS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00405">HEAP_NUMBER_OF_PSEUDO_TAG</a>, <a class="el" href="../../d9/d9/heappriv_8h.html#a24">HEAP_TAG_ACTION</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00337">_HEAP::NextAvailableTagIndex</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00365">_HEAP::PseudoTagEntries</a>, <a class="el" href="../../d9/d9/heappriv_8h.html#a60a31">ReAllocationAction</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00462">RtlpGlobalTagHeap</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00305">_HEAP_TAG_ENTRY::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00339">_HEAP::TagEntries</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>, <a class="el" href="../../d9/d9/heappriv_8h.html#a60a28">VirtualAllocationAction</a>, and <a class="el" href="../../d9/d9/heappriv_8h.html#a60a32">VirtualReAllocationAction</a>.
<p>
Referenced by <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l02075">RtlAllocateHeapSlowly()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l03273">RtlFreeHeapSlowly()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04693">RtlpGrowBlockInPlace()</a>, and <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00518">RtlReAllocateHeap()</a>.
<p>
<pre class="fragment"><div>05564                    :
05565 
05566     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to modify a tag entry
05567 
05568 Arguments:
05569 
05570     Heap - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified
05571 
05572     TagIndex - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag being modified
05573 
05574     OldSize - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> old allocation index of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block associated with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag
05575 
05576     NewSize - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> allocation index of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block associated with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag
05577 
05578     <a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> of action being performed on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap tag
05579 
05580 Return Value:
05581 
05582     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> - Returns a tag index <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly updated tag
05583 
05584 --*/
05585 
05586 {
05587     <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> TagEntry;
05588 
05589     <span class="comment">//</span>
05590     <span class="comment">//  If the processes tag heap does not exist then we'll return a zero index</span>
05591     <span class="comment">//  right away</span>
05592     <span class="comment">//</span>
05593 
05594     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05595 
05596         <span class="keywordflow">return</span> 0;
05597     }
05598 
05599     <span class="comment">//</span>
05600     <span class="comment">//  If the action is greater than or equal to free action then it is</span>
05601     <span class="comment">//  either FreeAction, VirtualFreeAction, ReAllocationAction, or</span>
05602     <span class="comment">//  VirtualReAllocationAction.  Which means we already should have a tag</span>
05603     <span class="comment">//  that is simply being modified</span>
05604     <span class="comment">//</span>
05605 
05606     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> &gt;= <a class="code" href="../../d9/d9/heappriv_8h.html#a60a29">FreeAction</a>) {
05607 
05608         <span class="comment">//</span>
05609         <span class="comment">//  If the tag index is zero then there is nothing for us to do</span>
05610         <span class="comment">//</span>
05611 
05612         <span class="keywordflow">if</span> (TagIndex == 0) {
05613 
05614             <span class="keywordflow">return</span> 0;
05615         }
05616 
05617         <span class="comment">//</span>
05618         <span class="comment">//  If this is a pseudo tag then make sure the rest of the tag index</span>
05619         <span class="comment">//  after we remove the psuedo bit is valid and that the heap is</span>
05620         <span class="comment">//  actually maintaining pseudo tags</span>
05621         <span class="comment">//</span>
05622 
05623         <span class="keywordflow">if</span> (TagIndex &amp; HEAP_PSEUDO_TAG_FLAG) {
05624 
05625             TagIndex &amp;= ~HEAP_PSEUDO_TAG_FLAG;
05626 
05627             <span class="keywordflow">if</span> ((TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a32">HEAP_NUMBER_OF_PSEUDO_TAG</a>) &amp;&amp;
05628                 (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05629 
05630                 TagEntry = (<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a>)(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> + TagIndex);
05631 
05632                 TagIndex |= HEAP_PSEUDO_TAG_FLAG;
05633 
05634             } <span class="keywordflow">else</span> {
05635 
05636                 <span class="keywordflow">return</span> 0;
05637             }
05638 
05639         <span class="comment">//</span>
05640         <span class="comment">//  Otherwise if this is a global tag then make sure the tag index</span>
05641         <span class="comment">//  after we remove the global bit is valid and that the global tag</span>
05642         <span class="comment">//  heap has some tag entries</span>
05643         <span class="comment">//</span>
05644 
05645         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex &amp; HEAP_GLOBAL_TAG) {
05646 
05647             TagIndex &amp;= ~HEAP_GLOBAL_TAG;
05648 
05649             <span class="keywordflow">if</span> ((TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05650                 (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05651 
05652                 TagEntry = &amp;<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ];
05653 
05654                 TagIndex |= HEAP_GLOBAL_TAG;
05655 
05656             } <span class="keywordflow">else</span> {
05657 
05658                 <span class="keywordflow">return</span> 0;
05659             }
05660 
05661         <span class="comment">//</span>
05662         <span class="comment">//  Otherwise we have a regular tag index that we need to make sure</span>
05663         <span class="comment">//  is a valid value and that the heap has some tag entries</span>
05664         <span class="comment">//</span>
05665 
05666         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05667                    (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05668 
05669             TagEntry = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ];
05670 
05671         } <span class="keywordflow">else</span> {
05672 
05673             <span class="keywordflow">return</span> 0;
05674         }
05675 
05676         <span class="comment">//</span>
05677         <span class="comment">//  At this point we have a tag entry and tag index.  Increment the</span>
05678         <span class="comment">//  number of frees we've done on the tag, and decrement the size by</span>
05679         <span class="comment">//  the number of bytes we've just freed</span>
05680         <span class="comment">//</span>
05681 
05682         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a> += 1;
05683 
05684         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> -= OldSize;
05685 
05686         <span class="comment">//</span>
05687         <span class="comment">//  Now if the action is either ReAllocationAction or</span>
05688         <span class="comment">//  VirtualReAllocationAction.  Then we get to add back in the</span>
05689         <span class="comment">//  new size and the allocation count</span>
05690         <span class="comment">//</span>
05691 
05692         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> &gt;= <a class="code" href="../../d9/d9/heappriv_8h.html#a60a31">ReAllocationAction</a>) {
05693 
05694             <span class="comment">//</span>
05695             <span class="comment">//  If the this is a pseudo tag then we tag entry goes off the</span>
05696             <span class="comment">//  pseudo tag list</span>
05697             <span class="comment">//</span>
05698 
05699             <span class="keywordflow">if</span> (TagIndex &amp; HEAP_PSEUDO_TAG_FLAG) {
05700 
05701                 TagIndex = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(NewSize &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> ?
05702                                         NewSize :
05703                                         (<a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> == <a class="code" href="../../d9/d9/heappriv_8h.html#a60a32">VirtualReAllocationAction</a> ? <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> : 0));
05704 
05705                 TagEntry = (<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a>)(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> + TagIndex);
05706 
05707                 TagIndex |= HEAP_PSEUDO_TAG_FLAG;
05708             }
05709 
05710             TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a> += 1;
05711 
05712             TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> += NewSize;
05713         }
05714 
05715     <span class="comment">//</span>
05716     <span class="comment">//  The action is either AllocationAction or VirtualAllocationAction</span>
05717     <span class="comment">//</span>
05718 
05719     } <span class="keywordflow">else</span> {
05720 
05721         <span class="comment">//</span>
05722         <span class="comment">//  Check if the supplied tag index is a regular tag and that it is</span>
05723         <span class="comment">//  valid for the tags in this heap</span>
05724         <span class="comment">//</span>
05725 
05726         <span class="keywordflow">if</span> ((TagIndex != 0) &amp;&amp;
05727             (TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05728             (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05729 
05730             TagEntry = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ];
05731 
05732         <span class="comment">//</span>
05733         <span class="comment">//  Otherwise if this is a global tag then make sure that it is a</span>
05734         <span class="comment">//  valid global index</span>
05735         <span class="comment">//</span>
05736 
05737         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex &amp; HEAP_GLOBAL_TAG) {
05738 
05739             TagIndex &amp;= ~HEAP_GLOBAL_TAG;
05740 
05741             Heap = <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>;
05742 
05743             <span class="keywordflow">if</span> ((TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05744                 (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05745 
05746                 TagEntry = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ];
05747 
05748                 TagIndex |= HEAP_GLOBAL_TAG;
05749 
05750             } <span class="keywordflow">else</span> {
05751 
05752                 <span class="keywordflow">return</span> 0;
05753             }
05754 
05755         <span class="comment">//</span>
05756         <span class="comment">//  Otherwise if this is a pseudo tag then build a valid tag index</span>
05757         <span class="comment">//  based on the new size of the allocation</span>
05758         <span class="comment">//</span>
05759 
05760         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05761 
05762             TagIndex = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(NewSize &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> ?
05763                                     NewSize :
05764                                     (<a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> == <a class="code" href="../../d9/d9/heappriv_8h.html#a60a28">VirtualAllocationAction</a> ? <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> : 0));
05765 
05766             TagEntry = (<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a>)(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> + TagIndex);
05767 
05768             TagIndex |= HEAP_PSEUDO_TAG_FLAG;
05769 
05770         <span class="comment">//</span>
05771         <span class="comment">//  Otherwise the user didn't call us with a valid tag</span>
05772         <span class="comment">//</span>
05773 
05774         } <span class="keywordflow">else</span> {
05775 
05776             <span class="keywordflow">return</span> 0;
05777         }
05778 
05779         <span class="comment">//</span>
05780         <span class="comment">//  At this point we have a valid tag entry and tag index, so</span>
05781         <span class="comment">//  update the tag entry state to reflect this new allocation</span>
05782         <span class="comment">//</span>
05783 
05784         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a> += 1;
05785 
05786         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> += NewSize;
05787     }
05788 
05789     <span class="comment">//</span>
05790     <span class="comment">//  And return to our caller with the new tag index</span>
05791     <span class="comment">//</span>
05792 
05793     <span class="keywordflow">return</span> TagIndex;
05794 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="heapdll.c::RtlQueryTagHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PWSTR RtlQueryTagHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d6/jul98_2test_2icc__i386_8h.html#a14">USHORT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>TagIndex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>ResetCounters</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PRTL_HEAP_TAG_INFO TagInfo&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01919">1919</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00303">_HEAP_TAG_ENTRY::Allocs</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00304">_HEAP_TAG_ENTRY::Frees</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00405">HEAP_NUMBER_OF_PSEUDO_TAG</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00337">_HEAP::NextAvailableTagIndex</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00365">_HEAP::PseudoTagEntries</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01498">RtlDebugQueryTagHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00305">_HEAP_TAG_ENTRY::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00339">_HEAP::TagEntries</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00308">_HEAP_TAG_ENTRY::TagName</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01498">RtlDebugQueryTagHeap()</a>.
<p>
<pre class="fragment"><div>01929                    :
01930 
01931     This routine returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name and optional statistics <span class="keywordflow">for</span> a given
01932     tag index.
01933 
01934 Arguments:
01935 
01936         **** note that some of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> code looks like <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> can handle <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01937         **** global tag heap but other places look rather wrong
01938 
01939     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being queried.  If null then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01940         global tag heap <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used.
01941 
01942     Flags - Supplies a set flags to augment those enforced by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01943         heap
01944 
01945     TagIndex - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag index that we want to query
01946 
01947     ResetCounter - Specifies <span class="keywordflow">if</span> <span class="keyword">this</span> routine should reset <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> counter
01948         <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag after <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> query
01949 
01950     TagInfo - Optionally supplies storage where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> output tag information
01951         should be stored
01952 
01953 Return Value:
01954 
01955     PWSTR - Returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> tag name or <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> index
01956         doesn'<a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> exist
01957 
01958 --*/
01959 
01960 {
01961     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01962     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01963     <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> TagEntry;
01964     PWSTR Result;
01965 
01966     <span class="comment">//</span>
01967     <span class="comment">//  Tagging is not part of the guard page heap package</span>
01968     <span class="comment">//</span>
01969 
01970     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle, NULL );
01971 
01972     <span class="comment">//</span>
01973     <span class="comment">//  Check if tagging is disabled</span>
01974     <span class="comment">//</span>
01975 
01976     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
01977 
01978         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01979     }
01980 
01981     <span class="keywordflow">try</span> {
01982 
01983         <span class="comment">//</span>
01984         <span class="comment">//  Check if the caller has given us a heap to query</span>
01985         <span class="comment">//</span>
01986 
01987         <span class="keywordflow">if</span> (Heap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01988 
01989             <span class="comment">//</span>
01990             <span class="comment">//  Check if we should be using the debug version of the</span>
01991             <span class="comment">//  heap package</span>
01992             <span class="comment">//</span>
01993 
01994             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
01995 
01996                 Result = <a class="code" href="../../d5/d9/heapdll_8c.html#a14">RtlDebugQueryTagHeap</a>( HeapHandle, Flags, TagIndex, ResetCounters, TagInfo );
01997                 leave;
01998             }
01999 
02000             <span class="comment">//</span>
02001             <span class="comment">//  Lock the heap</span>
02002             <span class="comment">//</span>
02003 
02004             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
02005 
02006             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
02007 
02008                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02009 
02010                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02011             }
02012         }
02013 
02014         Result = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02015 
02016         <span class="comment">//</span>
02017         <span class="comment">//  **** note that the next test assumes that heap is not null</span>
02018         <span class="comment">//</span>
02019         <span class="comment">//  Check that the specified tag index is valid and that the</span>
02020         <span class="comment">//  this heap does actually have some tag entries</span>
02021         <span class="comment">//</span>
02022 
02023         <span class="keywordflow">if</span> ((TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
02024             (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02025 
02026             <span class="comment">//</span>
02027             <span class="comment">//  Stride over to the specific tag entry and if the caller gave us</span>
02028             <span class="comment">//  an output buffer then fill in the details</span>
02029             <span class="comment">//</span>
02030 
02031             TagEntry = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> + TagIndex;
02032 
02033             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( TagInfo )) {
02034 
02035                 TagInfo-&gt;NumberOfAllocations = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a>;
02036                 TagInfo-&gt;NumberOfFrees = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a>;
02037                 TagInfo-&gt;BytesAllocated = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
02038             }
02039 
02040             <span class="comment">//</span>
02041             <span class="comment">//  Check if we should reset the counters</span>
02042             <span class="comment">//</span>
02043 
02044             <span class="keywordflow">if</span> (ResetCounters) {
02045 
02046                 TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a> = 0;
02047                 TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a> = 0;
02048                 TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> = 0;
02049             }
02050 
02051             <span class="comment">//</span>
02052             <span class="comment">//  Point to the tag name</span>
02053             <span class="comment">//</span>
02054 
02055             Result = &amp;TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>[ 0 ];
02056 
02057         <span class="comment">//</span>
02058         <span class="comment">//  If the tag index has the psuedo tag bit set then recalulate the</span>
02059         <span class="comment">//  tag index and if this heap has pseudo tags than that is what</span>
02060         <span class="comment">//  we'll return</span>
02061         <span class="comment">//</span>
02062 
02063         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex &amp; HEAP_PSEUDO_TAG_FLAG) {
02064 
02065             <span class="comment">//</span>
02066             <span class="comment">//  Clear the bit</span>
02067             <span class="comment">//</span>
02068 
02069             TagIndex ^= HEAP_PSEUDO_TAG_FLAG;
02070 
02071             <span class="keywordflow">if</span> ((TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a32">HEAP_NUMBER_OF_PSEUDO_TAG</a>) &amp;&amp;
02072                 (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02073 
02074                 <span class="comment">//</span>
02075                 <span class="comment">//  Stride over to the specific pseudo tag entry and if the</span>
02076                 <span class="comment">//  caller gave us an output buffer then fill in the details</span>
02077                 <span class="comment">//</span>
02078 
02079                 TagEntry = (<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a>)(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> + TagIndex);
02080 
02081                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( TagInfo )) {
02082 
02083                     TagInfo-&gt;NumberOfAllocations = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a>;
02084                     TagInfo-&gt;NumberOfFrees = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a>;
02085                     TagInfo-&gt;BytesAllocated = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
02086                 }
02087 
02088                 <span class="comment">//</span>
02089                 <span class="comment">//  Check if we should reset the counters</span>
02090                 <span class="comment">//</span>
02091 
02092                 <span class="keywordflow">if</span> (ResetCounters) {
02093 
02094                     TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a> = 0;
02095                     TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a> = 0;
02096                     TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> = 0;
02097                 }
02098 
02099                 <span class="comment">//</span>
02100                 <span class="comment">//  Pseudo tags do not have names</span>
02101                 <span class="comment">//</span>
02102 
02103                 Result = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">""</span>;
02104             }
02105         }
02106 
02107     } finally {
02108 
02109         <span class="comment">//</span>
02110         <span class="comment">//  Unlock the heap</span>
02111         <span class="comment">//</span>
02112 
02113         <span class="keywordflow">if</span> (LockAcquired) {
02114 
02115             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02116         }
02117     }
02118 
02119     <span class="comment">//</span>
02120     <span class="comment">//  And return the tag name to our caller</span>
02121     <span class="comment">//</span>
02122 
02123     <span class="keywordflow">return</span> Result;
02124 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="heapdll.c::RtlReAllocateHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID RtlReAllocateHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN SIZE_T&nbsp;</td>
          <td class="mdname" nowrap> <em>Size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00518">518</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00351">_HEAP::AlignMask</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00350">_HEAP::AlignRound</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00397">ALLOC_HEAP_FILL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00395">CHECK_HEAP_TAIL_FILL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00394">CHECK_HEAP_TAIL_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00162">_HEAP_VIRTUAL_ALLOC_ENTRY::CommitSize</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00056">EXCEPTION_CONTINUE_SEARCH</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00161">_HEAP_VIRTUAL_ALLOC_ENTRY::ExtraStuff</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00200">_HEAP_FREE_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00244">HEAP_ENTRY_SETTABLE_FLAGS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00239">HEAP_ENTRY_VIRTUAL_ALLOC</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00231">HEAP_MAXIMUM_BLOCK_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00401">HEAP_NEED_EXTRA_FLAGS</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00134">HeapDebugBreak</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00121">HeapDebugPrint</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00277">_HEAP_SEGMENT::LastEntryInSegment</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00182">_HEAP_FREE_ENTRY::PreviousSize</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00365">_HEAP::PseudoTagEntries</a>, <a class="el" href="../../d9/d9/heappriv_8h.html#a60a31">ReAllocationAction</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00030">ROUND_UP_TO_POWER2</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d4/d6/config_2utils_2regutil_8c-source.html#l00022">RtlAllocateHeap</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00603">RtlDebugReAllocateHeap()</a>, <a class="el" href="../../d4/d6/config_2utils_2regutil_8c-source.html#l00023">RtlFreeHeap</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06008">RtlpGetExtraStuffPointer()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06070">RtlpGetSizeOfBigBlock()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04693">RtlpGrowBlockInPlace()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l05849">RtlpInsertFreeBlock()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00322">RtlpInsertFreeBlockDirect</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00465">RtlpRemoveFreeBlock</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05554">RtlpUpdateTagEntry()</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00466">RtlRaiseException()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00060">_HEAP_ENTRY::SegmentIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00189">_HEAP_FREE_ENTRY::SegmentIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00355">_HEAP::Segments</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00128">_HEAP_ENTRY_EXTRA::Settable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00174">_HEAP_FREE_ENTRY::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00091">_HEAP_ENTRY::SmallTagIndex</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00121">_HEAP_ENTRY_EXTRA::TagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00331">_HEAP::TotalFreeSize</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00085">_HEAP_ENTRY::UnusedBytes</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>, and <a class="el" href="../../d9/d9/heappriv_8h.html#a60a32">VirtualReAllocationAction</a>.
<p>
Referenced by <a class="el" href="../../d3/d2/ldrsnap_8c-source.html#l03781">LdrpDphSnapImports()</a>, <a class="el" href="../../d2/d2/ldrrsrc_8c-source.html#l01492">LdrpSetAlternateResourceModuleHandle()</a>, <a class="el" href="../../d2/d2/ldrrsrc_8c-source.html#l01882">LdrUnloadAlternateResourceModule()</a>, <a class="el" href="../../d2/d0/theap_8c-source.html#l00077">main()</a>, and <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00603">RtlDebugReAllocateHeap()</a>.
<p>
<pre class="fragment"><div>00527                    :
00528 
00529     This routine will resize a user specified heap block.  The <span class="keyword">new</span> size
00530     can either be smaller or larger than <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current block size.
00531 
00532 Arguments:
00533 
00534     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified
00535 
00536     Flags - Supplies a set of heap flags to augment those already
00537         enforced by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
00538 
00539     BaseAddress - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current address of a block allocated
00540         from heap.  We will <span class="keywordflow">try</span> and resize <span class="keyword">this</span> block at its current
00541         address, but <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> could possibly <a class="code" href="../../d7/d4/conexts_8c.html#a1">move</a> <span class="keywordflow">if</span> <span class="keyword">this</span> heap structure
00542         allows <span class="keywordflow">for</span> relocation
00543 
00544     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size, in bytes, <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly resized heap
00545         block
00546 
00547 Return Value:
00548 
00549     PVOID - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> resized block.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> block had to <a class="code" href="../../d7/d4/conexts_8c.html#a1">move</a>
00550         then <span class="keyword">this</span> address will not be equal to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input base address
00551 
00552 --*/
00553 
00554 {
00555     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00556     SIZE_T AllocationSize;
00557     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock, NewBusyBlock;
00558     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> OldExtraStuff, NewExtraStuff;
00559     SIZE_T FreeSize;
00560     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00561     PVOID NewBaseAddress;
00562     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> SplitBlock, SplitBlock2;
00563     SIZE_T OldSize;
00564     SIZE_T AllocationIndex;
00565     SIZE_T OldAllocationIndex;
00566     UCHAR FreeFlags;
00567     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00568     PVOID DeCommitAddress;
00569     SIZE_T DeCommitSize;
00570     EXCEPTION_RECORD ExceptionRecord;
00571 
00572     <span class="comment">//</span>
00573     <span class="comment">//  If there isn't an address to relocate the heap at then our work is done</span>
00574     <span class="comment">//</span>
00575 
00576     <span class="keywordflow">if</span> (BaseAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00577 
00578         <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_SUCCESS );
00579 
00580         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00581     }
00582 
00583 <span class="preprocessor">#ifdef NTHEAP_ENABLED</span>
00584 <span class="preprocessor"></span>    {
00585         <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; NTHEAP_ENABLED_FLAG) {
00586 
00587             <span class="keywordflow">return</span> RtlReAllocateNtHeap( HeapHandle, Flags, BaseAddress, Size );
00588         }
00589     }
00590 <span class="preprocessor">#endif // NTHEAP_ENABLED</span>
00591 <span class="preprocessor"></span>
00592     <span class="comment">//</span>
00593     <span class="comment">//  Augment the heap flags</span>
00594     <span class="comment">//</span>
00595 
00596     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
00597 
00598     <span class="comment">//</span>
00599     <span class="comment">//  Check if we should simply call the debug version of heap to do the work</span>
00600     <span class="comment">//</span>
00601 
00602     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags)) {
00603 
00604         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a8">RtlDebugReAllocateHeap</a>( HeapHandle, Flags, BaseAddress, Size );
00605     }
00606 
00607     <span class="comment">//</span>
00608     <span class="comment">//  Make sure we didn't get a negative heap size</span>
00609     <span class="comment">//</span>
00610 
00611     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; 0x7fffffff) {
00612 
00613         <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_NO_MEMORY );
00614 
00615         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00616     }
00617 
00618     <span class="comment">//</span>
00619     <span class="comment">//  Round the requested size up to the allocation granularity.  Note</span>
00620     <span class="comment">//  that if the request is for 0 bytes, we still allocate memory, because</span>
00621     <span class="comment">//  we add in an extra byte to protect ourselves from idiots.</span>
00622     <span class="comment">//</span>
00623 
00624     AllocationSize = ((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> ? <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> : 1) + Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o19">AlignRound</a>) &amp; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o20">AlignMask</a>;
00625 
00626     <span class="keywordflow">if</span> ((Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a31">HEAP_NEED_EXTRA_FLAGS</a>) ||
00627         (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
00628         ((((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress)-1)-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>)) {
00629 
00630         AllocationSize += <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">HEAP_ENTRY_EXTRA</a> );
00631     }
00632 
00633     <span class="keywordflow">try</span> {
00634 
00635         <span class="comment">//</span>
00636         <span class="comment">//  Lock the heap</span>
00637         <span class="comment">//</span>
00638 
00639         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
00640 
00641             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00642 
00643             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00644 
00645             <span class="comment">//</span>
00646             <span class="comment">//  Because it is now zero the following statement will set the no</span>
00647             <span class="comment">//  serialize bit</span>
00648             <span class="comment">//</span>
00649 
00650             Flags ^= HEAP_NO_SERIALIZE;
00651         }
00652 
00653         <span class="keywordflow">try</span> {
00654 
00655             <span class="comment">//</span>
00656             <span class="comment">//  Compute the heap block address for user specified block</span>
00657             <span class="comment">//</span>
00658 
00659             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
00660 
00661             <span class="comment">//</span>
00662             <span class="comment">//  Check if the block is not in use then it is an error</span>
00663             <span class="comment">//</span>
00664 
00665             <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>)) {
00666 
00667                 <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
00668 
00669                 <span class="comment">//</span>
00670                 <span class="comment">//  Bail if not a busy block.</span>
00671                 <span class="comment">//</span>
00672 
00673                 leave;
00674 
00675             <span class="comment">//</span>
00676             <span class="comment">//  We need the current (i.e., old) size and allocation of the</span>
00677             <span class="comment">//  block.  Check if the block is a big allocation.  The size</span>
00678             <span class="comment">//  field of a big block is really the unused by count</span>
00679             <span class="comment">//</span>
00680 
00681             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
00682 
00683                 OldSize = <a class="code" href="../../d9/d9/heappriv_8h.html#a40">RtlpGetSizeOfBigBlock</a>( BusyBlock );
00684 
00685                 OldAllocationIndex = (OldSize + BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>) &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
00686 
00687                 <span class="comment">//</span>
00688                 <span class="comment">//  We'll need to adjust the new allocation size to account</span>
00689                 <span class="comment">//  for the big block header and then round it up to a page</span>
00690                 <span class="comment">//</span>
00691 
00692                 AllocationSize += FIELD_OFFSET( <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
00693                 AllocationSize = <a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( AllocationSize, PAGE_SIZE );
00694 
00695             <span class="comment">//</span>
00696             <span class="comment">//  Otherwise the block is in use and is a small allocation</span>
00697             <span class="comment">//</span>
00698 
00699             } <span class="keywordflow">else</span> {
00700 
00701                 OldAllocationIndex = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
00702 
00703                 OldSize = (OldAllocationIndex &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) -
00704                           BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a>;
00705             }
00706 
00707             <span class="comment">//</span>
00708             <span class="comment">//  Compute the new allocation index</span>
00709             <span class="comment">//</span>
00710 
00711             AllocationIndex = AllocationSize &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
00712 
00713             <span class="comment">//</span>
00714             <span class="comment">//  At this point we have the old size and index, and the new size</span>
00715             <span class="comment">//  and index</span>
00716             <span class="comment">//</span>
00717             <span class="comment">//  See if new size less than or equal to the current size.</span>
00718             <span class="comment">//</span>
00719 
00720             <span class="keywordflow">if</span> (AllocationIndex &lt;= OldAllocationIndex) {
00721 
00722                 <span class="comment">//</span>
00723                 <span class="comment">//  If the new allocation index is only one less then the current</span>
00724                 <span class="comment">//  index then make the sizes equal</span>
00725                 <span class="comment">//</span>
00726 
00727                 <span class="keywordflow">if</span> (AllocationIndex + 1 == OldAllocationIndex) {
00728 
00729                     AllocationIndex += 1;
00730                     AllocationSize += <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> );
00731                 }
00732 
00733                 <span class="comment">//</span>
00734                 <span class="comment">//  Calculate new residual (unused) amount</span>
00735                 <span class="comment">//</span>
00736 
00737                 <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
00738 
00739                     <span class="comment">//</span>
00740                     <span class="comment">//  In a big block the size is really the unused byte count</span>
00741                     <span class="comment">//</span>
00742 
00743                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
00744 
00745                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
00746 
00747                     <span class="comment">//</span>
00748                     <span class="comment">//  The extra stuff struct goes after the data.  So compute</span>
00749                     <span class="comment">//  the old and new extra stuff location and copy the data</span>
00750                     <span class="comment">//</span>
00751 
00752                     OldExtraStuff = (<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a>)(BusyBlock + BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> - 1);
00753 
00754                     NewExtraStuff = (<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a>)(BusyBlock + AllocationIndex - 1);
00755 
00756                     *NewExtraStuff = *OldExtraStuff;
00757 
00758                     <span class="comment">//</span>
00759                     <span class="comment">//  If we're doing heap tagging then update the tag entry</span>
00760                     <span class="comment">//</span>
00761 
00762                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
00763 
00764                         NewExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> =
00765                             <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
00766                                                 NewExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>,
00767                                                 OldAllocationIndex,
00768                                                 AllocationIndex,
00769                                                 ReAllocationAction );
00770                     }
00771 
00772                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a> = (UCHAR)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
00773 
00774                 } <span class="keywordflow">else</span> {
00775 
00776                     <span class="comment">//</span>
00777                     <span class="comment">//  If we're doing heap tagging then update the tag entry</span>
00778                     <span class="comment">//</span>
00779 
00780                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
00781 
00782                         BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a> = (UCHAR)
00783                             <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
00784                                                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a>,
00785                                                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>,
00786                                                 AllocationIndex,
00787                                                 ReAllocationAction );
00788                     }
00789 
00790                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a> = (UCHAR)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
00791                 }
00792 
00793                 <span class="comment">//</span>
00794                 <span class="comment">//  Check if the block is getting bigger, then fill in the extra</span>
00795                 <span class="comment">//  space.</span>
00796                 <span class="comment">//</span>
00797                 <span class="comment">//  **** how can this happen if the allocation index is less than or</span>
00798                 <span class="comment">//  **** equal to the old allocation index</span>
00799                 <span class="comment">//</span>
00800 
00801                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; OldSize) {
00802 
00803                     <span class="comment">//</span>
00804                     <span class="comment">//  See if we should zero the extra space</span>
00805                     <span class="comment">//</span>
00806 
00807                     <span class="keywordflow">if</span> (Flags &amp; HEAP_ZERO_MEMORY) {
00808 
00809                         RtlZeroMemory( (PCHAR)BaseAddress + OldSize,
00810                                        Size - OldSize );
00811 
00812                     <span class="comment">//</span>
00813                     <span class="comment">//  Otherwise see if we should fill the extra space</span>
00814                     <span class="comment">//</span>
00815 
00816                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_FREE_CHECKING_ENABLED) {
00817 
00818                         SIZE_T PartialBytes, ExtraSize;
00819 
00820                         PartialBytes = OldSize &amp; (<span class="keyword">sizeof</span>( ULONG ) - 1);
00821 
00822                         <span class="keywordflow">if</span> (PartialBytes) {
00823 
00824                             PartialBytes = 4 - PartialBytes;
00825                         }
00826 
00827                         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; (OldSize + PartialBytes)) {
00828 
00829                             ExtraSize = (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - (OldSize + PartialBytes)) &amp; ~(<span class="keyword">sizeof</span>( ULONG ) - 1);
00830 
00831                             <span class="keywordflow">if</span> (ExtraSize != 0) {
00832 
00833                                 RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
00834                                                     ExtraSize,
00835                                                     ALLOC_HEAP_FILL );
00836                             }
00837                         }
00838                     }
00839                 }
00840 
00841                 <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_TAIL_CHECKING_ENABLED) {
00842 
00843                     RtlFillMemory( (PCHAR)(BusyBlock + 1) + Size,
00844                                    CHECK_HEAP_TAIL_SIZE,
00845                                    CHECK_HEAP_TAIL_FILL );
00846                 }
00847 
00848                 <span class="comment">//</span>
00849                 <span class="comment">//  If amount of change is greater than the size of a free block,</span>
00850                 <span class="comment">//  then need to free the extra space.  Otherwise, nothing else to</span>
00851                 <span class="comment">//  do.</span>
00852                 <span class="comment">//</span>
00853 
00854                 <span class="keywordflow">if</span> (AllocationIndex != OldAllocationIndex) {
00855 
00856                     FreeFlags = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; ~<a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>;
00857 
00858                     <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
00859 
00860                         <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
00861 
00862                         VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
00863 
00864                         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
00865 
00866                             VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o1">ExtraStuff</a>.<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> =
00867                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
00868                                                     VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o1">ExtraStuff</a>.<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>,
00869                                                     OldAllocationIndex,
00870                                                     AllocationIndex,
00871                                                     VirtualReAllocationAction );
00872                         }
00873 
00874                         DeCommitAddress = (PCHAR)VirtualAllocBlock + AllocationSize;
00875 
00876                         DeCommitSize = (OldAllocationIndex &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) -
00877                                        AllocationSize;
00878 
00879                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwFreeVirtualMemory( NtCurrentProcess(),
00880                                                       (PVOID *)&amp;DeCommitAddress,
00881                                                       &amp;DeCommitSize,
00882                                                       MEM_RELEASE );
00883 
00884                         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00885 
00886                             <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Unable to release memory at %p for %p bytes - Status == %x\n"</span>,
00887                                              DeCommitAddress, DeCommitSize, Status ));
00888 
00889                             <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( NULL );
00890 
00891                         } <span class="keywordflow">else</span> {
00892 
00893                             VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a> -= DeCommitSize;
00894                         }
00895 
00896                     } <span class="keywordflow">else</span> {
00897 
00898                         <span class="comment">//</span>
00899                         <span class="comment">//  Otherwise, shrink size of this block to new size, and make extra</span>
00900                         <span class="comment">//  space at end free.</span>
00901                         <span class="comment">//</span>
00902 
00903                         SplitBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)(BusyBlock + AllocationIndex);
00904 
00905                         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = FreeFlags;
00906 
00907                         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
00908 
00909                         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a> = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a>;
00910 
00911                         FreeSize = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> - AllocationIndex;
00912 
00913                         BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
00914 
00915                         BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp;= ~<a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
00916 
00917                         <span class="comment">//</span>
00918                         <span class="comment">//  If the following block is uncommitted then we only need to</span>
00919                         <span class="comment">//  add this new entry to its free list</span>
00920                         <span class="comment">//</span>
00921 
00922                         <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
00923 
00924                             <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
00925 
00926                             Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
00927                             Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
00928 
00929                             SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
00930 
00931                             <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize );
00932 
00933                             Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
00934 
00935                         } <span class="keywordflow">else</span> {
00936 
00937                             <span class="comment">//</span>
00938                             <span class="comment">//  Otherwise get the next block and check if it is busy.  If it</span>
00939                             <span class="comment">//  is in use then add this new entry to its free list</span>
00940                             <span class="comment">//</span>
00941 
00942                             SplitBlock2 = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize);
00943 
00944                             <span class="keywordflow">if</span> (SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
00945 
00946                                 SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
00947 
00948                                 ((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize))-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
00949 
00950                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize );
00951 
00952                                 Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
00953 
00954                             } <span class="keywordflow">else</span> {
00955 
00956                                 <span class="comment">//</span>
00957                                 <span class="comment">//  Otherwise the next block is not in use so we</span>
00958                                 <span class="comment">//  should be able to merge with it.  Remove the</span>
00959                                 <span class="comment">//  second free block and if the combined size is</span>
00960                                 <span class="comment">//  still okay then merge the two blocks and add</span>
00961                                 <span class="comment">//  the single block back in.  Otherwise call a</span>
00962                                 <span class="comment">//  routine that will actually break it apart</span>
00963                                 <span class="comment">//  before insertion.</span>
00964                                 <span class="comment">//</span>
00965 
00966                                 SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
00967 
00968                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, SplitBlock2 );
00969 
00970                                 Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> -= SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
00971 
00972                                 FreeSize += SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
00973 
00974                                 <span class="keywordflow">if</span> (FreeSize &lt;= <a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>) {
00975 
00976                                     SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
00977 
00978                                     <span class="keywordflow">if</span> (!(SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
00979 
00980                                         ((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize))-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
00981 
00982                                     } <span class="keywordflow">else</span> {
00983 
00984                                         <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
00985 
00986                                         Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
00987                                         Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
00988                                     }
00989 
00990                                     <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (USHORT)FreeSize );
00991 
00992                                     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
00993 
00994                                 } <span class="keywordflow">else</span> {
00995 
00996                                     <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, SplitBlock, FreeSize );
00997                                 }
00998                             }
00999                         }
01000                     }
01001                 }
01002 
01003             } <span class="keywordflow">else</span> {
01004 
01005                 <span class="comment">//</span>
01006                 <span class="comment">//  At this point the new size is greater than the current size</span>
01007                 <span class="comment">//</span>
01008                 <span class="comment">//  If the block is a big allocation or we're not able to grow</span>
01009                 <span class="comment">//  the block in place then we have a lot of work to do</span>
01010                 <span class="comment">//</span>
01011 
01012                 <span class="keywordflow">if</span> ((BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) ||
01013                     !<a class="code" href="../../d5/d9/heapdll_8c.html#a7">RtlpGrowBlockInPlace</a>( Heap, Flags, BusyBlock, Size, AllocationIndex )) {
01014 
01015                     <span class="comment">//</span>
01016                     <span class="comment">//  We're growing the block.  Allocate a new block with the bigger</span>
01017                     <span class="comment">//  size, copy the contents of the old block to the new block and then</span>
01018                     <span class="comment">//  free the old block.  Return the address of the new block.</span>
01019                     <span class="comment">//</span>
01020 
01021                     <span class="keywordflow">if</span> (Flags &amp; HEAP_REALLOC_IN_PLACE_ONLY) {
01022 
01023 <span class="preprocessor">#if DBG</span>
01024 <span class="preprocessor"></span>                        <span class="comment">// HeapDebugPrint(( "Failing ReAlloc because cant do it inplace.\n" ));</span>
01025 <span class="preprocessor">#endif</span>
01026 <span class="preprocessor"></span>
01027                         BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01028 
01029                     } <span class="keywordflow">else</span> {
01030 
01031                         <span class="comment">//</span>
01032                         <span class="comment">//  Clear the tag bits from the flags</span>
01033                         <span class="comment">//</span>
01034 
01035                         Flags &amp;= ~HEAP_TAG_MASK;
01036 
01037                         <span class="comment">//</span>
01038                         <span class="comment">//  If there is an extra struct present then get the tag</span>
01039                         <span class="comment">//  index from the extra stuff and augment the flags with</span>
01040                         <span class="comment">//  the tag index.</span>
01041                         <span class="comment">//</span>
01042 
01043                         <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
01044 
01045                             Flags &amp;= ~HEAP_SETTABLE_USER_FLAGS;
01046 
01047                             Flags |= HEAP_SETTABLE_USER_VALUE |
01048                                      ((BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a16">HEAP_ENTRY_SETTABLE_FLAGS</a>) &lt;&lt; 4);
01049 
01050                             OldExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
01051 
01052                             <span class="keywordflow">try</span> {
01053 
01054                                 <span class="keywordflow">if</span> ((OldExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> != 0) &amp;&amp;
01055                                     !(OldExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> &amp; HEAP_PSEUDO_TAG_FLAG)) {
01056 
01057                                     Flags |= OldExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> &lt;&lt; HEAP_TAG_SHIFT;
01058                                 }
01059 
01060                             } except (EXCEPTION_EXECUTE_HANDLER) {
01061 
01062                                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp;= ~<a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>;
01063                             }
01064 
01065                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a> != 0) {
01066 
01067                             <span class="comment">//</span>
01068                             <span class="comment">//  There is not an extra stuff struct, but block</span>
01069                             <span class="comment">//  does have a small tag index so now add this small</span>
01070                             <span class="comment">//  tag to the flags</span>
01071                             <span class="comment">//</span>
01072 
01073                             Flags |= BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a> &lt;&lt; HEAP_TAG_SHIFT;
01074                         }
01075 
01076                         <span class="comment">//</span>
01077                         <span class="comment">//  Allocate from the heap space for the reallocation</span>
01078                         <span class="comment">//</span>
01079 
01080                         NewBaseAddress = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( HeapHandle,
01081                                                           Flags &amp; ~HEAP_ZERO_MEMORY,
01082                                                           Size );
01083 
01084                         <span class="keywordflow">if</span> (NewBaseAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01085 
01086                             <span class="comment">//</span>
01087                             <span class="comment">//  We were able to get the allocation so now back up</span>
01088                             <span class="comment">//  to the heap block and if the block has an extra</span>
01089                             <span class="comment">//  stuff struct then copy over the extra stuff</span>
01090                             <span class="comment">//</span>
01091 
01092                             NewBusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)NewBaseAddress - 1;
01093 
01094                             <span class="keywordflow">if</span> (NewBusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
01095 
01096                                 NewExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( NewBusyBlock );
01097 
01098                                 <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
01099 
01100                                     OldExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
01101 
01102                                     NewExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o2">Settable</a> = OldExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o2">Settable</a>;
01103 
01104                                 } <span class="keywordflow">else</span> {
01105 
01106                                     RtlZeroMemory( NewExtraStuff, <span class="keyword">sizeof</span>( *NewExtraStuff ));
01107                                 }
01108                             }
01109 
01110                             <span class="comment">//</span>
01111                             <span class="comment">//  Copy over the user's data area to the new block</span>
01112                             <span class="comment">//</span>
01113 
01114                             RtlMoveMemory( NewBaseAddress, BaseAddress, Size &lt; OldSize ? Size : OldSize );
01115 
01116                             <span class="comment">//</span>
01117                             <span class="comment">//  Check if we grew the block and we should zero</span>
01118                             <span class="comment">//  the remaining part.</span>
01119                             <span class="comment">//</span>
01120                             <span class="comment">//  **** is this first test always true because we're</span>
01121                             <span class="comment">//  **** in the part that grows blocks</span>
01122                             <span class="comment">//</span>
01123 
01124                             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; OldSize &amp;&amp; (Flags &amp; HEAP_ZERO_MEMORY)) {
01125 
01126                                 RtlZeroMemory( (PCHAR)NewBaseAddress + OldSize,
01127                                                Size - OldSize );
01128                             }
01129 
01130                             <span class="comment">//</span>
01131                             <span class="comment">//  Release the old block</span>
01132                             <span class="comment">//</span>
01133 
01134                             <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( HeapHandle,
01135                                          Flags,
01136                                          BaseAddress );
01137                         }
01138 
01139                         BaseAddress = NewBaseAddress;
01140                     }
01141                 }
01142             }
01143 
01144             <span class="keywordflow">if</span> ((BaseAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (Flags &amp; HEAP_GENERATE_EXCEPTIONS)) {
01145 
01146                 <span class="comment">//</span>
01147                 <span class="comment">//  Construct an exception record.</span>
01148                 <span class="comment">//</span>
01149 
01150                 ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
01151                 ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01152                 ExceptionRecord.NumberParameters = 1;
01153                 ExceptionRecord.ExceptionFlags = 0;
01154                 ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;
01155 
01156                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a>( &amp;ExceptionRecord );
01157             }
01158 
01159         } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
01160                                                            EXCEPTION_EXECUTE_HANDLER ) {
01161 
01162             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01163             BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01164 
01165         }
01166 
01167     } finally {
01168 
01169         <span class="comment">//</span>
01170         <span class="comment">//  Unlock the heap</span>
01171         <span class="comment">//</span>
01172 
01173         <span class="keywordflow">if</span> (LockAcquired) {
01174 
01175             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01176         }
01177     }
01178 
01179     <span class="comment">//</span>
01180     <span class="comment">//  And return to our caller</span>
01181     <span class="comment">//</span>
01182 
01183     <span class="keywordflow">return</span> BaseAddress;
01184 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="heapdll.c::RtlSetUserFlagsHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlSetUserFlagsHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>UserFlagsReset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>UserFlagsSet</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01480">1480</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01086">RtlDebugSetUserFlagsHeap()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01086">RtlDebugSetUserFlagsHeap()</a>, and <a class="el" href="../../d7/d8/heappage_8c-source.html#l04664">RtlpDphNormalHeapSetUserFlags()</a>.
<p>
<pre class="fragment"><div>01490                    :
01491 
01492     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified
01493 
01494     Flags - Supplies a set of flags needed to augment those already enforced
01495         by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
01496 
01497     BaseAddress - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap entry allocation being
01498         modified
01499 
01500     UserFlagsReset - Supplies a mask of flags that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user wants cleared
01501 
01502     UserFlagsSet- Supplies a mask of flags that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user wants set
01503 
01504 Return Value:
01505 
01506     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a success and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise
01507 
01508 --*/
01509 
01510 {
01511     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01512     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
01513     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01514     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01515 
01516     <span class="comment">//</span>
01517     <span class="comment">//  Augment the set of flags</span>
01518     <span class="comment">//</span>
01519 
01520     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
01521 
01522     <span class="comment">//</span>
01523     <span class="comment">//  Check to see if we should be going the debug route</span>
01524     <span class="comment">//</span>
01525 
01526     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
01527 
01528         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a11">RtlDebugSetUserFlagsHeap</a>( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet );
01529     }
01530 
01531     <span class="keywordflow">try</span> {
01532 
01533         <span class="comment">//</span>
01534         <span class="comment">//  Lock the heap</span>
01535         <span class="comment">//</span>
01536 
01537         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01538 
01539             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01540 
01541             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01542         }
01543 
01544         <span class="keywordflow">try</span> {
01545 
01546             <span class="comment">//</span>
01547             <span class="comment">//  Get a pointer to the owning heap entry</span>
01548             <span class="comment">//</span>
01549 
01550             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
01551 
01552             <span class="comment">//</span>
01553             <span class="comment">//  If the entry is not in use then it is an error</span>
01554             <span class="comment">//</span>
01555 
01556             <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>)) {
01557 
01558                 <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
01559 
01560             } <span class="keywordflow">else</span> {
01561 
01562                 <span class="comment">//</span>
01563                 <span class="comment">//  Otherwise modify the flags in the block</span>
01564                 <span class="comment">//</span>
01565                 <span class="comment">//  **** this is terrible error prone if the user passes in</span>
01566                 <span class="comment">//  **** flags that aren't 0x200 0x400 or 0x800 only.</span>
01567                 <span class="comment">//</span>
01568 
01569                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp;= ~(UserFlagsReset &gt;&gt; 4);
01570                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> |= (UserFlagsSet &gt;&gt; 4);
01571 
01572                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01573             }
01574 
01575         } except( EXCEPTION_EXECUTE_HANDLER ) {
01576 
01577             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01578 
01579             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01580         }
01581 
01582     } finally {
01583 
01584         <span class="comment">//</span>
01585         <span class="comment">//  Unlock the heap</span>
01586         <span class="comment">//</span>
01587 
01588         <span class="keywordflow">if</span> (LockAcquired) {
01589 
01590             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01591         }
01592     }
01593 
01594     <span class="keywordflow">return</span> Result;
01595 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="heapdll.c::RtlSetUserValueHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlSetUserValueHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>UserValue</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01356">1356</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01002">RtlDebugSetUserValueHeap()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06008">RtlpGetExtraStuffPointer()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00128">_HEAP_ENTRY_EXTRA::Settable</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01002">RtlDebugSetUserValueHeap()</a>, and <a class="el" href="../../d7/d8/heappage_8c-source.html#l04694">RtlpDphNormalHeapSetUserValue()</a>.
<p>
<pre class="fragment"><div>01365                    :
01366 
01367     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to set <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user settable value <span class="keywordflow">for</span> a heap entry
01368 
01369 Arguments:
01370 
01371     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being modified
01372 
01373     Flags - Supplies a set of flags needed to augment those already enforced
01374         by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
01375 
01376     BaseAddress - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap entry allocation being
01377         modified
01378 
01379     UserValue - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> value to store in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> extra stuff space of
01380         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap entry
01381 
01382 Return Value:
01383 
01384     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> setting worked, and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise.  It could be
01385         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> base address <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invalid, or <span class="keywordflow">if</span> there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not room <span class="keywordflow">for</span>
01386         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> extra stuff
01387 
01388 --*/
01389 
01390 {
01391     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01392     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
01393     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
01394     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01395     BOOLEAN Result;
01396 
01397     <span class="comment">//</span>
01398     <span class="comment">//  Augment the set of flags</span>
01399     <span class="comment">//</span>
01400 
01401     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
01402 
01403     <span class="comment">//</span>
01404     <span class="comment">//  Check to see if we should be going the debug route</span>
01405     <span class="comment">//</span>
01406 
01407     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
01408 
01409         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a10">RtlDebugSetUserValueHeap</a>( HeapHandle, Flags, BaseAddress, UserValue );
01410     }
01411 
01412     Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01413 
01414     <span class="keywordflow">try</span> {
01415 
01416         <span class="comment">//</span>
01417         <span class="comment">//  Lock the heap</span>
01418         <span class="comment">//</span>
01419 
01420         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01421 
01422             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01423 
01424             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01425         }
01426 
01427         <span class="comment">//</span>
01428         <span class="comment">//  Get a pointer to the owning heap entry</span>
01429         <span class="comment">//</span>
01430 
01431         BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
01432 
01433         <span class="comment">//</span>
01434         <span class="comment">//  If the entry is not in use then its is an error</span>
01435         <span class="comment">//</span>
01436 
01437         <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>)) {
01438 
01439             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
01440 
01441         <span class="comment">//</span>
01442         <span class="comment">//  Otherwise we only can set the value if the entry has space</span>
01443         <span class="comment">//  for the extra stuff</span>
01444         <span class="comment">//</span>
01445 
01446         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
01447 
01448             ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
01449 
01450             ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o2">Settable</a> = (ULONG_PTR)UserValue;
01451 
01452             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01453         }
01454 
01455     } finally {
01456 
01457         <span class="comment">//</span>
01458         <span class="comment">//  Unlock the heap</span>
01459         <span class="comment">//</span>
01460 
01461         <span class="keywordflow">if</span> (LockAcquired) {
01462 
01463             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01464         }
01465     }
01466 
01467     <span class="comment">//</span>
01468     <span class="comment">//  And return to our caller</span>
01469     <span class="comment">//</span>
01470 
01471     <span class="keywordflow">return</span> Result;
01472 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="heapdll.c::RtlUnlockHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlUnlockHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>HeapHandle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00454">454</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00383">_HEAP::LookasideLockCount</a>, <a class="el" href="../../d6/d8/ntrtlp_8h-source.html#l00246">RTL_PAGED_CODE</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03613">RtlpDebugPageHeapUnlock()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>00460                    :
00461 
00462     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to unlock access to a specific heap structure
00463 
00464 Arguments:
00465 
00466     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heep being unlocked
00467 
00468 Return Value:
00469 
00470     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> now unlocked and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise (i.e.,
00471         the heap is ill-formed).  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> also returned <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap was
00472         never locked to begin with because <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not seralizable.
00473 
00474 --*/
00475 
00476 {
00477     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00478 
00479     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00480 
00481     <span class="comment">//</span>
00482     <span class="comment">//  Check for the heap protected by guard pages</span>
00483     <span class="comment">//</span>
00484 
00485     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
00486                                     <a class="code" href="../../d7/d9/heappage_8h.html#a20">RtlpDebugPageHeapUnlock</a>( HeapHandle ));
00487 
00488     <span class="comment">//</span>
00489     <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
00490     <span class="comment">//</span>
00491 
00492     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlUnlockHeap"</span> )) {
00493 
00494         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00495     }
00496 
00497     <span class="comment">//</span>
00498     <span class="comment">//  Unlock the heap.  And enable the lookaside logic by decrementing</span>
00499     <span class="comment">//  its lock count</span>
00500     <span class="comment">//</span>
00501 
00502     <span class="keywordflow">if</span> (!(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_NO_SERIALIZE)) {
00503 
00504         Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o34">LookasideLockCount</a> -= 1;
00505 
00506         <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00507     }
00508 
00509     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00510 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="heapdll.c::RtlUsageHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS RtlUsageHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PRTL_HEAP_USAGE&nbsp;</td>
          <td class="mdname" nowrap> <em>Usage</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02976">2976</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00254">_HEAP_UNCOMMMTTED_RANGE::Address</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00113">_HEAP_ENTRY_EXTRA::AllocatorBackTraceIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00267">_HEAP_SEGMENT::BaseAddress</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00164">_HEAP_VIRTUAL_ALLOC_ENTRY::BusyBlock</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00162">_HEAP_VIRTUAL_ALLOC_ENTRY::CommitSize</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00260">_HEAP_SEGMENT::Entry</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00319">_HEAP::Entry</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00161">_HEAP_VIRTUAL_ALLOC_ENTRY::ExtraStuff</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00234">HEAP_MAXIMUM_SEGMENTS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00270">_HEAP_SEGMENT::LastValidEntry</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00253">_HEAP_UNCOMMMTTED_RANGE::Next</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d4/d5/allocvm_8c-source.html#l00075">NtAllocateVirtualMemory()</a>, <a class="el" href="../../d4/d6/freevm_8c-source.html#l00066">NtFreeVirtualMemory()</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00268">_HEAP_SEGMENT::NumberOfPages</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00272">_HEAP_SEGMENT::NumberOfUnCommittedPages</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d5/d9/heapdll_8c.html#a2">PRTL_HEAP_USAGE_INTERNAL</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01572">RtlDebugUsageHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05954">RtlpAllocateHeapUsageEntry()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l06092">RtlpFreeHeapUsageEntry()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06008">RtlpGetExtraStuffPointer()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00326">_HEAP::SegmentReserve</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00355">_HEAP::Segments</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00255">_HEAP_UNCOMMMTTED_RANGE::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00091">_HEAP_ENTRY::SmallTagIndex</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00121">_HEAP_ENTRY_EXTRA::TagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00331">_HEAP::TotalFreeSize</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00274">_HEAP_SEGMENT::UnCommittedRanges</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00085">_HEAP_ENTRY::UnusedBytes</a>, <a class="el" href="../../d2/d0/hivedmp_8c-source.html#l00066">Usage()</a>, and <a class="el" href="../../d4/d8/heap_8h-source.html#l00353">_HEAP::VirtualAllocdBlocks</a>.
<p>
Referenced by <a class="el" href="../../d2/d0/theap_8c-source.html#l00077">main()</a>, and <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01572">RtlDebugUsageHeap()</a>.
<p>
<pre class="fragment"><div>02984                    :
02985 
02986     This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a rather bizzare routine.  It models heap usage in that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> returns
02987     to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> various heap sizes, but <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> also <span class="keywordflow">return</span> three lists.  One
02988     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a list of entries <span class="keywordflow">for</span> each active allocation in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap.  The next two
02989     are used <span class="keywordflow">for</span> tracking difference between usage calls.  There <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a list of
02990     what was added and a list of what was removed.
02991 
02992 Arguments:
02993 
02994     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being queried
02995 
02996     Flags - Supplies a set of flags needed to augment those enforced
02997         by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap.
02998 
02999         HEAP_USAGE_ALLOCATED_BLOCKS - Denotes that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> calls wants <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list
03000             of allocated entries.
03001 
03002         HEAP_USAGE_FREE_BUFFER - Denotes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last call to <span class="keyword">this</span> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> and
03003             that any temporary storage can now be freed
03004 
03005     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a> - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current usage statistics <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap.  This variable
03006         <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> also used to store state information between calls to <span class="keyword">this</span> routine.
03007 
03008 Return Value:
03009 
03010     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - An appropriate status value.  STATUS_SUCCESS <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap has
03011         not changed at all between calls and STATUS_MORE_ENTRIES <span class="keywordflow">if</span> thep changed
03012         between two calls.
03013 
03014 --*/
03015 
03016 {
03017     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03018     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
03019     <a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">PRTL_HEAP_USAGE_INTERNAL</a> <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
03020     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
03021     <a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> UnCommittedRange;
03022     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> CurrentBlock;
03023     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
03024     PLIST_ENTRY Head, Next;
03025     <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
03026     SIZE_T BytesFree;
03027     UCHAR SegmentIndex;
03028     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03029     BOOLEAN VirtualAllocBlockSeen;
03030     PRTL_HEAP_USAGE_ENTRY pOldEntries, pNewEntries, pNewEntry;
03031     PRTL_HEAP_USAGE_ENTRY *ppEntries, *ppAddedEntries, *ppRemovedEntries, *pp;
03032     PVOID DataAddress;
03033     SIZE_T DataSize;
03034 
03035     <span class="comment">//</span>
03036     <span class="comment">//  Augment the heap flags</span>
03037     <span class="comment">//</span>
03038 
03039     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
03040 
03041     <span class="comment">//</span>
03042     <span class="comment">//  Check if we should be using the debug version of heap</span>
03043     <span class="comment">//</span>
03044 
03045     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
03046 
03047         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a15">RtlDebugUsageHeap</a>( HeapHandle, Flags, Usage );
03048     }
03049 
03050     <span class="comment">//</span>
03051     <span class="comment">//  Make sure that the size of the input buffer is correct</span>
03052     <span class="comment">//</span>
03053 
03054     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;Length != <span class="keyword">sizeof</span>( RTL_HEAP_USAGE )) {
03055 
03056         <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
03057     }
03058 
03059     <span class="comment">//</span>
03060     <span class="comment">//  Zero out the output fields</span>
03061     <span class="comment">//</span>
03062 
03063     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesAllocated = 0;
03064     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesCommitted = 0;
03065     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReserved = 0;
03066     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReservedMaximum = 0;
03067 
03068     <span class="comment">//</span>
03069     <span class="comment">//  Use the reserved area of the output buffer as an internal</span>
03070     <span class="comment">//  heap usage storage space between calls</span>
03071     <span class="comment">//</span>
03072 
03073     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (<a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">PRTL_HEAP_USAGE_INTERNAL</a>)&amp;<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;Reserved[ 0 ];
03074 
03075     <span class="comment">//</span>
03076     <span class="comment">//  Check if there is not a base buffer and we should allocate</span>
03077     <span class="comment">//  one then do so now</span>
03078     <span class="comment">//</span>
03079 
03080     <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03081         (Flags &amp; HEAP_USAGE_ALLOCATED_BLOCKS)) {
03082 
03083         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;ReservedSize = 4 * 1024 * 1024;
03084 
03085         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d6/allocvm_8c.html#a7">NtAllocateVirtualMemory</a>( NtCurrentProcess(),
03086                                           &amp;<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base,
03087                                           0,
03088                                           &amp;<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;ReservedSize,
03089                                           MEM_RESERVE,
03090                                           PAGE_READWRITE );
03091 
03092         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03093 
03094             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03095         }
03096 
03097         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;CommittedSize = 0;
03098         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03099         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;LargeEntriesSentinal = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03100 
03101     <span class="comment">//</span>
03102     <span class="comment">//  Otherwise check if there already is a base buffer</span>
03103     <span class="comment">//  and we should free it now</span>
03104     <span class="comment">//</span>
03105 
03106     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03107                (Flags &amp; HEAP_USAGE_FREE_BUFFER)) {
03108 
03109         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;ReservedSize = 0;
03110 
03111         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d7/freevm_8c.html#a6">NtFreeVirtualMemory</a>( NtCurrentProcess(),
03112                                       &amp;<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base,
03113                                       &amp;<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;ReservedSize,
03114                                       MEM_RELEASE );
03115 
03116         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03117 
03118             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03119         }
03120 
03121         RtlZeroMemory( Buffer, <span class="keyword">sizeof</span>( *Buffer ) );
03122     }
03123 
03124     <span class="comment">//</span>
03125     <span class="comment">//  **** Augment the heap flags again</span>
03126     <span class="comment">//</span>
03127 
03128     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
03129 
03130     <span class="keywordflow">try</span> {
03131 
03132         <span class="comment">//</span>
03133         <span class="comment">//  Lock the heap</span>
03134         <span class="comment">//</span>
03135 
03136         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
03137 
03138             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
03139 
03140             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03141         }
03142 
03143         <span class="comment">//</span>
03144         <span class="comment">//  Scan through the heap segments and for every in-use segment</span>
03145         <span class="comment">//  we add it to the amount of committed and reserved bytes</span>
03146         <span class="comment">//  If the segment is not in use and the heap is growable then</span>
03147         <span class="comment">//  we just add it to the reserved maximum</span>
03148         <span class="comment">//</span>
03149 
03150         <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
03151 
03152             Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
03153 
03154             <span class="keywordflow">if</span> (Segment) {
03155 
03156                 <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesCommitted += (Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o6">NumberOfPages</a> -
03157                                           Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o9">NumberOfUnCommittedPages</a>) * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03158 
03159                 <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReserved += Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o6">NumberOfPages</a> * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03160 
03161             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_GROWABLE) {
03162 
03163                 <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReservedMaximum += Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o5">SegmentReserve</a>;
03164             }
03165         }
03166 
03167         <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReservedMaximum += <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReserved;
03168         <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesAllocated = <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesCommitted - (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>);
03169 
03170         <span class="comment">//</span>
03171         <span class="comment">//  Scan through the big allocations and add those amounts to the</span>
03172         <span class="comment">//  usage statistics</span>
03173         <span class="comment">//</span>
03174 
03175         Head = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o21">VirtualAllocdBlocks</a>;
03176         Next = Head-&gt;Flink;
03177 
03178         <span class="keywordflow">while</span> (Head != Next) {
03179 
03180             VirtualAllocBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, Entry );
03181 
03182             <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesAllocated += VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a>;
03183             <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesCommitted += VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a>;
03184 
03185             Next = Next-&gt;Flink;
03186         }
03187 
03188         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
03189 
03190         <span class="comment">//</span>
03191         <span class="comment">//  Now check if we have a base buffer and we are suppose to account</span>
03192         <span class="comment">//  for allocated blocks</span>
03193         <span class="comment">//</span>
03194 
03195         <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03196             (Flags &amp; HEAP_USAGE_ALLOCATED_BLOCKS)) {
03197 
03198             <span class="comment">//</span>
03199             <span class="comment">//  Setup a pointer to the old entries, added entries, and removed</span>
03200             <span class="comment">//  entries in the usage struct.  Also drain the added entries</span>
03201             <span class="comment">//  and removed entries list</span>
03202             <span class="comment">//</span>
03203 
03204             pOldEntries = <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;Entries;
03205 
03206             ppEntries = &amp;<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;Entries;
03207 
03208             *ppEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03209 
03210             ppAddedEntries = &amp;<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;AddedEntries;
03211 
03212             <span class="keywordflow">while</span> (*ppAddedEntries = <a class="code" href="../../d5/d9/heapdll_8c.html#a18">RtlpFreeHeapUsageEntry</a>( Buffer, *ppAddedEntries )) { NOTHING; }
03213 
03214             ppRemovedEntries = &amp;<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;RemovedEntries;
03215 
03216             <span class="keywordflow">while</span> (*ppRemovedEntries = <a class="code" href="../../d5/d9/heapdll_8c.html#a18">RtlpFreeHeapUsageEntry</a>( Buffer, *ppRemovedEntries )) { NOTHING; }
03217 
03218             <span class="comment">//</span>
03219             <span class="comment">//  The way the code works is that ppEntries, ppAddedEntries, and</span>
03220             <span class="comment">//  ppRemovedEntries point to the tail of their respective lists.  If</span>
03221             <span class="comment">//  the list is empty then they point to the head.</span>
03222             <span class="comment">//</span>
03223 
03224             <span class="comment">//</span>
03225             <span class="comment">//  Process every segment in the heap</span>
03226             <span class="comment">//</span>
03227 
03228             <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
03229 
03230                 Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
03231 
03232                 <span class="comment">//</span>
03233                 <span class="comment">//  Only deal with segments that are in use</span>
03234                 <span class="comment">//</span>
03235 
03236                 <span class="keywordflow">if</span> (Segment) {
03237 
03238                     <span class="comment">//</span>
03239                     <span class="comment">//  The current block is really the first block in current</span>
03240                     <span class="comment">//  segment.  We need to special case the computation to</span>
03241                     <span class="comment">//  account for the first heap segment.</span>
03242                     <span class="comment">//</span>
03243 
03244                     <span class="keywordflow">if</span> (Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o5">BaseAddress</a> == Heap) {
03245 
03246                         CurrentBlock = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o0">Entry</a>;
03247 
03248                     } <span class="keywordflow">else</span> {
03249 
03250                         CurrentBlock = &amp;Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o0">Entry</a>;
03251                     }
03252 
03253                     <span class="comment">//</span>
03254                     <span class="comment">//  Now for every busy block in the segment we'll check if</span>
03255                     <span class="comment">//  we need to allocate a heap usage entry and put it in the</span>
03256                     <span class="comment">//  the entries list</span>
03257                     <span class="comment">//</span>
03258 
03259                     <span class="keywordflow">while</span> (CurrentBlock &lt; Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>) {
03260 
03261                         <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
03262 
03263                             <span class="comment">//</span>
03264                             <span class="comment">//  Compute the users data address and size</span>
03265                             <span class="comment">//</span>
03266 
03267                             DataAddress = (CurrentBlock+1);
03268                             DataSize = (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) -
03269                                        CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a>;
03270 
03271     keepLookingAtOldEntries:
03272 
03273                             <span class="comment">//</span>
03274                             <span class="comment">//  The first time through this routine will have</span>
03275                             <span class="comment">//  both of these variables null so we'll start off</span>
03276                             <span class="comment">//  by looking at new entries.</span>
03277                             <span class="comment">//</span>
03278 
03279                             <span class="keywordflow">if</span> (pOldEntries == <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;LargeEntriesSentinal) {
03280 
03281                                 <span class="keywordflow">goto</span> keepLookingAtNewEntries;
03282                             }
03283 
03284                             <span class="comment">//</span>
03285                             <span class="comment">//  Check if this entry hasn't changed.</span>
03286                             <span class="comment">//</span>
03287                             <span class="comment">//  If the old entry is equal to this data block</span>
03288                             <span class="comment">//  then move the old entry back to the entries</span>
03289                             <span class="comment">//  list and go on to the next block.</span>
03290                             <span class="comment">//</span>
03291 
03292                             <span class="keywordflow">if</span> ((pOldEntries-&gt;Address == DataAddress) &amp;&amp;
03293                                 (pOldEntries-&gt;Size == DataSize)) {
03294 
03295                                 <span class="comment">//</span>
03296                                 <span class="comment">//  Same block, keep in entries list</span>
03297                                 <span class="comment">//</span>
03298 
03299                                 *ppEntries = pOldEntries;
03300                                 pOldEntries = pOldEntries-&gt;Next;
03301                                 ppEntries = &amp;(*ppEntries)-&gt;Next;
03302 
03303                                 *ppEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03304 
03305                             <span class="comment">//</span>
03306                             <span class="comment">//  Check if an entry was removed</span>
03307                             <span class="comment">//</span>
03308                             <span class="comment">//  If this entry is beyond the old entry then move</span>
03309                             <span class="comment">//  the old entry to the removed entry list and keep</span>
03310                             <span class="comment">//  looking at the old entry list without advancing</span>
03311                             <span class="comment">//  the current data block</span>
03312                             <span class="comment">//</span>
03313 
03314                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pOldEntries-&gt;Address &lt;= DataAddress) {
03315 
03316                                 *ppRemovedEntries = pOldEntries;
03317                                 pOldEntries = pOldEntries-&gt;Next;
03318                                 ppRemovedEntries = &amp;(*ppRemovedEntries)-&gt;Next;
03319 
03320                                 *ppRemovedEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03321 
03322                                 <span class="keywordflow">goto</span> keepLookingAtOldEntries;
03323 
03324                             <span class="comment">//</span>
03325                             <span class="comment">//  Otherwise the we want to process the current data block</span>
03326                             <span class="comment">//</span>
03327 
03328                             } <span class="keywordflow">else</span> {
03329 
03330     keepLookingAtNewEntries:
03331 
03332                                 <span class="comment">//</span>
03333                                 <span class="comment">//  Allocate a new heap usage entry</span>
03334                                 <span class="comment">//</span>
03335 
03336                                 pNewEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03337 
03338                                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d9/heapdll_8c.html#a19">RtlpAllocateHeapUsageEntry</a>( Buffer, &amp;pNewEntry );
03339 
03340                                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03341 
03342                                     <span class="keywordflow">break</span>;
03343                                 }
03344 
03345                                 <span class="comment">//</span>
03346                                 <span class="comment">//  And fill in the new entry</span>
03347                                 <span class="comment">//</span>
03348 
03349                                 pNewEntry-&gt;Address = DataAddress;
03350                                 pNewEntry-&gt;Size = DataSize;
03351 
03352                                 <span class="comment">//</span>
03353                                 <span class="comment">//  If there is an extra stuff struct then fill it in</span>
03354                                 <span class="comment">//  with the stack backtrace, and appropriate tag index</span>
03355                                 <span class="comment">//</span>
03356 
03357                                 <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
03358 
03359                                     ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( CurrentBlock );
03360 
03361 <span class="preprocessor">    #if i386</span>
03362 <span class="preprocessor"></span>
03363                                     pNewEntry-&gt;AllocatorBackTraceIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o0">AllocatorBackTraceIndex</a>;
03364 
03365 <span class="preprocessor">    #endif // i386</span>
03366 <span class="preprocessor"></span>
03367                                     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
03368 
03369                                         pNewEntry-&gt;TagIndex = 0;
03370 
03371                                     } <span class="keywordflow">else</span> {
03372 
03373                                         pNewEntry-&gt;TagIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>;
03374                                     }
03375 
03376                                 } <span class="keywordflow">else</span> {
03377 
03378                                     <span class="comment">//</span>
03379                                     <span class="comment">//  Otherwise there is no extra stuff so there is</span>
03380                                     <span class="comment">//  no backtrace and the tag is from the small index</span>
03381                                     <span class="comment">//</span>
03382 
03383 <span class="preprocessor">    #if i386</span>
03384 <span class="preprocessor"></span>
03385                                     pNewEntry-&gt;AllocatorBackTraceIndex = 0;
03386 
03387 <span class="preprocessor">    #endif // i386</span>
03388 <span class="preprocessor"></span>
03389                                     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
03390 
03391                                         pNewEntry-&gt;TagIndex = 0;
03392 
03393                                     } <span class="keywordflow">else</span> {
03394 
03395                                         pNewEntry-&gt;TagIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a>;
03396                                     }
03397                                 }
03398 
03399                                 <span class="comment">//</span>
03400                                 <span class="comment">//  Allocate another new heap usage entry as part of the added</span>
03401                                 <span class="comment">//  entry list</span>
03402                                 <span class="comment">//</span>
03403 
03404                                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d9/heapdll_8c.html#a19">RtlpAllocateHeapUsageEntry</a>( Buffer, ppAddedEntries );
03405 
03406                                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03407 
03408                                     <span class="keywordflow">break</span>;
03409                                 }
03410 
03411                                 <span class="comment">//</span>
03412                                 <span class="comment">//  Copy over the contents of the new entry to the added entry</span>
03413                                 <span class="comment">//</span>
03414 
03415                                 **ppAddedEntries = *pNewEntry;
03416 
03417                                 <span class="comment">//</span>
03418                                 <span class="comment">//  Advance the added entry pointer to the next slot</span>
03419                                 <span class="comment">//</span>
03420 
03421                                 ppAddedEntries = &amp;((*ppAddedEntries)-&gt;Next);
03422 
03423                                 *ppAddedEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03424 
03425                                 pNewEntry-&gt;Next = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03426 
03427                                 <span class="comment">//</span>
03428                                 <span class="comment">//  Add the new entry to the entries list</span>
03429                                 <span class="comment">//</span>
03430 
03431                                 *ppEntries = pNewEntry;
03432                                 ppEntries = &amp;pNewEntry-&gt;Next;
03433                             }
03434                         }
03435 
03436                         <span class="comment">//</span>
03437                         <span class="comment">//  Now advance to the next block in the segment</span>
03438                         <span class="comment">//</span>
03439                         <span class="comment">//  If the next block doesn't exist then zoom through the</span>
03440                         <span class="comment">//  uncommitted ranges in the segment until we find a</span>
03441                         <span class="comment">//  match and can recompute the next real block</span>
03442                         <span class="comment">//</span>
03443 
03444                         <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
03445 
03446                             CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
03447 
03448                             <span class="keywordflow">if</span> (CurrentBlock &lt; Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>) {
03449 
03450                                 UnCommittedRange = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o11">UnCommittedRanges</a>;
03451 
03452                                 <span class="keywordflow">while</span> ((UnCommittedRange != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03453                                        (UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> != (ULONG_PTR)CurrentBlock)) {
03454 
03455                                     UnCommittedRange = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
03456                                 }
03457 
03458                                 <span class="keywordflow">if</span> (UnCommittedRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03459 
03460                                     CurrentBlock = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>;
03461 
03462                                 } <span class="keywordflow">else</span> {
03463 
03464                                     CurrentBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)(UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> +
03465                                                                  UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a>);
03466                                 }
03467                             }
03468 
03469                         } <span class="keywordflow">else</span> {
03470 
03471                             <span class="comment">//</span>
03472                             <span class="comment">//  Otherwise the next block exists and so point</span>
03473                             <span class="comment">//  directly at it</span>
03474                             <span class="comment">//</span>
03475 
03476                             CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
03477                         }
03478                     }
03479                 }
03480             }
03481 
03482             <span class="comment">//</span>
03483             <span class="comment">//  At this point we've scanned through every segment in the heap</span>
03484             <span class="comment">//</span>
03485             <span class="comment">//  The first time through we now have two lists one of entries and</span>
03486             <span class="comment">//  another of added entries.  In each case Usage-&gt;Entries, and</span>
03487             <span class="comment">//  Usage-&gt;AddedEntries points to the start of the list and ppEntries,</span>
03488             <span class="comment">//  and ppAddedEntries points to the tail of the list.  The first</span>
03489             <span class="comment">//  time through we has seem to have a one-to-one correspondence</span>
03490             <span class="comment">//  between Entries and AddedEntries, but the AddedEntries records</span>
03491             <span class="comment">//  do not contain anything useful</span>
03492             <span class="comment">//</span>
03493 
03494             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03495 
03496                 <span class="comment">//</span>
03497                 <span class="comment">//  Now we'll examine each big allocation, and for each big allocation</span>
03498                 <span class="comment">//  we'll make a heap usage entry</span>
03499                 <span class="comment">//</span>
03500 
03501                 Head = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o21">VirtualAllocdBlocks</a>;
03502                 Next = Head-&gt;Flink;
03503                 VirtualAllocBlockSeen = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03504 
03505                 <span class="keywordflow">while</span> (Head != Next) {
03506 
03507                     VirtualAllocBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, Entry );
03508 
03509                     <span class="comment">//</span>
03510                     <span class="comment">//  Allocate a new heap usage entry</span>
03511                     <span class="comment">//</span>
03512 
03513                     pNewEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03514 
03515                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d9/heapdll_8c.html#a19">RtlpAllocateHeapUsageEntry</a>( Buffer, &amp;pNewEntry );
03516 
03517                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03518 
03519                         <span class="keywordflow">break</span>;
03520                     }
03521 
03522                     VirtualAllocBlockSeen = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03523 
03524                     <span class="comment">//</span>
03525                     <span class="comment">//  Fill in the new heap usage entry</span>
03526                     <span class="comment">//</span>
03527 
03528                     pNewEntry-&gt;Address = (VirtualAllocBlock + 1);
03529                     pNewEntry-&gt;Size = VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a> - VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o4">BusyBlock</a>.<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
03530 
03531 <span class="preprocessor">    #if i386</span>
03532 <span class="preprocessor"></span>
03533                     pNewEntry-&gt;AllocatorBackTraceIndex = VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o1">ExtraStuff</a>.<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o0">AllocatorBackTraceIndex</a>;
03534 
03535 <span class="preprocessor">    #endif // i386</span>
03536 <span class="preprocessor"></span>
03537                     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
03538 
03539                         pNewEntry-&gt;TagIndex = 0;
03540 
03541                     } <span class="keywordflow">else</span> {
03542 
03543                         pNewEntry-&gt;TagIndex = VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o1">ExtraStuff</a>.<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>;
03544                     }
03545 
03546                     <span class="comment">//</span>
03547                     <span class="comment">//  Search the heap usage entries list until we find the address</span>
03548                     <span class="comment">//  that right after the new entry address and then insert</span>
03549                     <span class="comment">//  this new entry.  This will keep the entries list sorted in</span>
03550                     <span class="comment">//  assending addresses</span>
03551                     <span class="comment">//</span>
03552                     <span class="comment">//</span>
03553                     <span class="comment">//  The first time through this function ppEntries will point</span>
03554                     <span class="comment">//  to the tail and so *pp should actually start off as null,</span>
03555                     <span class="comment">//  which means that the big allocation simply get tacked on</span>
03556                     <span class="comment">//  the end of the entries list.  We do not augment the</span>
03557                     <span class="comment">//  AddedEntries list for these big allocations.</span>
03558                     <span class="comment">//</span>
03559 
03560                     pp = ppEntries;
03561 
03562                     <span class="keywordflow">while</span> (*pp) {
03563 
03564                         <span class="keywordflow">if</span> ((*pp)-&gt;Address &gt;= pNewEntry-&gt;Address) {
03565 
03566                             <span class="keywordflow">break</span>;
03567                         }
03568 
03569                         pp = &amp;(*pp)-&gt;Next;
03570                     }
03571 
03572                     pNewEntry-&gt;Next = *pp;
03573                     *pp = pNewEntry;
03574 
03575                     <span class="comment">//</span>
03576                     <span class="comment">//  Get the next big allocation block</span>
03577                     <span class="comment">//</span>
03578 
03579                     Next = Next-&gt;Flink;
03580                 }
03581 
03582                 <span class="comment">//</span>
03583                 <span class="comment">//  At this point we've scanned through the heap segments and the</span>
03584                 <span class="comment">//  big allocations.</span>
03585                 <span class="comment">//</span>
03586                 <span class="comment">//  The first time through this procedure we have built two lists</span>
03587                 <span class="comment">//  the Entries and the AddedEntries</span>
03588                 <span class="comment">//</span>
03589 
03590                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03591 
03592                     pOldEntries = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;LargeEntriesSentinal;
03593                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;LargeEntriesSentinal = *ppEntries;
03594 
03595                     <span class="comment">//</span>
03596                     <span class="comment">//  Now we'll process the previous large entries sentinal list</span>
03597                     <span class="comment">//</span>
03598                     <span class="comment">//  This path is not taken the first time through this procedure</span>
03599                     <span class="comment">//</span>
03600 
03601                     <span class="keywordflow">while</span> (pOldEntries != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03602 
03603                         <span class="comment">//</span>
03604                         <span class="comment">//  If we have new entries and the entry is equal to the</span>
03605                         <span class="comment">//  entry in the previous large sentinal list then</span>
03606                         <span class="comment">//  we move one down on the new list and remove the previous</span>
03607                         <span class="comment">//  sentinal entry</span>
03608                         <span class="comment">//</span>
03609 
03610                         <span class="keywordflow">if</span> ((*ppEntries != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03611                             (pOldEntries-&gt;Address == (*ppEntries)-&gt;Address) &amp;&amp;
03612                             (pOldEntries-&gt;Size == (*ppEntries)-&gt;Size)) {
03613 
03614                             ppEntries = &amp;(*ppEntries)-&gt;Next;
03615 
03616                             pOldEntries = <a class="code" href="../../d5/d9/heapdll_8c.html#a18">RtlpFreeHeapUsageEntry</a>( Buffer, pOldEntries );
03617 
03618                         <span class="comment">//</span>
03619                         <span class="comment">//  If we do now have any new entries or the previous</span>
03620                         <span class="comment">//  sentinal entry is comes before this new entry then</span>
03621                         <span class="comment">//  we'll add the sentinal entry to the remove list</span>
03622                         <span class="comment">//</span>
03623 
03624                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*ppEntries == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
03625                                    (pOldEntries-&gt;Address &lt; (*ppEntries)-&gt;Address)) {
03626 
03627                             *ppRemovedEntries = pOldEntries;
03628 
03629                             pOldEntries = pOldEntries-&gt;Next;
03630 
03631                             ppRemovedEntries = &amp;(*ppRemovedEntries)-&gt;Next;
03632 
03633                             *ppRemovedEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03634 
03635                         <span class="comment">//</span>
03636                         <span class="comment">//  Otherwise the old sentinal entry is put on the added</span>
03637                         <span class="comment">//  entries list</span>
03638                         <span class="comment">//</span>
03639 
03640                         } <span class="keywordflow">else</span> {
03641 
03642                             *ppAddedEntries = pOldEntries;
03643 
03644                             pOldEntries = pOldEntries-&gt;Next;
03645 
03646                             **ppAddedEntries = **ppEntries;
03647 
03648                             ppAddedEntries = &amp;(*ppAddedEntries)-&gt;Next;
03649 
03650                             *ppAddedEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03651                         }
03652                     }
03653 
03654                     <span class="comment">//</span>
03655                     <span class="comment">//  This path is not taken the first time through this procedure</span>
03656                     <span class="comment">//</span>
03657 
03658                     <span class="keywordflow">while</span> (pNewEntry = *ppEntries) {
03659 
03660                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d9/heapdll_8c.html#a19">RtlpAllocateHeapUsageEntry</a>( Buffer, ppAddedEntries );
03661 
03662                         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
03663 
03664                             <span class="keywordflow">break</span>;
03665                         }
03666 
03667                         **ppAddedEntries = *pNewEntry;
03668 
03669                         ppAddedEntries = &amp;(*ppAddedEntries)-&gt;Next;
03670 
03671                         *ppAddedEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03672 
03673                         ppEntries = &amp;pNewEntry-&gt;Next;
03674                     }
03675 
03676                     <span class="comment">//</span>
03677                     <span class="comment">//  Tell the user that something has changed between the</span>
03678                     <span class="comment">//  previous call and this one</span>
03679                     <span class="comment">//</span>
03680 
03681                     <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;AddedEntries != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;RemovedEntries != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
03682 
03683                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_MORE_ENTRIES;
03684                     }
03685                 }
03686             }
03687         }
03688 
03689     } finally {
03690 
03691         <span class="comment">//</span>
03692         <span class="comment">//  Unlock the heap</span>
03693         <span class="comment">//</span>
03694 
03695         <span class="keywordflow">if</span> (LockAcquired) {
03696 
03697             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
03698         }
03699     }
03700 
03701     <span class="comment">//</span>
03702     <span class="comment">//  And return to our caller</span>
03703     <span class="comment">//</span>
03704 
03705     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03706 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="heapdll.c::RtlValidateHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlValidateHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02530">2530</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00323">_HEAP::ForceFlags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00233">HEAP_MAXIMUM_FREELISTS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00054">IS_DEBUG_PAGE_HEAP_HANDLE</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00369">_HEAP::LockVariable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00382">_HEAP::Lookaside</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00078">RtlAcquireLockRoutine</a>, <a class="el" href="../../d4/d6/config_2utils_2regutil_8c-source.html#l00023">RtlFreeHeap</a>, <a class="el" href="../../d1/d5/rtl_2lookasid_8c-source.html#l00222">RtlpAllocateFromHeapLookaside()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04250">RtlpCheckHeapSignature()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03539">RtlpDebugPageHeapValidate()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l02025">RtlpValidateHeap()</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01696">RtlpValidateHeapEntry()</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00079">RtlReleaseLockRoutine</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00104">SET_LAST_STATUS</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d2/d0/theap_8c-source.html#l00077">main()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l04752">RtlpDphNormalHeapValidate()</a>, and <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02680">RtlValidateProcessHeaps()</a>.
<p>
<pre class="fragment"><div>02538                    :
02539 
02540     This routine verifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> structure of a heap and/or heap block
02541 
02542 Arguments:
02543 
02544     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being queried
02545 
02546     Flags - Supplies a set of flags used to augment those already
02547         enforced by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap
02548 
02549     BaseAddress - Optionally supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap block
02550         that should be individually validated
02551 
02552 Return Value:
02553 
02554     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap/block <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> okay and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise
02555 
02556 --*/
02557 
02558 {
02559     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
02560     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02561     BOOLEAN Result;
02562 
02563     <span class="keywordflow">try</span> {
02564 
02565         <span class="keywordflow">try</span> {
02566 
02567             <span class="comment">//</span>
02568             <span class="comment">//  Check for the guard page version of heap</span>
02569             <span class="comment">//</span>
02570 
02571             <span class="keywordflow">if</span> ( <a class="code" href="../../d7/d9/heappage_8h.html#a5">IS_DEBUG_PAGE_HEAP_HANDLE</a>( HeapHandle )) {
02572 
02573                 Result = <a class="code" href="../../d7/d9/heappage_8h.html#a17">RtlpDebugPageHeapValidate</a>( HeapHandle, Flags, BaseAddress );
02574 
02575             } <span class="keywordflow">else</span> {
02576 
02577                 <span class="comment">//</span>
02578                 <span class="comment">//  If there is an active lookaside list then drain and remove it.</span>
02579                 <span class="comment">//  By setting the lookaside field in the heap to null we guarantee</span>
02580                 <span class="comment">//  that the call the free heap will not try and use the lookaside</span>
02581                 <span class="comment">//  list logic.</span>
02582                 <span class="comment">//</span>
02583                 <span class="comment">//  We'll actually capture the lookaside pointer from the heap and</span>
02584                 <span class="comment">//  only use the captured pointer.  This will take care of the</span>
02585                 <span class="comment">//  condition where another walk or lock heap can cause us to check</span>
02586                 <span class="comment">//  for a non null pointer and then have it become null when we read</span>
02587                 <span class="comment">//  it again.  If it is non null to start with then even if the</span>
02588                 <span class="comment">//  user walks or locks the heap via another thread the pointer to</span>
02589                 <span class="comment">//  still valid here so we can still try and do a lookaside list pop.</span>
02590                 <span class="comment">//</span>
02591 
02592                 <a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a> Lookaside = (<a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a>)Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o33">Lookaside</a>;
02593 
02594                 <span class="keywordflow">if</span> (Lookaside != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02595 
02596                     ULONG i;
02597                     PVOID Block;
02598 
02599                     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o33">Lookaside</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02600 
02601                     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>; i += 1) {
02602 
02603                         <span class="keywordflow">while</span> ((Block = <a class="code" href="../../d0/d6/rtl_2lookasid_8c.html#a5">RtlpAllocateFromHeapLookaside</a>(&amp;(Lookaside[i]))) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02604 
02605                             <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( HeapHandle, 0, Block );
02606                         }
02607                     }
02608                 }
02609 
02610                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02611 
02612                 <span class="comment">//</span>
02613                 <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
02614                 <span class="comment">//</span>
02615 
02616                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlValidateHeap"</span> )) {
02617 
02618                     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
02619 
02620                     <span class="comment">//</span>
02621                     <span class="comment">//  Lock the heap</span>
02622                     <span class="comment">//</span>
02623 
02624                     <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
02625 
02626                         <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02627 
02628                         LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02629                     }
02630 
02631                     <span class="comment">//</span>
02632                     <span class="comment">//  If the user did not supply a base address then verify</span>
02633                     <span class="comment">//  the complete heap otherwise just do a single heap</span>
02634                     <span class="comment">//  entry</span>
02635                     <span class="comment">//</span>
02636 
02637                     <span class="keywordflow">if</span> (BaseAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02638 
02639                         Result = <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, TRUE );
02640 
02641                     } <span class="keywordflow">else</span> {
02642 
02643                         Result = <a class="code" href="../../d9/d9/heappriv_8h.html#a47">RtlpValidateHeapEntry</a>( Heap, (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1, <span class="stringliteral">"RtlValidateHeap"</span> );
02644                     }
02645                 }
02646             }
02647 
02648         } except( EXCEPTION_EXECUTE_HANDLER ) {
02649 
02650             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
02651 
02652             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02653         }
02654 
02655     } finally {
02656 
02657         <span class="comment">//</span>
02658         <span class="comment">//  Unlock the heap</span>
02659         <span class="comment">//</span>
02660 
02661         <span class="keywordflow">if</span> (LockAcquired) {
02662 
02663             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02664         }
02665     }
02666 
02667     <span class="comment">//</span>
02668     <span class="comment">//  And return to our caller</span>
02669     <span class="comment">//</span>
02670 
02671     <span class="keywordflow">return</span> Result;
02672 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="heapdll.c::RtlValidateProcessHeaps" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlValidateProcessHeaps           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">VOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02680">2680</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02803">RtlGetProcessHeaps()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02530">RtlValidateHeap()</a>, <a class="el" href="../../d9/d6/lh__open_2pi__mem_8h-source.html#l00017">Size</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l01462">LdrShutdownProcess()</a>.
<p>
<pre class="fragment"><div>02686                    :
02687 
02688     This routine cycles through all and validates each heap in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current
02689     process.
02690 
02691 Arguments:
02692 
02693     None.
02694 
02695 Return Value:
02696 
02697     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap verify okay and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <span class="keywordflow">for</span> any other
02698         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a10">reason</a>.
02699 
02700 --*/
02701 
02702 {
02703     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02704     ULONG i, NumberOfHeaps;
02705     PVOID HeapsArray[ 512 ];
02706     PVOID *Heaps;
02707     SIZE_T <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02708     BOOLEAN Result;
02709 
02710     Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02711 
02712     Heaps = &amp;HeapsArray[ 0 ];
02713 
02714     <span class="comment">//</span>
02715     <span class="comment">//  By default we can handle 512 heaps per process any more than</span>
02716     <span class="comment">//  that and we'll need to allocate storage to do the processing</span>
02717     <span class="comment">//</span>
02718     <span class="comment">//  So now determine how many heaps are in the current process</span>
02719     <span class="comment">//</span>
02720 
02721     NumberOfHeaps = <a class="code" href="../../d5/d9/heapdll_8c.html#a34">RtlGetProcessHeaps</a>( 512, Heaps );
02722 
02723     <span class="comment">//</span>
02724     <span class="comment">//  **** this is bogus because the preceeding routine will</span>
02725     <span class="comment">//  **** never return more than 512.  Either this routine</span>
02726     <span class="comment">//  **** needs to get the heap count from the peb itself</span>
02727     <span class="comment">//  **** or the called routine needs to return the actual</span>
02728     <span class="comment">//  **** number of heaps in the process, Then we have to know</span>
02729     <span class="comment">//  **** not to to beyond the heap array size</span>
02730     <span class="comment">//</span>
02731 
02732     <span class="keywordflow">if</span> (NumberOfHeaps &gt; 512) {
02733 
02734         <span class="comment">//</span>
02735         <span class="comment">//  The number of heaps is greater than 512 so</span>
02736         <span class="comment">//  allocate extra memory to store the array of</span>
02737         <span class="comment">//  heap pointers</span>
02738         <span class="comment">//</span>
02739 
02740         Heaps = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02741         <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = NumberOfHeaps * <span class="keyword">sizeof</span>( PVOID );
02742 
02743         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
02744                                           (PVOID *)&amp;Heaps,
02745                                           0,
02746                                           &amp;Size,
02747                                           MEM_COMMIT,
02748                                           PAGE_READWRITE );
02749 
02750         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
02751 
02752             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02753         }
02754 
02755         <span class="comment">//</span>
02756         <span class="comment">//  And retry getting the heaps</span>
02757         <span class="comment">//</span>
02758         <span class="comment">//  **** this won't work again because it still uses 512</span>
02759         <span class="comment">//</span>
02760 
02761         NumberOfHeaps = <a class="code" href="../../d5/d9/heapdll_8c.html#a34">RtlGetProcessHeaps</a>( 512, Heaps );
02762     }
02763 
02764     <span class="comment">//</span>
02765     <span class="comment">//  Now for each heap in our heap array we'll validate</span>
02766     <span class="comment">//  that heap</span>
02767     <span class="comment">//</span>
02768 
02769     <span class="keywordflow">for</span> (i=0; i&lt;NumberOfHeaps; i++) {
02770 
02771         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d9/heapdll_8c.html#a32">RtlValidateHeap</a>( Heaps[i], 0, NULL )) {
02772 
02773             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02774         }
02775     }
02776 
02777     <span class="comment">//</span>
02778     <span class="comment">//  Check if we need to return the memory that we use for</span>
02779     <span class="comment">//  an enlarged heap array</span>
02780     <span class="comment">//</span>
02781 
02782     <span class="keywordflow">if</span> (Heaps != &amp;HeapsArray[ 0 ]) {
02783 
02784         ZwFreeVirtualMemory( NtCurrentProcess(),
02785                              (PVOID *)&amp;Heaps,
02786                              &amp;Size,
02787                              MEM_RELEASE );
02788     }
02789 
02790     <span class="comment">//</span>
02791     <span class="comment">//  And return to our caller</span>
02792     <span class="comment">//</span>
02793 
02794     <span class="keywordflow">return</span> Result;
02795 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="heapdll.c::RtlWalkHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS RtlWalkHeap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>HeapHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PRTL_HEAP_WALK_ENTRY&nbsp;</td>
          <td class="mdname" nowrap> <em>Entry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l03714">3714</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
References <a class="el" href="../../d4/d8/heap_8h-source.html#l00254">_HEAP_UNCOMMMTTED_RANGE::Address</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00113">_HEAP_ENTRY_EXTRA::AllocatorBackTraceIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00164">_HEAP_VIRTUAL_ALLOC_ENTRY::BusyBlock</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00103">DEBUG_HEAP</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00160">_HEAP_VIRTUAL_ALLOC_ENTRY::Entry</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00269">_HEAP_SEGMENT::FirstEntry</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00076">_HEAP_ENTRY::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00263">_HEAP_SEGMENT::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00322">_HEAP::Flags</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00236">HEAP_ENTRY_BUSY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00237">HEAP_ENTRY_EXTRA_PRESENT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00240">HEAP_ENTRY_LAST_ENTRY</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00244">HEAP_ENTRY_SETTABLE_FLAGS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00239">HEAP_ENTRY_VIRTUAL_ALLOC</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00228">HEAP_GRANULARITY_SHIFT</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00233">HEAP_MAXIMUM_FREELISTS</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00234">HEAP_MAXIMUM_SEGMENTS</a>, <a class="el" href="../../d5/d5/memory_8c-source.html#l00115">HeapHandle</a>, <a class="el" href="../../d8/d8/heappage_8h-source.html#l00058">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>, <a class="el" href="../../d0/d9/heappriv_8h-source.html#l00563">IS_HEAP_TAGGING_ENABLED</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00270">_HEAP_SEGMENT::LastValidEntry</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00382">_HEAP::Lookaside</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00253">_HEAP_UNCOMMMTTED_RANGE::Next</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00268">_HEAP_SEGMENT::NumberOfPages</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00272">_HEAP_SEGMENT::NumberOfUnCommittedPages</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l01654">RtlDebugWalkHeap()</a>, <a class="el" href="../../d4/d6/config_2utils_2regutil_8c-source.html#l00023">RtlFreeHeap</a>, <a class="el" href="../../d1/d5/rtl_2lookasid_8c-source.html#l00222">RtlpAllocateFromHeapLookaside()</a>, <a class="el" href="../../d7/d8/heappage_8c-source.html#l03586">RtlpDebugPageHeapWalk()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06008">RtlpGetExtraStuffPointer()</a>, <a class="el" href="../../d2/d8/rtl_2heap_8c-source.html#l06070">RtlpGetSizeOfBigBlock()</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00060">_HEAP_ENTRY::SegmentIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00355">_HEAP::Segments</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00128">_HEAP_ENTRY_EXTRA::Settable</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00255">_HEAP_UNCOMMMTTED_RANGE::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00045">_HEAP_ENTRY::Size</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00091">_HEAP_ENTRY::SmallTagIndex</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00121">_HEAP_ENTRY_EXTRA::TagIndex</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00274">_HEAP_SEGMENT::UnCommittedRanges</a>, <a class="el" href="../../d4/d8/heap_8h-source.html#l00085">_HEAP_ENTRY::UnusedBytes</a>, and <a class="el" href="../../d4/d8/heap_8h-source.html#l00353">_HEAP::VirtualAllocdBlocks</a>.
<p>
<pre class="fragment"><div>03721                    :
03722 
03723     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to enumerate all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entries within a heap.  For each
03724     call <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> returns a <span class="keyword">new</span> information in entry.
03725 
03726 Arguments:
03727 
03728     <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> heap being queried
03729 
03730     Entry - Supplies storage <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entry information.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> DataAddress field
03731         <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> null then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> enumeration starts over from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> beginning otherwise <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
03732         resumes from where <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> left off
03733 
03734 Return Value:
03735 
03736     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> - An appropriate status value
03737 
03738 --*/
03739 
03740 {
03741     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03742     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
03743     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
03744     UCHAR SegmentIndex;
03745     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> CurrentBlock;
03746     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
03747     <a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> UnCommittedRange, *pp;
03748     PLIST_ENTRY Next, Head;
03749     <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
03750 
03751     <span class="comment">//</span>
03752     <span class="comment">//  Check if we should be using the guard page verion of heap</span>
03753     <span class="comment">//</span>
03754 
03755     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( HeapHandle,
03756                                     <a class="code" href="../../d7/d9/heappage_8h.html#a18">RtlpDebugPageHeapWalk</a>( HeapHandle, Entry ));
03757 
03758     <span class="comment">//</span>
03759     <span class="comment">//  If this is the debug version of heap then validate the heap</span>
03760     <span class="comment">//  before we go on</span>
03761     <span class="comment">//</span>
03762 
03763     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> )) {
03764 
03765         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d9/heapdll_8c.html#a16">RtlDebugWalkHeap</a>( HeapHandle, Entry )) {
03766 
03767             <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
03768         }
03769     }
03770 
03771     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
03772 
03773     <span class="comment">//</span>
03774     <span class="comment">//  If there is an active lookaside list then drain and remove it.</span>
03775     <span class="comment">//  By setting the lookaside field in the heap to null we guarantee</span>
03776     <span class="comment">//  that the call the free heap will not try and use the lookaside</span>
03777     <span class="comment">//  list logic.</span>
03778     <span class="comment">//</span>
03779     <span class="comment">//  We'll actually capture the lookaside pointer from the heap and</span>
03780     <span class="comment">//  only use the captured pointer.  This will take care of the</span>
03781     <span class="comment">//  condition where another walk or lock heap can cause us to check</span>
03782     <span class="comment">//  for a non null pointer and then have it become null when we read</span>
03783     <span class="comment">//  it again.  If it is non null to start with then even if the</span>
03784     <span class="comment">//  user walks or locks the heap via another thread the pointer to</span>
03785     <span class="comment">//  still valid here so we can still try and do a lookaside list pop.</span>
03786     <span class="comment">//</span>
03787 
03788     {
03789         <a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a> Lookaside = (<a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a>)Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o33">Lookaside</a>;
03790 
03791         <span class="keywordflow">if</span> (Lookaside != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03792 
03793             ULONG i;
03794             PVOID Block;
03795 
03796             Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o33">Lookaside</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03797 
03798             <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>; i += 1) {
03799 
03800                 <span class="keywordflow">while</span> ((Block = <a class="code" href="../../d0/d6/rtl_2lookasid_8c.html#a5">RtlpAllocateFromHeapLookaside</a>(&amp;(Lookaside[i]))) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03801 
03802                     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( HeapHandle, 0, Block );
03803                 }
03804             }
03805         }
03806     }
03807 
03808     <span class="comment">//</span>
03809     <span class="comment">//  Check if this is the first time we've been called to walk the heap</span>
03810     <span class="comment">//</span>
03811 
03812     <span class="keywordflow">if</span> (Entry-&gt;DataAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03813 
03814         <span class="comment">//</span>
03815         <span class="comment">//  Start with the first segement in the heap</span>
03816         <span class="comment">//</span>
03817 
03818         SegmentIndex = 0;
03819 
03820 nextSegment:
03821 
03822         CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03823 
03824         <span class="comment">//</span>
03825         <span class="comment">//  Now find the next in use segment for the heap</span>
03826         <span class="comment">//</span>
03827 
03828         Segment = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03829 
03830         <span class="keywordflow">while</span> ((SegmentIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>) &amp;&amp;
03831                ((Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ]) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
03832 
03833             SegmentIndex += 1;
03834         }
03835 
03836         <span class="comment">//</span>
03837         <span class="comment">//  If there are no more valid segments then we'll try the big</span>
03838         <span class="comment">//  allocation</span>
03839         <span class="comment">//</span>
03840 
03841         <span class="keywordflow">if</span> (Segment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03842 
03843             Head = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o21">VirtualAllocdBlocks</a>;
03844             Next = Head-&gt;Flink;
03845 
03846             <span class="keywordflow">if</span> (Next == Head) {
03847 
03848                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MORE_ENTRIES;
03849 
03850             } <span class="keywordflow">else</span> {
03851 
03852                 VirtualAllocBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, Entry );
03853 
03854                 CurrentBlock = &amp;VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o4">BusyBlock</a>;
03855             }
03856 
03857         <span class="comment">//</span>
03858         <span class="comment">//  Otherwise we'll grab information about the segment.  Note that</span>
03859         <span class="comment">//  the current block is still null so when we fall out of this</span>
03860         <span class="comment">//  block we'll return directly to our caller with this segment</span>
03861         <span class="comment">//  information</span>
03862         <span class="comment">//</span>
03863 
03864         } <span class="keywordflow">else</span> {
03865 
03866             Entry-&gt;DataAddress = Segment;
03867 
03868             Entry-&gt;DataSize = 0;
03869 
03870             Entry-&gt;OverheadBytes = <span class="keyword">sizeof</span>( *Segment );
03871 
03872             Entry-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o2">Flags</a> = RTL_HEAP_SEGMENT;
03873 
03874             Entry-&gt;SegmentIndex = SegmentIndex;
03875 
03876             Entry-&gt;Segment.CommittedSize = (Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o6">NumberOfPages</a> -
03877                                             Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o9">NumberOfUnCommittedPages</a>) * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03878 
03879             Entry-&gt;Segment.UnCommittedSize = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o9">NumberOfUnCommittedPages</a> * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03880 
03881             Entry-&gt;Segment.FirstEntry = (Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o7">FirstEntry</a>-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) ?
03882                 ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o7">FirstEntry</a> + 1) :
03883                 (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o7">FirstEntry</a> + 1);
03884 
03885             Entry-&gt;Segment.LastEntry = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>;
03886         }
03887 
03888     <span class="comment">//</span>
03889     <span class="comment">//  This is not the first time through.  Check if last time we gave back</span>
03890     <span class="comment">//  an heap segement or an uncommitted range</span>
03891     <span class="comment">//</span>
03892 
03893     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Entry-&gt;Flags &amp; (RTL_HEAP_SEGMENT | RTL_HEAP_UNCOMMITTED_RANGE)) {
03894 
03895         <span class="comment">//</span>
03896         <span class="comment">//  Check that the segment index is still valid</span>
03897         <span class="comment">//</span>
03898 
03899         <span class="keywordflow">if</span> ((SegmentIndex = Entry-&gt;SegmentIndex) &gt;= <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>) {
03900 
03901             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_ADDRESS;
03902 
03903             CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03904 
03905         } <span class="keywordflow">else</span> {
03906 
03907             <span class="comment">//</span>
03908             <span class="comment">//  Check that the segment is still in use</span>
03909             <span class="comment">//</span>
03910 
03911             Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
03912 
03913             <span class="keywordflow">if</span> (Segment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03914 
03915                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_ADDRESS;
03916 
03917                 CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03918 
03919             <span class="comment">//</span>
03920             <span class="comment">//  The segment is still in use if what we returned last time</span>
03921             <span class="comment">//  as the segment header then this time we'll return the</span>
03922             <span class="comment">//  segments first entry</span>
03923             <span class="comment">//</span>
03924 
03925             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Entry-&gt;Flags &amp; RTL_HEAP_SEGMENT) {
03926 
03927                 CurrentBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o7">FirstEntry</a>;
03928 
03929             <span class="comment">//</span>
03930             <span class="comment">//  Otherwise what we returned last time as an uncommitted</span>
03931             <span class="comment">//  range so now we need to get the next block</span>
03932             <span class="comment">//</span>
03933 
03934             } <span class="keywordflow">else</span> {
03935 
03936                 CurrentBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)((PCHAR)Entry-&gt;DataAddress + Entry-&gt;DataSize);
03937 
03938                 <span class="comment">//</span>
03939                 <span class="comment">//  Check if we are beyond this segment and need to get the</span>
03940                 <span class="comment">//  next one</span>
03941                 <span class="comment">//</span>
03942 
03943                 <span class="keywordflow">if</span> (CurrentBlock &gt;= Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>) {
03944 
03945                     SegmentIndex += 1;
03946 
03947                     <span class="keywordflow">goto</span> nextSegment;
03948                 }
03949             }
03950         }
03951 
03952     <span class="comment">//</span>
03953     <span class="comment">//  Otherwise this is not the first time through and last time we gave back a</span>
03954     <span class="comment">//  valid heap entry</span>
03955     <span class="comment">//</span>
03956 
03957     } <span class="keywordflow">else</span> {
03958 
03959         <span class="comment">//</span>
03960         <span class="comment">//  Check if the last entry we gave back was in use</span>
03961         <span class="comment">//</span>
03962 
03963         <span class="keywordflow">if</span> (Entry-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
03964 
03965             <span class="comment">//</span>
03966             <span class="comment">//  Get the last entry we returned</span>
03967             <span class="comment">//</span>
03968 
03969             CurrentBlock = ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)Entry-&gt;DataAddress - 1);
03970 
03971             <span class="comment">//</span>
03972             <span class="comment">//  If the last entry was for a big allocation then</span>
03973             <span class="comment">//  get the next big block if there is one otherwise</span>
03974             <span class="comment">//  say there are no more entries</span>
03975             <span class="comment">//</span>
03976 
03977             <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
03978 
03979                 Head = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o21">VirtualAllocdBlocks</a>;
03980 
03981                 VirtualAllocBlock = CONTAINING_RECORD( CurrentBlock, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
03982 
03983                 Next = VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o0">Entry</a>.Flink;
03984 
03985                 <span class="keywordflow">if</span> (Next == Head) {
03986 
03987                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MORE_ENTRIES;
03988 
03989                 } <span class="keywordflow">else</span> {
03990 
03991                     VirtualAllocBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, Entry );
03992 
03993                     CurrentBlock = &amp;VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o4">BusyBlock</a>;
03994                 }
03995 
03996             <span class="comment">//</span>
03997             <span class="comment">//  Our previous result is a busy normal block</span>
03998             <span class="comment">//</span>
03999 
04000             } <span class="keywordflow">else</span> {
04001 
04002                 <span class="comment">//</span>
04003                 <span class="comment">//  Get the segment and make sure it it still valid and in use</span>
04004                 <span class="comment">//</span>
04005                 <span class="comment">//  **** this should also check that segment index is not</span>
04006                 <span class="comment">//  **** greater than HEAP MAXIMUM SEGMENTS</span>
04007                 <span class="comment">//</span>
04008 
04009                 Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a> ];
04010 
04011                 <span class="keywordflow">if</span> (Segment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04012 
04013                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_ADDRESS;
04014 
04015                     CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04016 
04017                 <span class="comment">//</span>
04018                 <span class="comment">//  The segment is still in use, check if what we returned</span>
04019                 <span class="comment">//  previously was a last entry</span>
04020                 <span class="comment">//</span>
04021 
04022                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
04023 
04024 findUncommittedRange:
04025 
04026                     <span class="comment">//</span>
04027                     <span class="comment">//  We are at a last entry so now if the segment is done</span>
04028                     <span class="comment">//  then go get another segment</span>
04029                     <span class="comment">//</span>
04030 
04031                     CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
04032 
04033                     <span class="keywordflow">if</span> (CurrentBlock &gt;= Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>) {
04034 
04035                         SegmentIndex += 1;
04036 
04037                         <span class="keywordflow">goto</span> nextSegment;
04038                     }
04039 
04040                     <span class="comment">//</span>
04041                     <span class="comment">//  Otherwise we will find the uncommitted range entry that</span>
04042                     <span class="comment">//  immediately follows this last entry</span>
04043                     <span class="comment">//</span>
04044 
04045                     pp = &amp;Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o11">UnCommittedRanges</a>;
04046 
04047                     <span class="keywordflow">while</span> ((UnCommittedRange = *pp) &amp;&amp; UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> != (ULONG_PTR)CurrentBlock ) {
04048 
04049                         pp = &amp;UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
04050                     }
04051 
04052                     <span class="keywordflow">if</span> (UnCommittedRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04053 
04054                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
04055 
04056                     } <span class="keywordflow">else</span> {
04057 
04058                         <span class="comment">//</span>
04059                         <span class="comment">//  Now fill in the entry to denote that uncommitted</span>
04060                         <span class="comment">//  range information</span>
04061                         <span class="comment">//</span>
04062 
04063                         Entry-&gt;DataAddress = (PVOID)UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a>;
04064 
04065                         Entry-&gt;DataSize = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a>;
04066 
04067                         Entry-&gt;OverheadBytes = 0;
04068 
04069                         Entry-&gt;SegmentIndex = SegmentIndex;
04070 
04071                         Entry-&gt;Flags = RTL_HEAP_UNCOMMITTED_RANGE;
04072                     }
04073 
04074                     <span class="comment">//</span>
04075                     <span class="comment">//  Null out the current block because we've just filled in</span>
04076                     <span class="comment">//  the entry</span>
04077                     <span class="comment">//</span>
04078 
04079                     CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04080 
04081                 } <span class="keywordflow">else</span> {
04082 
04083                     <span class="comment">//</span>
04084                     <span class="comment">//  Otherwise the entry has a following entry so now</span>
04085                     <span class="comment">//  advance to the next entry</span>
04086                     <span class="comment">//</span>
04087 
04088                     CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
04089                 }
04090             }
04091 
04092         <span class="comment">//</span>
04093         <span class="comment">//  Otherwise the previous entry we returned is not in use</span>
04094         <span class="comment">//</span>
04095 
04096         } <span class="keywordflow">else</span> {
04097 
04098             <span class="comment">//</span>
04099             <span class="comment">//  Get the last entry we returned</span>
04100             <span class="comment">//</span>
04101 
04102             CurrentBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)Entry-&gt;DataAddress - 1);
04103 
04104             <span class="comment">//</span>
04105             <span class="comment">//  Get the segment and make sure it it still valid and in use</span>
04106             <span class="comment">//</span>
04107             <span class="comment">//  **** this should also check that segment index is not</span>
04108             <span class="comment">//  **** greater than HEAP MAXIMUM SEGMENTS</span>
04109             <span class="comment">//</span>
04110 
04111             Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a> ];
04112 
04113             <span class="keywordflow">if</span> (Segment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04114 
04115                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_ADDRESS;
04116 
04117                 CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04118 
04119             <span class="comment">//</span>
04120             <span class="comment">//  If the block is the last entry then go find the next uncommitted</span>
04121             <span class="comment">//  range or segment</span>
04122             <span class="comment">//</span>
04123 
04124             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
04125 
04126                 <span class="keywordflow">goto</span> findUncommittedRange;
04127 
04128             <span class="comment">//</span>
04129             <span class="comment">//  Otherwise we'll just move on to the next entry</span>
04130             <span class="comment">//</span>
04131 
04132             } <span class="keywordflow">else</span> {
04133 
04134                 CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
04135             }
04136         }
04137     }
04138 
04139     <span class="comment">//</span>
04140     <span class="comment">//  At this point if current block is not null then we've found another</span>
04141     <span class="comment">//  entry to return.  We could also have found a segment or uncommitted</span>
04142     <span class="comment">//  range but those are handled separately above and keep current block</span>
04143     <span class="comment">//  null</span>
04144     <span class="comment">//</span>
04145 
04146     <span class="keywordflow">if</span> (CurrentBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04147 
04148         <span class="comment">//</span>
04149         <span class="comment">//  Check if the block is in use</span>
04150         <span class="comment">//</span>
04151 
04152         <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
04153 
04154             <span class="comment">//</span>
04155             <span class="comment">//  Fill in the entry field for this block</span>
04156             <span class="comment">//</span>
04157 
04158             Entry-&gt;DataAddress = (CurrentBlock+1);
04159 
04160             <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
04161 
04162                 Entry-&gt;DataSize = <a class="code" href="../../d9/d9/heappriv_8h.html#a40">RtlpGetSizeOfBigBlock</a>( CurrentBlock );
04163 
04164                 Entry-&gt;OverheadBytes = (UCHAR)( <span class="keyword">sizeof</span>( *VirtualAllocBlock ) + CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>);
04165 
04166                 Entry-&gt;SegmentIndex = <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>;
04167 
04168                 Entry-&gt;Flags = RTL_HEAP_BUSY |  <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>;
04169 
04170             } <span class="keywordflow">else</span> {
04171 
04172                 Entry-&gt;DataSize = (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) -
04173                                   CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a>;
04174 
04175                 Entry-&gt;OverheadBytes = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a>;
04176 
04177                 Entry-&gt;SegmentIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a>;
04178 
04179                 Entry-&gt;Flags = RTL_HEAP_BUSY;
04180             }
04181 
04182             <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
04183 
04184                 ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( CurrentBlock );
04185 
04186                 Entry-&gt;Block.Settable = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o2">Settable</a>;
04187 <span class="preprocessor">#if i386</span>
04188 <span class="preprocessor"></span>
04189                 Entry-&gt;Block.AllocatorBackTraceIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o0">AllocatorBackTraceIndex</a>;
04190 
04191 <span class="preprocessor">#endif // i386</span>
04192 <span class="preprocessor"></span>
04193                 <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
04194 
04195                     Entry-&gt;Block.TagIndex = 0;
04196 
04197                 } <span class="keywordflow">else</span> {
04198 
04199                     Entry-&gt;Block.TagIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>;
04200                 }
04201 
04202                 Entry-&gt;Flags |= RTL_HEAP_SETTABLE_VALUE;
04203 
04204             } <span class="keywordflow">else</span> {
04205 
04206                 <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
04207 
04208                     Entry-&gt;Block.TagIndex = 0;
04209 
04210                 } <span class="keywordflow">else</span> {
04211 
04212                     Entry-&gt;Block.TagIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a>;
04213                 }
04214             }
04215 
04216             Entry-&gt;Flags |= CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a16">HEAP_ENTRY_SETTABLE_FLAGS</a>;
04217 
04218         <span class="comment">//</span>
04219         <span class="comment">//  Otherwise the block is not in use</span>
04220         <span class="comment">//</span>
04221 
04222         } <span class="keywordflow">else</span> {
04223 
04224             Entry-&gt;DataAddress = ((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)CurrentBlock+1);
04225 
04226             Entry-&gt;DataSize = (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) -
04227                               <span class="keyword">sizeof</span>( <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a> );
04228 
04229             Entry-&gt;OverheadBytes = <span class="keyword">sizeof</span>( <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a> );
04230 
04231             Entry-&gt;SegmentIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a>;
04232 
04233             Entry-&gt;Flags = 0;
04234         }
04235     }
04236 
04237     <span class="comment">//</span>
04238     <span class="comment">//  And return to our caller</span>
04239     <span class="comment">//</span>
04240 
04241     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
04242 }

</div></pre>    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a5" doxytag="heapdll.c::RtlpGlobalTagHeap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> <a class="el" href="../../d5/d9/heapdll_8c.html#a5">RtlpGlobalTagHeap</a> = NULL          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00068">68</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
Referenced by <a class="el" href="../../d1/d9/heaptag_8c-source.html#l00191">LdrpDefineDllTag()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l01603">RtlCreateTagHeap()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05225">RtlpAllocateTags()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05425">RtlpGetTagName()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05554">RtlpUpdateTagEntry()</a>, and <a class="el" href="../../d2/d2/dll_2query_8c-source.html#l00769">RtlQueryProcessHeapInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="heapdll.c::RtlpProcessHeapsListBuffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d5/d5/struct__HEAP.html">PHEAP</a> <a class="el" href="../../d5/d9/heapdll_8c.html#a4">RtlpProcessHeapsListBuffer</a>[RTLP_STATIC_HEAP_LIST_SIZE]          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00061">61</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00179">RtlInitializeHeapManager()</a>, and <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04457">RtlpAddHeapToProcessList()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="heapdll.c::RtlpProcessHeapsListLock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d4/d6/struct__HEAP__LOCK.html">HEAP_LOCK</a> <a class="el" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00053">53</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02896">RtlEnumProcessHeaps()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l02803">RtlGetProcessHeaps()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00179">RtlInitializeHeapManager()</a>, <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04457">RtlpAddHeapToProcessList()</a>, and <a class="el" href="../../d6/d8/heapdll_8c-source.html#l04571">RtlpRemoveHeapFromProcessList()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="heapdll.c::RtlpPseudoTagNameBuffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> WCHAR <a class="el" href="../../d5/d9/heapdll_8c.html#a6">RtlpPseudoTagNameBuffer</a>[24]<code> [static]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d8/heapdll_8c-source.html#l00075">75</a> of file <a class="el" href="../../d6/d8/heapdll_8c-source.html">heapdll.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d8/heapdll_8c-source.html#l05425">RtlpGetTagName()</a>.    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:44:03 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
