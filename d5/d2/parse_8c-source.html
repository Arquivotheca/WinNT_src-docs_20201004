<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: parse.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>parse.c</h1><a href="../../d4/d3/parse_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989-1993  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    parse.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the code to implement the device object parse routine.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Darryl E. Havens (darrylh) 15-May-1988</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Kernel mode</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment"></span>
00024 <span class="comment">--*/</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="../../d0/d6/iop_8h.html">iop.h</a>"</span>
00027 
00028 <span class="comment">//</span>
00029 <span class="comment">// Define macro to round up the size of a name for buffer optimization.</span>
00030 <span class="comment">//</span>
00031 
<a name="l00032"></a><a class="code" href="../../d4/d3/parse_8c.html#a0">00032</a> <span class="preprocessor">#define RoundNameSize( Length ) ( \</span>
00033 <span class="preprocessor">    (Length &lt; 64 - 8) ? 64 - 8 :  \</span>
00034 <span class="preprocessor">    (Length &lt; 128 - 8) ? 128 - 8 :\</span>
00035 <span class="preprocessor">    (Length &lt; 256 - 8) ? 256 - 8 : Length )</span>
00036 <span class="preprocessor"></span>
<a name="l00037"></a><a class="code" href="../../d4/d3/parse_8c.html#a1">00037</a> <span class="preprocessor">#define IO_MAX_REMOUNT_REPARSE_ATTEMPTS 32</span>
00038 <span class="preprocessor"></span>
00039 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopParseFile)</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopParseDevice)</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopQueryName)</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopCheckBackupRestorePrivilege)</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00045 <span class="preprocessor"></span>
00046 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00047"></a><a class="code" href="../../d4/d3/parse_8c.html#a3">00047</a> <a class="code" href="../../d4/d3/parse_8c.html#a3">IopCheckDeviceAndDriver</a>(
00048     <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a> op,
00049     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> parseDeviceObject
00050     )
00051 {
00052     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00053     KIRQL irql;
00054 
00055     <span class="comment">//</span>
00056     <span class="comment">// Make sure that the device and its driver are really there and they are</span>
00057     <span class="comment">// going to stay there.  The object itself cannot go away just yet because</span>
00058     <span class="comment">// the object management system has performed a reference which bumps the</span>
00059     <span class="comment">// count of the number of reasons why the object must stick around.</span>
00060     <span class="comment">// However, the driver could be attempting to unload itself, so perform</span>
00061     <span class="comment">// this check.  If the driver is being unloaded, then set the final status</span>
00062     <span class="comment">// of the operation to "No such device" and return with a NULL file object</span>
00063     <span class="comment">// pointer.</span>
00064     <span class="comment">//</span>
00065     <span class="comment">// Note that it is possible to "open" an exclusive device more than once</span>
00066     <span class="comment">// provided that the caller is performing a relative open.  This feature</span>
00067     <span class="comment">// is how users "allocate" a device, and then use it to perform operations.</span>
00068     <span class="comment">//</span>
00069 
00070     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
00071 
00072     <span class="keywordflow">if</span> (parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp;
00073             (<a class="code" href="../../d0/d5/io_8h.html#a138">DOE_UNLOAD_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a140">DOE_REMOVE_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a141">DOE_REMOVE_PROCESSED</a> | <a class="code" href="../../d0/d5/io_8h.html#a142">DOE_START_PENDING</a>) ||
00074         parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a128">DO_DEVICE_INITIALIZING</a>) {
00075 
00076         status = STATUS_NO_SUCH_DEVICE;
00077 
00078     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a124">DO_EXCLUSIVE</a> &amp;&amp;
00079                parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o2">ReferenceCount</a> != 0 &amp;&amp;
00080                op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
00081                !(op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o13">Options</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a111">IO_ATTACH_DEVICE</a>)) {
00082 
00083         status = STATUS_ACCESS_DENIED;
00084 
00085     } <span class="keywordflow">else</span> {
00086 
00087         parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o2">ReferenceCount</a>++;
00088         status = STATUS_SUCCESS;
00089 
00090     }
00091 
00092     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
00093 
00094     <span class="keywordflow">return</span> status;
00095 }
00096 
00097 <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a>
<a name="l00098"></a><a class="code" href="../../d4/d3/parse_8c.html#a4">00098</a> <a class="code" href="../../d4/d3/parse_8c.html#a4">IopCheckVpbMounted</a>(
00099     IN <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a> op,
00100     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> parseDeviceObject,
00101     IN OUT PUNICODE_STRING RemainingName,
00102     OUT PNTSTATUS status
00103     )
00104 {
00105     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb;
00106     KIRQL irql;
00107     BOOLEAN alertable;
00108 
00109     <span class="comment">//</span>
00110     <span class="comment">// Loop here until the VPB_MOUNTED test can be passed while holding the</span>
00111     <span class="comment">// VPB spinlock.  After the mount succeeds, it is still necessary to acquire</span>
00112     <span class="comment">// the spinlock to check that the VPB (which may be different from the one</span>
00113     <span class="comment">// before the mount) is still mounted.  If it is, then its reference count</span>
00114     <span class="comment">// is incremented before releasing the spinlock.</span>
00115     <span class="comment">//</span>
00116 
00117     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a>, &amp;irql );
00118 
00119     alertable = (op-&gt;CreateOptions &amp; FILE_SYNCHRONOUS_IO_ALERT) ? <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00120     <span class="keywordflow">while</span> (!(parseDeviceObject-&gt;Vpb-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a116">VPB_MOUNTED</a>)) {
00121 
00122         ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a>, irql );
00123 
00124         <span class="comment">//</span>
00125         <span class="comment">// Try to mount the volume, allowing only RAW to perform the mount if</span>
00126         <span class="comment">// this is a DASD open.</span>
00127         <span class="comment">//</span>
00128 
00129         *status = <a class="code" href="../../d0/d6/iop_8h.html#a195">IopMountVolume</a>( parseDeviceObject,
00130                                  (BOOLEAN) (!RemainingName-&gt;Length &amp;&amp; !op-&gt;RelatedFileObject),
00131                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00132                  alertable );
00133         <span class="comment">//</span>
00134         <span class="comment">// If the mount operation was unsuccessful, adjust the reference</span>
00135         <span class="comment">// count for the device and return now.</span>
00136         <span class="comment">//</span>
00137 
00138         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( *status ) || *status == STATUS_USER_APC || *status == STATUS_ALERTED) {
00139 
00140             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00141 
00142             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( *status )) {
00143                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00144             } <span class="keywordflow">else</span> {
00145                 *status = STATUS_WRONG_VOLUME;
00146                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00147             }
00148         }
00149 
00150         ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a>, &amp;irql );
00151     }
00152 
00153     <span class="comment">//</span>
00154     <span class="comment">// Synchronize here with the file system to make sure that volumes do not</span>
00155     <span class="comment">// go away while en route to the FS.</span>
00156     <span class="comment">//</span>
00157 
00158     vpb = parseDeviceObject-&gt;Vpb;
00159 
00160     <span class="comment">//</span>
00161     <span class="comment">//  Check here that the VPB is not locked.</span>
00162     <span class="comment">//</span>
00163 
00164     <span class="keywordflow">if</span> (vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o2">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a117">VPB_LOCKED</a>) {
00165 
00166         *status = STATUS_ACCESS_DENIED;
00167         vpb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00168 
00169     } <span class="keywordflow">else</span> {
00170 
00171         vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a> += 1;
00172     }
00173 
00174     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a>, irql );
00175 
00176     <span class="keywordflow">return</span> vpb;
00177 }
00178 
00179 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00180"></a><a class="code" href="../../d4/d3/parse_8c.html#a5">00180</a> <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(
00181     IN <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb
00182     )
00183 {
00184     KIRQL irql;
00185     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb = (<a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00186 
00187     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a>, &amp;irql );
00188     Vpb-&gt;ReferenceCount--;
00189     <span class="keywordflow">if</span> ((Vpb-&gt;ReferenceCount == 0) &amp;&amp;
00190         (Vpb-&gt;RealDevice-&gt;Vpb != Vpb) &amp;&amp;
00191         !(Vpb-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a118">VPB_PERSISTENT</a>)) {
00192         vpb = Vpb;
00193     }
00194     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a>, irql );
00195     <span class="keywordflow">if</span> (vpb) {
00196         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( vpb );
00197     }
00198 }
00199 
00200 
00201 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00202"></a><a class="code" href="../../d4/d3/parse_8c.html#a6">00202</a> <a class="code" href="../../d4/d3/parse_8c.html#a6">IopParseDevice</a>(
00203     IN PVOID ParseObject,
00204     IN PVOID ObjectType,
00205     IN <a class="code" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a> AccessState,
00206     IN KPROCESSOR_MODE AccessMode,
00207     IN ULONG Attributes,
00208     IN OUT PUNICODE_STRING CompleteName,
00209     IN OUT PUNICODE_STRING RemainingName,
00210     IN OUT PVOID Context OPTIONAL,
00211     IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
00212     OUT PVOID *Object
00213     )
00214 
00215 <span class="comment">/*++</span>
00216 <span class="comment"></span>
00217 <span class="comment">Routine Description:</span>
00218 <span class="comment"></span>
00219 <span class="comment">    This routine interfaces to the NT Object Manager.  It is invoked when</span>
00220 <span class="comment">    the object system is given the name of an entity to create or open and the</span>
00221 <span class="comment">    name translates to a device object.  This routine is specified as the parse</span>
00222 <span class="comment">    routine for all device objects.</span>
00223 <span class="comment"></span>
00224 <span class="comment">    In the normal case of an NtCreateFile, the user specifies either the name</span>
00225 <span class="comment">    of a device or of a file.  In the former situation, this routine is invoked</span>
00226 <span class="comment">    with a pointer to the device and a null ("") string.  For this case, the</span>
00227 <span class="comment">    routine simply allocates an IRP, fills it in, and passes it to the driver</span>
00228 <span class="comment">    for the device.  The driver will then perform whatever rudimentary functions</span>
00229 <span class="comment">    are necessary and will return a status code indicating whether an error was</span>
00230 <span class="comment">    incurred.  This status code is remembered in the Open Packet (OP).</span>
00231 <span class="comment"></span>
00232 <span class="comment">    In the latter situation, the name string to be opened/created is non-null.</span>
00233 <span class="comment">    That is, it contains the remainder of the pathname to the file that is to</span>
00234 <span class="comment">    be opened or created.  For this case, the routine allocates an IRP, fills</span>
00235 <span class="comment">    it in, and passes it to the driver for the device.  The driver may then</span>
00236 <span class="comment">    need to take further action or it may complete the request immediately.  If</span>
00237 <span class="comment">    it needs to perform some work asynchronously, then it can queue the request</span>
00238 <span class="comment">    and return a status of STATUS_PENDING.  This allows this routine and its</span>
00239 <span class="comment">    caller to return to the user so that he can continue.  Otherwise, the open/</span>
00240 <span class="comment">    create is basically finished.</span>
00241 <span class="comment"></span>
00242 <span class="comment">    If the driver supports symbolic links, then it is also possible for the</span>
00243 <span class="comment">    driver to return a new name.  This name will be returned to the Object</span>
00244 <span class="comment">    Manager as a new name to look up.  The parsing will then begin again from</span>
00245 <span class="comment">    the start.</span>
00246 <span class="comment"></span>
00247 <span class="comment">    It is also the responsibility of this routine to create a file object for</span>
00248 <span class="comment">    the file, if the name specifies a file.  The file object's address is</span>
00249 <span class="comment">    returned to the NtCreateFile service through the OP.</span>
00250 <span class="comment"></span>
00251 <span class="comment">Arguments:</span>
00252 <span class="comment"></span>
00253 <span class="comment">    ParseObject - Pointer to the device object the name translated into.</span>
00254 <span class="comment"></span>
00255 <span class="comment">    ObjectType - Type of the object being opened.</span>
00256 <span class="comment"></span>
00257 <span class="comment">    AccessState - Running security access state information for operation.</span>
00258 <span class="comment"></span>
00259 <span class="comment">    AccessMode - Access mode of the original caller.</span>
00260 <span class="comment"></span>
00261 <span class="comment">    Attributes - Attributes to be applied to the object.</span>
00262 <span class="comment"></span>
00263 <span class="comment">    CompleteName - Complete name of the object.</span>
00264 <span class="comment"></span>
00265 <span class="comment">    RemainingName - Remaining name of the object.</span>
00266 <span class="comment"></span>
00267 <span class="comment">    Context - Pointer to an Open Packet (OP) from NtCreateFile service.</span>
00268 <span class="comment"></span>
00269 <span class="comment">    SecurityQos - Optional security quality of service indicator.</span>
00270 <span class="comment"></span>
00271 <span class="comment">    Object - The address of a variable to receive the created file object, if</span>
00272 <span class="comment">        any.</span>
00273 <span class="comment"></span>
00274 <span class="comment">Return Value:</span>
00275 <span class="comment"></span>
00276 <span class="comment">    The function return value is one of the following:</span>
00277 <span class="comment"></span>
00278 <span class="comment">        a)  Success - This indicates that the function succeeded and the object</span>
00279 <span class="comment">            parameter contains the address of the created file object.</span>
00280 <span class="comment"></span>
00281 <span class="comment">        b)  Error - This indicates that the file was not found or created and</span>
00282 <span class="comment">            no file object was created.</span>
00283 <span class="comment"></span>
00284 <span class="comment">        c)  Reparse - This indicates that the remaining name string has been</span>
00285 <span class="comment">            replaced by a new name that is to be parsed.</span>
00286 <span class="comment"></span>
00287 <span class="comment">--*/</span>
00288 
00289 {
00290 
00291 <span class="preprocessor">#define COPY_ATTRIBUTES( n, b, s ) {                                    \</span>
00292 <span class="preprocessor">        (n)-&gt;CreationTime.QuadPart = (b)-&gt;CreationTime.QuadPart;        \</span>
00293 <span class="preprocessor">        (n)-&gt;LastAccessTime.QuadPart = (b)-&gt;LastAccessTime.QuadPart;    \</span>
00294 <span class="preprocessor">        (n)-&gt;LastWriteTime.QuadPart = (b)-&gt;LastWriteTime.QuadPart;      \</span>
00295 <span class="preprocessor">        (n)-&gt;ChangeTime.QuadPart = (b)-&gt;ChangeTime.QuadPart;            \</span>
00296 <span class="preprocessor">        (n)-&gt;AllocationSize.QuadPart = (s)-&gt;AllocationSize.QuadPart;    \</span>
00297 <span class="preprocessor">        (n)-&gt;EndOfFile.QuadPart = (s)-&gt;EndOfFile.QuadPart;              \</span>
00298 <span class="preprocessor">        (n)-&gt;FileAttributes = (b)-&gt;FileAttributes; }</span>
00299 <span class="preprocessor"></span>
00300     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00301     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00302     <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a> op;
00303     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00304     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00305     IO_STATUS_BLOCK ioStatus;
00306     <a class="code" href="../../d1/d5/struct__IO__SECURITY__CONTEXT.html">IO_SECURITY_CONTEXT</a> securityContext;
00307     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00308     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> parseDeviceObject;
00309     BOOLEAN directDeviceOpen;
00310     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb;
00311     ACCESS_MASK desiredAccess;
00312     <a class="code" href="../../d0/d1/struct__DUMMY__FILE__OBJECT.html">PDUMMY_FILE_OBJECT</a> localFileObject;
00313     BOOLEAN realFileObjectRequired;
00314     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> modeForPrivilegeCheck;
00315     ULONG retryCount = 0;
00316     BOOLEAN  relativeVolumeOpen = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;     <span class="comment">// True if opening a filesystem volume</span>
00317 
00318     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00319 
00320 reparse_loop:
00321 
00322     <span class="comment">//</span>
00323     <span class="comment">// Assume failure by setting the returned object pointer to NULL.</span>
00324     <span class="comment">//</span>
00325 
00326     *Object = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00327 
00328     <span class="comment">//</span>
00329     <span class="comment">// Get the address of the Open Packet (OP).</span>
00330     <span class="comment">//</span>
00331 
00332     op = Context;
00333 
00334     <span class="comment">//</span>
00335     <span class="comment">// Ensure that this routine is actually being invoked because someone is</span>
00336     <span class="comment">// attempting to open a device or a file through NtCreateFile.  This code</span>
00337     <span class="comment">// must be invoked from there (as opposed to some other random object</span>
00338     <span class="comment">// create or open routine).</span>
00339     <span class="comment">//</span>
00340 
00341     <span class="keywordflow">if</span> (op == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
00342         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a7">IO_TYPE_OPEN_PACKET</a> ||
00343         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o1">Size</a> != <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">OPEN_PACKET</a> )) {
00344 
00345         <span class="keywordflow">return</span> STATUS_OBJECT_TYPE_MISMATCH;
00346     }
00347 
00348     <span class="comment">//</span>
00349     <span class="comment">// Obtain a pointer to the parse object as a device object, which is the</span>
00350     <span class="comment">// actual type of the object anyway.</span>
00351     <span class="comment">//</span>
00352 
00353     parseDeviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) ParseObject;
00354 
00355     <span class="comment">//</span>
00356     <span class="comment">// If this is a relative open, then get the device on which the file</span>
00357     <span class="comment">// is really being opened from the related file object and use that for</span>
00358     <span class="comment">// the remainder of this function and for all operations performed on</span>
00359     <span class="comment">// the file object that is about to be created.</span>
00360     <span class="comment">//</span>
00361 
00362     <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>) {
00363         parseDeviceObject = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>;
00364     }
00365 
00366     <span class="comment">//</span>
00367     <span class="comment">// Make sure that the device and its driver are really there and they are</span>
00368     <span class="comment">// going to stay there.  The object itself cannot go away just yet because</span>
00369     <span class="comment">// the object management system has performed a reference which bumps the</span>
00370     <span class="comment">// count of the number of reasons why the object must stick around.</span>
00371     <span class="comment">// However, the driver could be attempting to unload itself, so perform</span>
00372     <span class="comment">// this check.  If the driver is being unloaded, then set the final status</span>
00373     <span class="comment">// of the operation to "No such device" and return with a NULL file object</span>
00374     <span class="comment">// pointer.</span>
00375     <span class="comment">//</span>
00376     <span class="comment">// Note that it is possible to "open" an exclusive device more than once</span>
00377     <span class="comment">// provided that the caller is performing a relative open.  This feature</span>
00378     <span class="comment">// is how users "allocate" a device, and then use it to perform operations.</span>
00379     <span class="comment">//</span>
00380 
00381     status = <a class="code" href="../../d4/d3/parse_8c.html#a3">IopCheckDeviceAndDriver</a>( op, parseDeviceObject );
00382 
00383     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00384         <span class="keywordflow">return</span> op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = status;
00385     }
00386 
00387     <span class="comment">//</span>
00388     <span class="comment">// Since ObOpenObjectByName is called without being passed</span>
00389     <span class="comment">// any object type information, we need to map the generic</span>
00390     <span class="comment">// bits in the DesiredAccess mask here.  We also need to save</span>
00391     <span class="comment">// the object's generic mapping in the access state structure</span>
00392     <span class="comment">// here, because this is the earliest opportunity we have</span>
00393     <span class="comment">// to do so.</span>
00394     <span class="comment">//</span>
00395 
00396     <a class="code" href="../../d8/d6/sertl_8c.html#a70">RtlMapGenericMask</a>( &amp;AccessState-&gt;RemainingDesiredAccess,
00397                        &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a> );
00398 
00399     <a class="code" href="../../d8/d6/sertl_8c.html#a70">RtlMapGenericMask</a>( &amp;AccessState-&gt;OriginalDesiredAccess,
00400                        &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a> );
00401 
00402     <a class="code" href="../../d2/d5/seastate_8c.html#a4">SeSetAccessStateGenericMapping</a>( AccessState, &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a> );
00403 
00404     desiredAccess = AccessState-&gt;RemainingDesiredAccess;
00405 
00406     <span class="comment">//</span>
00407     <span class="comment">// Compute the previous mode to be passed in to the privilege check</span>
00408     <span class="comment">//</span>
00409 
00410     <span class="keywordflow">if</span> (AccessMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> || op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o13">Options</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a104">IO_FORCE_ACCESS_CHECK</a>) {
00411         modeForPrivilegeCheck = <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>;
00412     } <span class="keywordflow">else</span> {
00413         modeForPrivilegeCheck = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
00414     }
00415 
00416     <a class="code" href="../../d4/d3/parse_8c.html#a9">IopCheckBackupRestorePrivilege</a>( AccessState,
00417                                     &amp;op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a>,
00418                                     modeForPrivilegeCheck,
00419                                     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o14">Disposition</a>
00420                                     );
00421 
00422     <span class="comment">//</span>
00423     <span class="comment">// If this is not the first time through here for this object, and the</span>
00424     <span class="comment">// object itself is being opened, then the desired access must also</span>
00425     <span class="comment">// include the previously granted access from the last pass.  Likewise,</span>
00426     <span class="comment">// if the privileges have been checked already, then this is another</span>
00427     <span class="comment">// pass through for a file, so add in the previously granted access.</span>
00428     <span class="comment">//</span>
00429 
00430     <span class="keywordflow">if</span> ((op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o19">Override</a> &amp;&amp; !RemainingName-&gt;Length) ||
00431         AccessState-&gt;Flags &amp; <a class="code" href="../../d0/d5/se_8h.html#a6">SE_BACKUP_PRIVILEGES_CHECKED</a>) {
00432         desiredAccess |= AccessState-&gt;PreviouslyGrantedAccess;
00433     }
00434 
00435     <span class="comment">//</span>
00436     <span class="comment">// If its a filesystem volume open and we are doing a relative open to it</span>
00437     <span class="comment">// then do the access check. Note that relative opens can be nested and we propagate</span>
00438     <span class="comment">// the fact that the relative open is for a volume using the FO_VOLUME_OPEN flag.</span>
00439     <span class="comment">//</span>
00440 
00441     <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>) {
00442         <span class="keywordflow">if</span> ((op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a172">FO_VOLUME_OPEN</a>) &amp;&amp; RemainingName-&gt;Length == 0) {
00443             relativeVolumeOpen = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00444         }
00445     }
00446 
00447     <span class="comment">//</span>
00448     <span class="comment">// Now determine what type of security check should be made.  This is</span>
00449     <span class="comment">// based on whether the remaining name string is null.  If it is null,</span>
00450     <span class="comment">// then the device itself is being opened, so a full security check is</span>
00451     <span class="comment">// performed.  Otherwise, only a check to ensure that the caller can</span>
00452     <span class="comment">// traverse the device object is made.  Note that these checks are only</span>
00453     <span class="comment">// made if the caller's mode is user, or if access checking is being</span>
00454     <span class="comment">// forced.  Note also that if an access check was already made on the</span>
00455     <span class="comment">// device itself, and this code is being executed again because of a</span>
00456     <span class="comment">// reparse, then the access check need not be made the second time</span>
00457     <span class="comment">// around.</span>
00458     <span class="comment">//</span>
00459 
00460 
00461     <span class="keywordflow">if</span> ((AccessMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> || op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o13">Options</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a104">IO_FORCE_ACCESS_CHECK</a>) &amp;&amp;
00462         (!op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> || relativeVolumeOpen) &amp;&amp;
00463         !op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o19">Override</a>) {
00464 
00465         BOOLEAN subjectContextLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00466         BOOLEAN accessGranted;
00467         ACCESS_MASK grantedAccess;
00468 
00469         <span class="comment">//</span>
00470         <span class="comment">// The caller's mode is either user or access checking is being</span>
00471         <span class="comment">// forced.  Perform the appropriate access check on the device</span>
00472         <span class="comment">// object.</span>
00473         <span class="comment">//</span>
00474 
00475         <span class="keywordflow">if</span> (!RemainingName-&gt;Length) {
00476 
00477             UNICODE_STRING nameString;
00478             PPRIVILEGE_SET privileges = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00479 
00480             <span class="comment">//</span>
00481             <span class="comment">// The device itself is being opened.  Make a full security check</span>
00482             <span class="comment">// to ensure that the caller has the appropriate access.</span>
00483             <span class="comment">//</span>
00484 
00485             <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>( );
00486             <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00487 
00488             <a class="code" href="../../d0/d8/subject_8c.html#a1">SeLockSubjectContext</a>( &amp;AccessState-&gt;SubjectSecurityContext );
00489             subjectContextLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00490 
00491             accessGranted = <a class="code" href="../../d0/d4/accessck_8c.html#a18">SeAccessCheck</a>( parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00492                                            &amp;AccessState-&gt;SubjectSecurityContext,
00493                                            subjectContextLocked,
00494                                            desiredAccess,
00495                                            0,
00496                                            &amp;privileges,
00497                                            &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a>,
00498                                            <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>,
00499                                            &amp;grantedAccess,
00500                                            &amp;status );
00501 
00502             <span class="keywordflow">if</span> (privileges) {
00503                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d5/seastate_8c.html#a5">SeAppendPrivileges</a>( AccessState,
00504                                            privileges );
00505                 <a class="code" href="../../d0/d4/accessck_8c.html#a17">SeFreePrivileges</a>( privileges );
00506             }
00507 
00508             <span class="keywordflow">if</span> (accessGranted) {
00509                 AccessState-&gt;PreviouslyGrantedAccess |= grantedAccess;
00510                 AccessState-&gt;RemainingDesiredAccess &amp;= ~( grantedAccess | MAXIMUM_ALLOWED );
00511                 op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o19">Override</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00512             }
00513 
00514             nameString.Length = 8;
00515             nameString.MaximumLength = 8;
00516             nameString.Buffer = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"File"</span>;
00517 
00518             <a class="code" href="../../d3/d5/seaudit_8c.html#a23">SeOpenObjectAuditAlarm</a>( &amp;nameString,
00519                                     parseDeviceObject,
00520                                     CompleteName,
00521                                     parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00522                                     AccessState,
00523                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00524                                     accessGranted,
00525                                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>,
00526                                     &amp;AccessState-&gt;GenerateOnClose );
00527 
00528             <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a> );
00529             <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00530 
00531         } <span class="keywordflow">else</span> {
00532 
00533             <span class="comment">//</span>
00534             <span class="comment">// The device is not being opened, rather, a file on the device</span>
00535             <span class="comment">// is being opened or created.  Therefore, only perform a check</span>
00536             <span class="comment">// here for traverse access to the device.</span>
00537             <span class="comment">//</span>
00538 
00539             <span class="comment">//</span>
00540             <span class="comment">// First determine if we have to perform traverse checking at all.</span>
00541             <span class="comment">// Traverse checking only needs to be done if the device being</span>
00542             <span class="comment">// traversed is a disk, or if the caller does not already have</span>
00543             <span class="comment">// traverse checking privilege.  Note that the former case is so</span>
00544             <span class="comment">// that an administrator can turn off access to the "system</span>
00545             <span class="comment">// partition", or someone would be able to install a trojan horse</span>
00546             <span class="comment">// into the system by simply replacing one of the files there with</span>
00547             <span class="comment">// something of their own.</span>
00548             <span class="comment">//</span>
00549 
00550             <span class="keywordflow">if</span> (!(AccessState-&gt;Flags &amp; <a class="code" href="../../d0/d5/se_8h.html#a1">TOKEN_HAS_TRAVERSE_PRIVILEGE</a>) ||
00551                 parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_DISK ||
00552                 parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ) {
00553 
00554                 <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>( );
00555                 <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00556 
00557                 <span class="comment">//</span>
00558                 <span class="comment">// If the token is restricted we need to do the full</span>
00559                 <span class="comment">// access check.</span>
00560                 <span class="comment">//</span>
00561 
00562                 <span class="keywordflow">if</span> ((AccessState-&gt;Flags &amp; <a class="code" href="../../d0/d5/se_8h.html#a5">TOKEN_IS_RESTRICTED</a>) == 0) {
00563                     accessGranted = <a class="code" href="../../d0/d4/accessck_8c.html#a22">SeFastTraverseCheck</a>( parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00564                                                          FILE_TRAVERSE,
00565                                                          <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a> );
00566                 } <span class="keywordflow">else</span> {
00567                     accessGranted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00568                 }
00569 
00570                 <span class="keywordflow">if</span> (!accessGranted) {
00571 
00572                     PPRIVILEGE_SET privileges = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00573 
00574                     <span class="comment">//</span>
00575                     <span class="comment">// The caller was not granted traverse access through the</span>
00576                     <span class="comment">// normal fast path lookup.  Perform a full-blown access</span>
00577                     <span class="comment">// check to determine whether some other ACE allows traverse</span>
00578                     <span class="comment">// access.</span>
00579                     <span class="comment">//</span>
00580 
00581                     <a class="code" href="../../d0/d8/subject_8c.html#a1">SeLockSubjectContext</a>( &amp;AccessState-&gt;SubjectSecurityContext );
00582 
00583                     subjectContextLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00584 
00585                     accessGranted = <a class="code" href="../../d0/d4/accessck_8c.html#a18">SeAccessCheck</a>( parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00586                                                    &amp;AccessState-&gt;SubjectSecurityContext,
00587                                                    subjectContextLocked,
00588                                                    FILE_TRAVERSE,
00589                                                    0,
00590                                                    &amp;privileges,
00591                                                    &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a>,
00592                                                    <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>,
00593                                                    &amp;grantedAccess,
00594                                                    &amp;status );
00595 
00596                     <span class="keywordflow">if</span> (privileges) {
00597 
00598                         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d5/seastate_8c.html#a5">SeAppendPrivileges</a>( AccessState,
00599                                                    privileges );
00600                         <a class="code" href="../../d0/d4/accessck_8c.html#a17">SeFreePrivileges</a>( privileges );
00601                     }
00602 
00603                 }
00604 
00605                 <span class="comment">//</span>
00606                 <span class="comment">// Perform the traverse audit alarm if necessary.</span>
00607                 <span class="comment">//</span>
00608 
00609                 <a class="code" href="../../d3/d5/seaudit_8c.html#a25">SeTraverseAuditAlarm</a>( &amp;AccessState-&gt;OperationID,
00610                                       parseDeviceObject,
00611                                       parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00612                                       &amp;AccessState-&gt;SubjectSecurityContext,
00613                                       subjectContextLocked,
00614                                       FILE_TRAVERSE,
00615                                       (PPRIVILEGE_SET) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00616                                       accessGranted,
00617                                       <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a> );
00618                 <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a> );
00619                 <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00620 
00621             } <span class="keywordflow">else</span> {
00622 
00623                     accessGranted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00624             }
00625         }
00626 
00627         <span class="comment">//</span>
00628         <span class="comment">// Unlock the subject's security context so that it can be changed,</span>
00629         <span class="comment">// if it was locked.</span>
00630         <span class="comment">//</span>
00631 
00632         <span class="keywordflow">if</span> (subjectContextLocked) {
00633             <a class="code" href="../../d0/d8/subject_8c.html#a2">SeUnlockSubjectContext</a>( &amp;AccessState-&gt;SubjectSecurityContext );
00634         }
00635 
00636         <span class="comment">//</span>
00637         <span class="comment">// Finally, determine whether or not access was granted to the device.</span>
00638         <span class="comment">// If not, clean everything up and get out now without even invoking</span>
00639         <span class="comment">// the device driver.</span>
00640         <span class="comment">//</span>
00641 
00642         <span class="keywordflow">if</span> (!accessGranted) {
00643 
00644             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00645             <span class="keywordflow">return</span> STATUS_ACCESS_DENIED;
00646         }
00647 
00648     }
00649 
00650     realFileObjectRequired = !(op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o20">QueryOnly</a> || op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o21">DeleteOnly</a>);
00651 
00652     <span class="keywordflow">if</span> (RemainingName-&gt;Length == 0 &amp;&amp;
00653         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
00654         ((desiredAccess &amp; ~(SYNCHRONIZE |
00655                             FILE_READ_ATTRIBUTES |
00656                             READ_CONTROL |
00657                             ACCESS_SYSTEM_SECURITY |
00658                             WRITE_OWNER |
00659                             WRITE_DAC)) == 0) &amp;&amp;
00660         realFileObjectRequired) {
00661 
00662         <span class="comment">//</span>
00663         <span class="comment">// If the name of the object being opened is just the name of the</span>
00664         <span class="comment">// device itself, and there is no related file object, and the caller</span>
00665         <span class="comment">// is opening the device for only read attributes access, then this</span>
00666         <span class="comment">// device will not be mounted.  This allows applications to obtain</span>
00667         <span class="comment">// attributes about the device without actually mounting it.</span>
00668         <span class="comment">//</span>
00669         <span class="comment">// Note that if this *is* a direct device open, then the normal path</span>
00670         <span class="comment">// through the I/O system and drivers may never be used, even if</span>
00671         <span class="comment">// the device appears to be mounted.  This is because the user may</span>
00672         <span class="comment">// remove the media from the drive (even though it is mounted), and</span>
00673         <span class="comment">// now attempting to determine what type of drive it is will still</span>
00674         <span class="comment">// fail, this time very hard, because a whole mount process is now</span>
00675         <span class="comment">// required, thus defeating this feature.</span>
00676         <span class="comment">//</span>
00677 
00678         directDeviceOpen = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00679 
00680     } <span class="keywordflow">else</span> {
00681 
00682         <span class="comment">//</span>
00683         <span class="comment">// Otherwise, this is a normal open of a file, directory, device, or</span>
00684         <span class="comment">// volume.</span>
00685         <span class="comment">//</span>
00686 
00687         directDeviceOpen = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00688     }
00689 
00690     <span class="comment">//</span>
00691     <span class="comment">// There are now five different cases.  These are as follows:</span>
00692     <span class="comment">//</span>
00693     <span class="comment">//    1)  This is a relative open, in which case we want to send the</span>
00694     <span class="comment">//        request to then same device that opened the relative file object.</span>
00695     <span class="comment">//</span>
00696     <span class="comment">//    2)  The VPB pointer in the device object is NULL.  This means that</span>
00697     <span class="comment">//        this device does not support a file system.  This includes</span>
00698     <span class="comment">//        devices such as terminals, etc.</span>
00699     <span class="comment">//</span>
00700     <span class="comment">//    3)  The VPB pointer in the device object is not NULL and:</span>
00701     <span class="comment">//</span>
00702     <span class="comment">//        a)  The VPB is "blank".  That is, the VPB has never been filled</span>
00703     <span class="comment">//            in, which means that the device has never been mounted.</span>
00704     <span class="comment">//</span>
00705     <span class="comment">//        b)  The VPB is non-blank, but the verify flag on the device is</span>
00706     <span class="comment">//            set, indicating that the door to the drive may have been</span>
00707     <span class="comment">//            opened and the media may therefore have been changed.</span>
00708     <span class="comment">//</span>
00709     <span class="comment">//        c)  The VPB is non-blank and the verify flag is not set.</span>
00710     <span class="comment">//</span>
00711     <span class="comment">//        Both of the latter are not explicitly checked for, as #c is</span>
00712     <span class="comment">//        the normal case, and #b is the responsibility of the file</span>
00713     <span class="comment">//        system to check.</span>
00714     <span class="comment">//</span>
00715 
00716     <span class="comment">//</span>
00717     <span class="comment">//  If this is a file system that supports volumes, vpbRefCount will</span>
00718     <span class="comment">//  be filled in to point to the reference count in the Vpb.  Error</span>
00719     <span class="comment">//  exits paths later on key off this value to see if they should</span>
00720     <span class="comment">//  decrement the ref count.  Note that a direct device open does not</span>
00721     <span class="comment">//  make it to the file system, so no increment is needed, and no</span>
00722     <span class="comment">//  decrement will be performed in objsup.c IopDeleteFile().</span>
00723     <span class="comment">//</span>
00724 
00725     vpb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00726 
00727     <span class="comment">//</span>
00728     <span class="comment">// If the related open was a direct device open then we should go through the full mount </span>
00729     <span class="comment">// path for this open as this may not be a direct device open.</span>
00730     <span class="comment">//</span>
00731     <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> &amp;&amp; (!(op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>))) {
00732 
00733         deviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>)ParseObject;
00734 
00735         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o3">Vpb</a>) {
00736 
00737             vpb = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o3">Vpb</a>;
00738 
00739             <span class="comment">//</span>
00740             <span class="comment">// Synchronize here with the file system to make sure that</span>
00741             <span class="comment">// volumes don't go away while en route to the FS.</span>
00742             <span class="comment">//</span>
00743 
00744             <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a>, 1, &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a> );
00745         }
00746 
00747     } <span class="keywordflow">else</span> {
00748 
00749         deviceObject = parseDeviceObject;
00750 
00751         <span class="keywordflow">if</span> (parseDeviceObject-&gt;Vpb &amp;&amp; !directDeviceOpen) {
00752             vpb = <a class="code" href="../../d4/d3/parse_8c.html#a4">IopCheckVpbMounted</a>( op,
00753                                       parseDeviceObject,
00754                                       RemainingName,
00755                                       &amp;status );
00756             <span class="keywordflow">if</span> ( !vpb ) {
00757                 <span class="keywordflow">return</span> status;
00758             }
00759 
00760             <span class="comment">//</span>
00761             <span class="comment">// Set the address of the device object associated with the VPB.</span>
00762             <span class="comment">//</span>
00763 
00764             deviceObject = vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a>;
00765         }
00766 
00767         <span class="comment">//</span>
00768         <span class="comment">// Walk the attached device list.</span>
00769         <span class="comment">//</span>
00770 
00771         <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>) {
00772             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( deviceObject );
00773         }
00774     }
00775 
00776     <span class="comment">//</span>
00777     <span class="comment">//  If the driver says that the IO manager should do the access checks, lets do it here.</span>
00778     <span class="comment">//  We do the check against the parse device object as that device object has a name</span>
00779     <span class="comment">//  and we can set an ACL against it.</span>
00780     <span class="comment">//  We only worry about related opens of devices as the other case is taken care of in the</span>
00781     <span class="comment">//  filesystem.</span>
00782     <span class="comment">//</span>
00783     <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o9">Characteristics</a> &amp; FILE_DEVICE_SECURE_OPEN) &amp;&amp;
00784         (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> || RemainingName-&gt;Length) &amp;&amp;  (!relativeVolumeOpen)) {
00785 
00786         BOOLEAN subjectContextLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00787         BOOLEAN accessGranted;
00788         ACCESS_MASK grantedAccess;
00789         UNICODE_STRING nameString;
00790         PPRIVILEGE_SET privileges = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00791 
00792         <span class="comment">//</span>
00793         <span class="comment">// If the device wants to ensure secure opens then lets check the two</span>
00794         <span class="comment">// cases which were skipped earlier. These cases are if its a relative</span>
00795         <span class="comment">// open or if there are trailing names.</span>
00796         <span class="comment">//</span>
00797 
00798         <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>( );
00799         <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00800 
00801         <a class="code" href="../../d0/d8/subject_8c.html#a1">SeLockSubjectContext</a>( &amp;AccessState-&gt;SubjectSecurityContext );
00802         subjectContextLocked = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00803 
00804         accessGranted = <a class="code" href="../../d0/d4/accessck_8c.html#a18">SeAccessCheck</a>( parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00805                                        &amp;AccessState-&gt;SubjectSecurityContext,
00806                                        subjectContextLocked,
00807                                        desiredAccess,
00808                                        0,
00809                                        &amp;privileges,
00810                                        &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a>,
00811                                        <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>,
00812                                        &amp;grantedAccess,
00813                                        &amp;status );
00814 
00815         <span class="keywordflow">if</span> (privileges) {
00816             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d5/seastate_8c.html#a5">SeAppendPrivileges</a>( AccessState,
00817                                        privileges );
00818             <a class="code" href="../../d0/d4/accessck_8c.html#a17">SeFreePrivileges</a>( privileges );
00819         }
00820 
00821         <span class="keywordflow">if</span> (accessGranted) {
00822             AccessState-&gt;PreviouslyGrantedAccess |= grantedAccess;
00823             AccessState-&gt;RemainingDesiredAccess &amp;= ~( grantedAccess | MAXIMUM_ALLOWED );
00824         }
00825 
00826         nameString.Length = 8;
00827         nameString.MaximumLength = 8;
00828         nameString.Buffer = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"File"</span>;
00829 
00830         <a class="code" href="../../d3/d5/seaudit_8c.html#a23">SeOpenObjectAuditAlarm</a>( &amp;nameString,
00831                                 deviceObject,
00832                                 CompleteName,
00833                                 parseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a>,
00834                                 AccessState,
00835                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00836                                 accessGranted,
00837                                 <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>,
00838                                 &amp;AccessState-&gt;GenerateOnClose );
00839 
00840         <a class="code" href="../../d0/d8/subject_8c.html#a2">SeUnlockSubjectContext</a>( &amp;AccessState-&gt;SubjectSecurityContext );
00841         <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a5">IopSecurityResource</a> );
00842         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00843 
00844         <span class="keywordflow">if</span> (!accessGranted) {
00845             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00846 
00847             <span class="keywordflow">if</span> (vpb) {
00848                 <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
00849             }
00850             <span class="keywordflow">return</span> STATUS_ACCESS_DENIED;
00851         }
00852     }
00853 
00854     <span class="comment">//</span>
00855     <span class="comment">// Allocate and fill in the I/O Request Packet (IRP) to use in interfacing</span>
00856     <span class="comment">// to the driver.  The allocation is done using an exception handler in</span>
00857     <span class="comment">// case the caller does not have enough quota to allocate the packet.</span>
00858     <span class="comment">//</span>
00859 
00860     irp = <a class="code" href="../../d0/d6/iop_8h.html#a16">IopAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00861     <span class="keywordflow">if</span> (!irp) {
00862 
00863         <span class="comment">//</span>
00864         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
00865         <span class="comment">// error status code.</span>
00866         <span class="comment">//</span>
00867 
00868         <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00869 
00870         <span class="keywordflow">if</span> (vpb) {
00871             <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
00872         }
00873         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00874     }
00875     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00876     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = AccessMode;
00877     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a182">IRP_CREATE_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a> | <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
00878 
00879     securityContext.<a class="code" href="../../d1/d5/struct__IO__SECURITY__CONTEXT.html#o0">SecurityQos</a> = <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a14">SecurityQos</a>;
00880     securityContext.<a class="code" href="../../d1/d5/struct__IO__SECURITY__CONTEXT.html#o1">AccessState</a> = AccessState;
00881     securityContext.<a class="code" href="../../d1/d5/struct__IO__SECURITY__CONTEXT.html#o2">DesiredAccess</a> = desiredAccess;
00882     securityContext.<a class="code" href="../../d1/d5/struct__IO__SECURITY__CONTEXT.html#o3">FullCreateOptions</a> = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a>;
00883 
00884     <span class="comment">//</span>
00885     <span class="comment">// Get a pointer to the stack location for the first driver.  This is where</span>
00886     <span class="comment">// the original function codes and parameters are passed.</span>
00887     <span class="comment">//</span>
00888 
00889     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00890     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> = 0;
00891 
00892     <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o17">CreateFileType</a> == <a class="code" href="../../d0/d5/io_8h.html#a600a406">CreateFileTypeNone</a>) {
00893 
00894         <span class="comment">//</span>
00895         <span class="comment">// This is a normal file open or create function.</span>
00896         <span class="comment">//</span>
00897 
00898         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a13">IRP_MJ_CREATE</a>;
00899         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Create.EaLength = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o12">EaLength</a>;
00900         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = (UCHAR) op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o13">Options</a>;
00901         <span class="keywordflow">if</span> (!(Attributes &amp; OBJ_CASE_INSENSITIVE)) {
00902             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a201">SL_CASE_SENSITIVE</a>;
00903         }
00904 
00905     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o17">CreateFileType</a> == <a class="code" href="../../d0/d5/io_8h.html#a600a407">CreateFileTypeNamedPipe</a>) {
00906 
00907         <span class="comment">//</span>
00908         <span class="comment">// A named pipe is being created.</span>
00909         <span class="comment">//</span>
00910 
00911         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a14">IRP_MJ_CREATE_NAMED_PIPE</a>;
00912         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.CreatePipe.Parameters = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o18">ExtraCreateParameters</a>;
00913 
00914     } <span class="keywordflow">else</span> {
00915 
00916         <span class="comment">//</span>
00917         <span class="comment">// A mailslot is being created.</span>
00918         <span class="comment">//</span>
00919 
00920         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a32">IRP_MJ_CREATE_MAILSLOT</a>;
00921         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.CreateMailslot.Parameters = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o18">ExtraCreateParameters</a>;
00922     }
00923 
00924     <span class="comment">//</span>
00925     <span class="comment">// Also fill in the NtCreateFile service's caller's parameters.</span>
00926     <span class="comment">//</span>
00927 
00928     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AllocationSize = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o7">AllocationSize</a>;
00929     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a>;
00930     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Create.Options = (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o14">Disposition</a> &lt;&lt; 24) | (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; 0x00ffffff);
00931     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Create.FileAttributes = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o9">FileAttributes</a>;
00932     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Create.ShareAccess = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o10">ShareAccess</a>;
00933     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Create.SecurityContext = &amp;securityContext;
00934 
00935     <span class="comment">//</span>
00936     <span class="comment">// Fill in local parameters so this routine can determine when the I/O is</span>
00937     <span class="comment">// finished, and the normal I/O completion code will not get any errors.</span>
00938     <span class="comment">//</span>
00939 
00940     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;ioStatus;
00941     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00942     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00943     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00944     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00945     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> = (<a class="code" href="../../d0/d5/io_8h.html#a286">PDRIVER_CANCEL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00946     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00947 
00948     <span class="comment">//</span>
00949     <span class="comment">// Allocate and initialize the file object that will be used in dealing</span>
00950     <span class="comment">// with the device for the remainder of this session with the user.  How</span>
00951     <span class="comment">// the file object is allocated is based on whether or not a real file</span>
00952     <span class="comment">// object is actually required.  It is not required for the query and</span>
00953     <span class="comment">// delete only operations.</span>
00954     <span class="comment">//</span>
00955 
00956     <span class="keywordflow">if</span> (realFileObjectRequired) {
00957 
00958         OBJECT_ATTRIBUTES objectAttributes;
00959 
00960         <span class="comment">//</span>
00961         <span class="comment">// A real, full-blown file object is actually required.</span>
00962         <span class="comment">//</span>
00963 
00964         InitializeObjectAttributes( &amp;objectAttributes,
00965                                     (PUNICODE_STRING) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00966                                     Attributes,
00967                                     (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00968                                     (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00969                                   );
00970 
00971         status = <a class="code" href="../../d6/d0/obcreate_8c.html#a5">ObCreateObject</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00972                                  <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
00973                                  &amp;objectAttributes,
00974                                  AccessMode,
00975                                  (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00976                                  (ULONG) <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">FILE_OBJECT</a> ),
00977                                  0,
00978                                  0,
00979                                  (PVOID *) &amp;fileObject );
00980 
00981         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00982             <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
00983 
00984             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00985 
00986             <span class="keywordflow">if</span> (vpb) {
00987                <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
00988             }
00989             <span class="keywordflow">return</span> op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = status;
00990         }
00991 
00992         RtlZeroMemory( fileObject, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a353">FILE_OBJECT</a> ) );
00993         fileObject-&gt;Type = <a class="code" href="../../d0/d5/io_8h.html#a4">IO_TYPE_FILE</a>;
00994         fileObject-&gt;Size = <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a353">FILE_OBJECT</a> );
00995         fileObject-&gt;RelatedFileObject = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>;
00996         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) {
00997             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>;
00998             <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; FILE_SYNCHRONOUS_IO_ALERT) {
00999                 fileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>;
01000             }
01001         }
01002 
01003         <span class="comment">//</span>
01004         <span class="comment">// Now fill in the file object as best is possible at this point and set</span>
01005         <span class="comment">// a pointer to it in the IRP so everyone else can find it.</span>
01006         <span class="comment">//</span>
01007 
01008         <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
01009             <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;fileObject-&gt;Lock, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01010             fileObject-&gt;Waiters = 0;
01011             fileObject-&gt;CurrentByteOffset.QuadPart = 0;
01012         }
01013         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; FILE_NO_INTERMEDIATE_BUFFERING) {
01014             fileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>;
01015         }
01016         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; FILE_WRITE_THROUGH) {
01017             fileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>;
01018         }
01019         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; FILE_SEQUENTIAL_ONLY) {
01020             fileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a155">FO_SEQUENTIAL_ONLY</a>;
01021         }
01022         <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> &amp; FILE_RANDOM_ACCESS) {
01023             fileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a170">FO_RANDOM_ACCESS</a>;
01024         }
01025 
01026     } <span class="keywordflow">else</span> {
01027 
01028         <span class="comment">//</span>
01029         <span class="comment">// This is either a quick delete or query operation.  For these cases,</span>
01030         <span class="comment">// it is possible to optimize the Object Manager out of the picture by</span>
01031         <span class="comment">// simply putting together something that "looks" like a file object,</span>
01032         <span class="comment">// and then operating on it.</span>
01033         <span class="comment">//</span>
01034 
01035         localFileObject = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o23">LocalFileObject</a>;
01036         RtlZeroMemory( localFileObject, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d1/struct__DUMMY__FILE__OBJECT.html">DUMMY_FILE_OBJECT</a> ) );
01037         fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) &amp;localFileObject-&gt;<a class="code" href="../../d0/d1/struct__DUMMY__FILE__OBJECT.html#o0">ObjectHeader</a>.<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o11">Body</a>;
01038         localFileObject-&gt;<a class="code" href="../../d0/d1/struct__DUMMY__FILE__OBJECT.html#o0">ObjectHeader</a>.<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a> = <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>;
01039         localFileObject-&gt;<a class="code" href="../../d0/d1/struct__DUMMY__FILE__OBJECT.html#o0">ObjectHeader</a>.<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o0">PointerCount</a> = 1;
01040     }
01041 
01042     <span class="keywordflow">if</span> (directDeviceOpen) {
01043         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>;
01044     }
01045     <span class="keywordflow">if</span> (!(Attributes &amp; OBJ_CASE_INSENSITIVE)) {
01046         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a167">FO_OPENED_CASE_SENSITIVE</a>;
01047     }
01048 
01049     fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a4">IO_TYPE_FILE</a>;
01050     fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o1">Size</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">FILE_OBJECT</a> );
01051     fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o9">RelatedFileObject</a> = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a>;
01052     fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> = parseDeviceObject;
01053 
01054     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
01055     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
01056 
01057     <span class="comment">//</span>
01058     <span class="comment">// Allocate a file name string buffer which is large enough to contain</span>
01059     <span class="comment">// the entire remaining name string and initialize the maximum length.</span>
01060     <span class="comment">//</span>
01061 
01062     <span class="keywordflow">if</span> (RemainingName-&gt;Length) {
01063         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.MaximumLength = <a class="code" href="../../d4/d3/parse_8c.html#a0">RoundNameSize</a>( RemainingName-&gt;Length );
01064         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01065                                                              fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.MaximumLength,
01066                                                              'mNoI' );
01067         <span class="keywordflow">if</span> (!fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer) {
01068             <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01069 
01070             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01071 
01072             <span class="keywordflow">if</span> (vpb) {
01073                <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
01074             }
01075             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01076             <span class="keywordflow">if</span> (realFileObjectRequired) {
01077                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01078             }
01079             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01080         }
01081     }
01082 
01083     <span class="comment">//</span>
01084     <span class="comment">// Now copy the name string into the file object from the remaining name</span>
01085     <span class="comment">// that is being reparsed.  If the driver decides to reparse, then it must</span>
01086     <span class="comment">// replace this name.</span>
01087     <span class="comment">//</span>
01088 
01089     <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>, RemainingName );
01090 
01091     <span class="comment">//</span>
01092     <span class="comment">// Before invoking the driver's open routine, check to see whether or not</span>
01093     <span class="comment">// this is a fast network attributes query and, if so, and the driver</span>
01094     <span class="comment">// implements the function, attempt to call it here.</span>
01095     <span class="comment">//</span>
01096 
01097     <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o20">QueryOnly</a>) {
01098         <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
01099         BOOLEAN result;
01100 
01101         <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp;
01102             fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o0">SizeOfFastIoDispatch</a> &gt; FIELD_OFFSET( <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">FAST_IO_DISPATCH</a>, FastIoQueryOpen ) &amp;&amp;
01103             fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o24">FastIoQueryOpen</a>) {
01104 
01105             <a class="code" href="../../d0/d5/io_8h.html#a238">IoSetNextIrpStackLocation</a>( irp );
01106             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a> = deviceObject;
01107             result = (fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o24">FastIoQueryOpen</a>)( irp,
01108                                                         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o16">NetworkInformation</a>,
01109                                                         deviceObject );
01110             <span class="keywordflow">if</span> (result) {
01111                 op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status;
01112                 op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o4">Information</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information;
01113 
01114                 <span class="comment">//</span>
01115                 <span class="comment">// The operation worked, so simply dereference and free the</span>
01116                 <span class="comment">// resources acquired up to this point.</span>
01117                 <span class="comment">//</span>
01118 
01119                 <span class="keywordflow">if</span> ((op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> == STATUS_REPARSE) &amp;&amp;
01120                     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer) {
01121                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o4">Information</a> &gt; IO_REPARSE_TAG_RESERVED_ONE );
01122                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer );
01123                     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01124                     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01125                 }
01126 
01127                 <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length) {
01128                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer );
01129                 }
01130 
01131                 <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01132 
01133                 <span class="keywordflow">if</span> (vpb) {
01134                     <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
01135                 }
01136 
01137 <span class="preprocessor">#if DBG</span>
01138 <span class="preprocessor"></span>                irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 2;
01139 <span class="preprocessor">#endif // DBG</span>
01140 <span class="preprocessor"></span>
01141                 <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01142 
01143                 <span class="comment">//</span>
01144                 <span class="comment">// Finally, indicate that the parse routine was actually</span>
01145                 <span class="comment">// invoked and that the information returned herein can be</span>
01146                 <span class="comment">// used.</span>
01147                 <span class="comment">//</span>
01148 
01149                 op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o5">ParseCheck</a> = <a class="code" href="../../d0/d6/iop_8h.html#a3">OPEN_PACKET_PATTERN</a>;
01150                 status = STATUS_SUCCESS;
01151 
01152                 <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o22">FullAttributes</a>) {
01153                     <span class="keywordflow">try</span> {
01154                         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o15">BasicInformation</a>-&gt;FileAttributes = op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o16">NetworkInformation</a>-&gt;FileAttributes;
01155                     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01156                         status = GetExceptionCode();
01157                     }
01158                 }
01159 
01160                 <span class="keywordflow">return</span> status;
01161 
01162             } <span class="keywordflow">else</span> {
01163 
01164                 <span class="comment">//</span>
01165                 <span class="comment">// The fast I/O operation did not work, so take the longer</span>
01166                 <span class="comment">// route.</span>
01167                 <span class="comment">//</span>
01168 
01169                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.CurrentStackLocation++;
01170                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>++;
01171             }
01172         }
01173     }
01174 
01175     <span class="comment">//</span>
01176     <span class="comment">// Finally, initialize the file object's event to the Not Signaled state</span>
01177     <span class="comment">// and remember that a file object was created.</span>
01178     <span class="comment">//</span>
01179 
01180     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01181     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> = fileObject;
01182 
01183     <span class="comment">//</span>
01184     <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
01185     <span class="comment">//</span>
01186 
01187     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
01188 
01189     <span class="comment">//</span>
01190     <span class="comment">// Now invoke the driver itself to open the file.</span>
01191     <span class="comment">//</span>
01192 
01193     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
01194 
01195     <span class="comment">//</span>
01196     <span class="comment">// One of four things may have happened when the driver was invoked:</span>
01197     <span class="comment">//</span>
01198     <span class="comment">//    1.  The I/O operation is pending (Status == STATUS_PENDING).  This can</span>
01199     <span class="comment">//        occur on devices which need to perform some sort of device</span>
01200     <span class="comment">//        manipulation (such as opening a file for a file system).</span>
01201     <span class="comment">//</span>
01202     <span class="comment">//    2.  The driver returned an error (Status &lt; 0). This occurs when either</span>
01203     <span class="comment">//        a supplied parameter was in error, or the device or file system</span>
01204     <span class="comment">//        incurred or discovered an error.</span>
01205     <span class="comment">//</span>
01206     <span class="comment">//    3.  The operation ended in a reparse (Status == STATUS_REPARSE).  This</span>
01207     <span class="comment">//        occurs when a file system opens the file, only to discover that it</span>
01208     <span class="comment">//        represents a symbolic link.</span>
01209     <span class="comment">//</span>
01210     <span class="comment">//    4.  The operation is complete and was successful (Status ==</span>
01211     <span class="comment">//        STATUS_SUCCESS).  Note that for this case the only action is to</span>
01212     <span class="comment">//        return a pointer to the file object.</span>
01213     <span class="comment">//</span>
01214 
01215     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
01216 
01217         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>,
01218                                       <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
01219                                       <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01220                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01221                                       (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01222         status = ioStatus.Status;
01223 
01224     } <span class="keywordflow">else</span> {
01225 
01226         <span class="comment">//</span>
01227         <span class="comment">// The I/O operation was completed without returning a status of</span>
01228         <span class="comment">// pending.  This means that at this point, the IRP has not been</span>
01229         <span class="comment">// fully completed.  Complete it now.</span>
01230         <span class="comment">//</span>
01231 
01232         <a class="code" href="../../d0/d9/ntosdef_8h.html#a41">PKNORMAL_ROUTINE</a> normalRoutine;
01233         PVOID normalContext;
01234         KIRQL irql;
01235 
01236         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> );
01237         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> );
01238 
01239         <span class="comment">//</span>
01240         <span class="comment">// In the case of name junctions do the transmogrify work.</span>
01241         <span class="comment">//</span>
01242 
01243         <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_REPARSE &amp;&amp;
01244             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information == IO_REPARSE_TAG_MOUNT_POINT ) {
01245 
01246             PREPARSE_DATA_BUFFER reparseBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01247 
01248             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01249 
01250             reparseBuffer = (PREPARSE_DATA_BUFFER) irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer;
01251 
01252             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( reparseBuffer-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT );
01253             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( reparseBuffer-&gt;ReparseDataLength &lt; MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
01254             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( reparseBuffer-&gt;Reserved &lt; MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
01255 
01256             <a class="code" href="../../d4/d6/iosubs_8c.html#a86">IopDoNameTransmogrify</a>( irp,
01257                                    fileObject,
01258                                    reparseBuffer );
01259         }
01260 
01261         <span class="comment">//</span>
01262         <span class="comment">// Now finish up the request.</span>
01263         <span class="comment">//</span>
01264 
01265         <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;irql );
01266 
01267         <span class="comment">//</span>
01268         <span class="comment">// Note that normally the system would simply call IopCompleteRequest</span>
01269         <span class="comment">// here to complete the packet.  However, because this is a create</span>
01270         <span class="comment">// operation, several assumptions can be made that make it much faster</span>
01271         <span class="comment">// to perform the couple of operations that completing the request</span>
01272         <span class="comment">// would perform.  These include:  copying the I/O status block,</span>
01273         <span class="comment">// dequeueing the IRP and freeing it, and setting the file object's</span>
01274         <span class="comment">// event to the signalled state.  The latter is done here by hand,</span>
01275         <span class="comment">// since it is known that it is not possible for any thread to be</span>
01276         <span class="comment">// waiting on the event.</span>
01277         <span class="comment">//</span>
01278 
01279         ioStatus = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
01280         status = ioStatus.Status;
01281 
01282         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>.<a class="code" href="../../d2/d6/struct__KEVENT.html#o0">Header</a>.<a class="code" href="../../d1/d6/struct__DISPATCHER__HEADER.html#o4">SignalState</a> = 1;
01283 
01284         <a class="code" href="../../d0/d6/iop_8h.html#a18">IopDequeueThreadIrp</a>( irp );
01285 
01286         <span class="comment">//</span>
01287         <span class="comment">// The SystemBuffer is in some cases used by the driver, and</span>
01288         <span class="comment">// needs to be freed if present.</span>
01289         <span class="comment">//</span>
01290 
01291         <span class="keywordflow">if</span> ((irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a>) &amp;&amp; (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>)) {
01292             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer);
01293         }
01294 
01295         <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01296 
01297         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
01298     }
01299 
01300     <span class="comment">//</span>
01301     <span class="comment">// Copy the information field of the I/O status block back to the</span>
01302     <span class="comment">// original caller in case it is required.</span>
01303     <span class="comment">//</span>
01304 
01305     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o4">Information</a> = ioStatus.Information;
01306 
01307     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01308         <span class="keywordtype">int</span> openCancelled;
01309 
01310         <span class="comment">//</span>
01311         <span class="comment">// The operation ended in an error.  Kill the file object, dereference</span>
01312         <span class="comment">// the device object, and return a null pointer.</span>
01313         <span class="comment">//</span>
01314 
01315         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length) {
01316             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer );
01317             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length = 0;
01318         }
01319 
01320         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01321 
01322         openCancelled = (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a171">FO_FILE_OPEN_CANCELLED</a>);
01323 
01324         <span class="keywordflow">if</span> (realFileObjectRequired) {
01325             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01326         }
01327         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01328 
01329         <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01330 
01331         <span class="keywordflow">if</span> ((!openCancelled) &amp;&amp; (vpb )) {
01332             <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
01333         }
01334 
01335         <span class="keywordflow">return</span> op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = status;
01336 
01337     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status == STATUS_REPARSE) {
01338 
01339         <span class="comment">//</span>
01340         <span class="comment">// The operation resulted in a reparse.  This means that the file</span>
01341         <span class="comment">// name in the file object is the new name to be looked up. Replace</span>
01342         <span class="comment">// the complete name string with the new name and return STATUS_REPARSE</span>
01343         <span class="comment">// so the object manager knows to start over again.  Note, however,</span>
01344         <span class="comment">// that the file name buffer in the file object itself is kept intact</span>
01345         <span class="comment">// so that it can be reused when coming back here again.</span>
01346         <span class="comment">//</span>
01347         <span class="comment">// A reparse status may also have been returned from the file system if</span>
01348         <span class="comment">// the volume that was in a drive needed to have been verified, but</span>
01349         <span class="comment">// the verification failed, and a new volume was mounted.  In this</span>
01350         <span class="comment">// case, everything starts over again using the new volume.</span>
01351         <span class="comment">//</span>
01352 
01353         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d5/io_8h.html#a108">IO_REPARSE</a> == IO_REPARSE_TAG_RESERVED_ZERO );
01354 
01355         <span class="keywordflow">if</span> ((ioStatus.Information == <a class="code" href="../../d0/d5/io_8h.html#a108">IO_REPARSE</a>) ||
01356             (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT)) {
01357 
01358             <span class="comment">//</span>
01359             <span class="comment">// If the complete name buffer isn't large enough, reallocate it.</span>
01360             <span class="comment">//</span>
01361 
01362             <span class="keywordflow">if</span> (CompleteName-&gt;MaximumLength &lt; fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length) {
01363 
01364                 PVOID buffer;
01365 
01366                 buffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
01367                                                 fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length,
01368                                                 'cFoI' );
01369                 <span class="keywordflow">if</span> (!buffer) {
01370                     <span class="keywordflow">return</span> op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = STATUS_INSUFFICIENT_RESOURCES;
01371                 } <span class="keywordflow">else</span> {
01372                     <span class="keywordflow">if</span> (CompleteName-&gt;Buffer) {
01373                         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( CompleteName-&gt;Buffer );
01374                     }
01375                     CompleteName-&gt;Buffer = buffer;
01376                     CompleteName-&gt;MaximumLength = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length;
01377                 }
01378             }
01379 
01380             <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>( CompleteName, &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a> );
01381 
01382             <span class="comment">//</span>
01383             <span class="comment">// For NTFS directory junction points we NULL the RelatedFileObject.</span>
01384             <span class="comment">// If the prior call was a relative open, the subsequent one will</span>
01385             <span class="comment">// not be.</span>
01386             <span class="comment">//</span>
01387 
01388             <span class="keywordflow">if</span> (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT) {
01389 
01390                 op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01391             }
01392         }
01393 
01394         <span class="comment">//</span>
01395         <span class="comment">// Kill the file object, dereference the device object, and return a</span>
01396         <span class="comment">// null pointer.</span>
01397         <span class="comment">//</span>
01398 
01399         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length) {
01400             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer );
01401             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length = 0;
01402         }
01403 
01404         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01405 
01406         <span class="keywordflow">if</span> (realFileObjectRequired) {
01407             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01408         }
01409         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01410 
01411         <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( parseDeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01412 
01413         <span class="keywordflow">if</span> (vpb) {
01414             <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
01415         }
01416 
01417         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d5/io_8h.html#a109">IO_REMOUNT</a> == IO_REPARSE_TAG_RESERVED_ONE );
01418 
01419         <span class="keywordflow">if</span> (ioStatus.Information == IO_REPARSE_TAG_RESERVED_ONE) {
01420 
01421             <span class="comment">//</span>
01422             <span class="comment">// If we are reparsing to verify a volume, restart the reparse</span>
01423             <span class="comment">// by attempting to parse the device once again.  Note that it</span>
01424             <span class="comment">// would be best to simply recurse, but it's not possible since</span>
01425             <span class="comment">// there is a limited amount of stack available to kernel mode</span>
01426             <span class="comment">// and a limit needs to be enforced for the number of times that</span>
01427             <span class="comment">// verify reparse can occur.</span>
01428             <span class="comment">//</span>
01429 
01430             <span class="keywordflow">if</span> (++retryCount &gt; <a class="code" href="../../d4/d3/parse_8c.html#a1">IO_MAX_REMOUNT_REPARSE_ATTEMPTS</a>) {
01431 
01432                 <span class="keywordflow">return</span> STATUS_UNSUCCESSFUL;
01433             }
01434             <span class="keywordflow">goto</span> reparse_loop;
01435 
01436         } <span class="keywordflow">else</span> {
01437 
01438             <span class="comment">//</span>
01439             <span class="comment">// Really reparsing a symbolic link, so go back to the object</span>
01440             <span class="comment">// manager so it can begin the parse from the top.</span>
01441             <span class="comment">//</span>
01442 
01443             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01444             <span class="keywordflow">return</span> STATUS_REPARSE;
01445         }
01446 
01447     } <span class="keywordflow">else</span> {
01448 
01449         <span class="comment">//</span>
01450         <span class="comment">// The operation was successful. The first thing to do is to see if</span>
01451         <span class="comment">// the device that processed the open also opened the file. If</span>
01452         <span class="comment">// not, we need to adjust the vpb reference counts. Then, if this is</span>
01453         <span class="comment">// not a query or a delete, but rather a normal open/create, return</span>
01454         <span class="comment">// the address of the FileObject to the caller and set the</span>
01455         <span class="comment">// information returned in the original requestor's I/O status block.</span>
01456         <span class="comment">// Also set the value of the parse check field in the open packet to</span>
01457         <span class="comment">// a value which will let the caller know that this routine was</span>
01458         <span class="comment">// successful in creating the file object. Finally, return the status</span>
01459         <span class="comment">// of the operation to the caller.</span>
01460         <span class="comment">//</span>
01461 
01462         <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObjectThatOpenedFile;
01463 
01464         deviceObjectThatOpenedFile = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>(fileObject);
01465         <span class="keywordflow">if</span> (deviceObject != deviceObjectThatOpenedFile) {
01466             <span class="comment">//</span>
01467             <span class="comment">// The device that opened the related file is not the one</span>
01468             <span class="comment">// that opened this file. So, readjust the vpb reference</span>
01469             <span class="comment">// counts.</span>
01470             <span class="keywordflow">if</span> (vpb) {
01471                 <a class="code" href="../../d4/d3/parse_8c.html#a5">IopDereferenceVpbAndFree</a>(vpb);
01472             }
01473             vpb = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o3">Vpb</a>;
01474             <span class="keywordflow">if</span> (vpb) {
01475                 <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>(
01476                     &amp;vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a>, 1, &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a> );
01477             }
01478         }
01479 
01480         <span class="keywordflow">if</span> (realFileObjectRequired) {
01481 
01482             *Object = fileObject;
01483             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o5">ParseCheck</a> = <a class="code" href="../../d0/d6/iop_8h.html#a3">OPEN_PACKET_PATTERN</a>;
01484 
01485             <span class="comment">//</span>
01486             <span class="comment">// Add a reference so the file object cannot go away before</span>
01487             <span class="comment">// the create routine gets chance to flag the object for handle</span>
01488             <span class="comment">// create.</span>
01489             <span class="comment">//</span>
01490 
01491             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( fileObject );
01492 
01493             <span class="comment">//</span>
01494             <span class="comment">// If the filename length is zero and its not a relative open or</span>
01495             <span class="comment">// its a relative open to a volume open then set the volume open flag.</span>
01496             <span class="comment">// Also set it only for filesystem device object volume.</span>
01497             <span class="comment">//</span>
01498             <span class="keywordflow">if</span> ((!fileObject-&gt;RelatedFileObject || fileObject-&gt;RelatedFileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a172">FO_VOLUME_OPEN</a>) &amp;&amp;
01499                 (!fileObject-&gt;FileName.Length)) {
01500                 <span class="keywordflow">switch</span> (deviceObjectThatOpenedFile-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a>) {
01501                 <span class="keywordflow">case</span> FILE_DEVICE_DISK_FILE_SYSTEM:
01502                 <span class="keywordflow">case</span> FILE_DEVICE_CD_ROM_FILE_SYSTEM:
01503                 <span class="keywordflow">case</span> FILE_DEVICE_TAPE_FILE_SYSTEM:
01504                 <span class="keywordflow">case</span> FILE_DEVICE_FILE_SYSTEM:
01505 
01506                     fileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a172">FO_VOLUME_OPEN</a>;
01507                     <span class="keywordflow">break</span>;
01508 
01509                 <span class="keywordflow">default</span>:
01510                     <span class="keywordflow">break</span>;
01511                 }
01512             }
01513 
01514             <span class="keywordflow">return</span> op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = ioStatus.Status;
01515 
01516         } <span class="keywordflow">else</span> {
01517 
01518             <span class="comment">//</span>
01519             <span class="comment">// This is either a quick query or delete operation.  Determine</span>
01520             <span class="comment">// which it is and quickly perform the operation.</span>
01521             <span class="comment">//</span>
01522 
01523             <span class="keywordflow">if</span> (op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o20">QueryOnly</a>) {
01524                 <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
01525                 BOOLEAN queryResult = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01526 
01527                 fastIoDispatch = deviceObjectThatOpenedFile-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
01528 
01529                 <span class="keywordflow">if</span> (!op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o22">FullAttributes</a>) {
01530                     PFILE_BASIC_INFORMATION basicInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01531 
01532                     <span class="comment">//</span>
01533                     <span class="comment">// This is a simple FAT file attribute query.  Attempt to</span>
01534                     <span class="comment">// obtain the basic information about the file.</span>
01535                     <span class="comment">//</span>
01536 
01537                     <span class="keywordflow">try</span> {
01538 
01539                         <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp; fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o4">FastIoQueryBasicInfo</a>) {
01540                             queryResult = fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o4">FastIoQueryBasicInfo</a>(
01541                                             fileObject,
01542                                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01543                                             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o15">BasicInformation</a>,
01544                                             &amp;ioStatus,
01545                                             deviceObjectThatOpenedFile
01546                                             );
01547                         }
01548                         <span class="keywordflow">if</span> (!queryResult) {
01549                             ULONG returnedLength;
01550 
01551                             basicInfo = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
01552                                                         <span class="keyword">sizeof</span>( FILE_BASIC_INFORMATION ) );
01553                             <span class="keywordflow">if</span> (basicInfo) {
01554                                 status = <a class="code" href="../../d4/d6/iosubs_8c.html#a90">IoQueryFileInformation</a>(
01555                                             fileObject,
01556                                             FileBasicInformation,
01557                                             <span class="keyword">sizeof</span>( FILE_BASIC_INFORMATION ),
01558                                             basicInfo,
01559                                             &amp;returnedLength
01560                                             );
01561                                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01562                                     RtlCopyMemory( op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o15">BasicInformation</a>,
01563                                                    basicInfo,
01564                                                    returnedLength );
01565                                 }
01566                                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( basicInfo );
01567                             } <span class="keywordflow">else</span> {
01568                                 status = STATUS_INSUFFICIENT_RESOURCES;
01569                             }
01570                         } <span class="keywordflow">else</span> {
01571                             status = ioStatus.Status;
01572                         }
01573                     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01574                         <span class="keywordflow">if</span> (basicInfo) {
01575                             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( basicInfo );
01576                         }
01577                         status = GetExceptionCode();
01578                     }
01579 
01580                 } <span class="keywordflow">else</span> {
01581 
01582                     <span class="comment">//</span>
01583                     <span class="comment">// This is a full attribute query.  Attempt to obtain the</span>
01584                     <span class="comment">// full network attributes for the file.  This includes</span>
01585                     <span class="comment">// both the basic and standard information about the</span>
01586                     <span class="comment">// file.  Try the fast path first, if it exists.</span>
01587                     <span class="comment">//</span>
01588 
01589                     <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp;
01590                         fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o0">SizeOfFastIoDispatch</a> &gt; FIELD_OFFSET( <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">FAST_IO_DISPATCH</a>, FastIoQueryNetworkOpenInfo ) &amp;&amp;
01591                         fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o14">FastIoQueryNetworkOpenInfo</a>) {
01592                         queryResult = fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o14">FastIoQueryNetworkOpenInfo</a>(
01593                                         fileObject,
01594                                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01595                                         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o16">NetworkInformation</a>,
01596                                         &amp;ioStatus,
01597                                         deviceObjectThatOpenedFile
01598                                         );
01599                     }
01600                     <span class="keywordflow">if</span> (!queryResult) {
01601                         ULONG returnedLength;
01602 
01603                         <span class="comment">//</span>
01604                         <span class="comment">// Either the fast dispatch routine did not exist, or</span>
01605                         <span class="comment">// it simply wasn't callable at this time.  Attempt to</span>
01606                         <span class="comment">// obtain all of the information at once via an IRP-</span>
01607                         <span class="comment">// based call.</span>
01608                         <span class="comment">//</span>
01609 
01610                         status = <a class="code" href="../../d4/d6/iosubs_8c.html#a90">IoQueryFileInformation</a>(
01611                                     fileObject,
01612                                     FileNetworkOpenInformation,
01613                                     <span class="keyword">sizeof</span>( FILE_NETWORK_OPEN_INFORMATION ),
01614                                     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o16">NetworkInformation</a>,
01615                                     &amp;returnedLength
01616                                     );
01617 
01618                         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01619                             <span class="keywordflow">if</span> (status == STATUS_INVALID_PARAMETER ||
01620                                 status == STATUS_NOT_IMPLEMENTED) {
01621                                 FILE_BASIC_INFORMATION basicInfo;
01622                                 FILE_STANDARD_INFORMATION stdInfo;
01623 
01624                                 <span class="comment">//</span>
01625                                 <span class="comment">// The IRP-based call did not work either, so</span>
01626                                 <span class="comment">// simply try to obtain the information by</span>
01627                                 <span class="comment">// doing IRP-based queries for the basic and</span>
01628                                 <span class="comment">// standard information and piecing together</span>
01629                                 <span class="comment">// the results into the caller's buffer.  Note</span>
01630                                 <span class="comment">// that it might be possible to perform fast</span>
01631                                 <span class="comment">// I/O operations to get the data, but it</span>
01632                                 <span class="comment">// might also fail because of the above.  So</span>
01633                                 <span class="comment">// simply query the information the long way.</span>
01634                                 <span class="comment">//</span>
01635 
01636                                 status = <a class="code" href="../../d4/d6/iosubs_8c.html#a90">IoQueryFileInformation</a>(
01637                                             fileObject,
01638                                             FileBasicInformation,
01639                                             <span class="keyword">sizeof</span>( FILE_BASIC_INFORMATION ),
01640                                             &amp;basicInfo,
01641                                             &amp;returnedLength
01642                                             );
01643                                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01644                                     status = <a class="code" href="../../d4/d6/iosubs_8c.html#a90">IoQueryFileInformation</a>(
01645                                                 fileObject,
01646                                                 FileStandardInformation,
01647                                                 <span class="keyword">sizeof</span>( FILE_STANDARD_INFORMATION ),
01648                                                 &amp;stdInfo,
01649                                                 &amp;returnedLength
01650                                                 );
01651                                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01652                                         <a class="code" href="../../d4/d3/parse_8c.html#a2">COPY_ATTRIBUTES</a>( op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o16">NetworkInformation</a>,
01653                                                          &amp;basicInfo,
01654                                                          &amp;stdInfo );
01655                                     }
01656                                 }
01657                             }
01658                         }
01659                     }
01660                 }
01661 
01662             } <span class="keywordflow">else</span> {
01663 
01664                 <span class="comment">//</span>
01665                 <span class="comment">// There is nothing to do for a quick delete since the caller</span>
01666                 <span class="comment">// set the FILE_DELETE_ON_CLOSE CreateOption so it is already</span>
01667                 <span class="comment">// set in the file system.</span>
01668                 <span class="comment">//</span>
01669 
01670                 NOTHING;
01671 
01672             }
01673 
01674             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o5">ParseCheck</a> = <a class="code" href="../../d0/d6/iop_8h.html#a3">OPEN_PACKET_PATTERN</a>;
01675             <span class="keywordflow">if</span> (realFileObjectRequired) {
01676                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01677             } <span class="keywordflow">else</span> {
01678                 <a class="code" href="../../d3/d1/objsup_8c.html#a1">IopDeleteFile</a>( fileObject );
01679             }
01680             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01681 
01682             op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = status;
01683 
01684             <span class="keywordflow">return</span> status;
01685         }
01686     }
01687 }
01688 
01689 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01690"></a><a class="code" href="../../d4/d3/parse_8c.html#a7">01690</a> <a class="code" href="../../d4/d3/parse_8c.html#a7">IopParseFile</a>(
01691     IN PVOID ParseObject,
01692     IN PVOID ObjectType,
01693     IN <a class="code" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a> AccessState,
01694     IN KPROCESSOR_MODE AccessMode,
01695     IN ULONG Attributes,
01696     IN OUT PUNICODE_STRING CompleteName,
01697     IN OUT PUNICODE_STRING RemainingName,
01698     IN OUT PVOID Context OPTIONAL,
01699     IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
01700     OUT PVOID *Object
01701     )
01702 
01703 <span class="comment">/*++</span>
01704 <span class="comment"></span>
01705 <span class="comment">Routine Description:</span>
01706 <span class="comment"></span>
01707 <span class="comment">    This routine interfaces to the NT Object Manager.  It is invoked when</span>
01708 <span class="comment">    the object system is given the name of an entity to create or open and is</span>
01709 <span class="comment">    also given a handle to a directory file object that the operation is to be</span>
01710 <span class="comment">    performed relative to.  This routine is specified as the parse routine for</span>
01711 <span class="comment">    all file objects.</span>
01712 <span class="comment"></span>
01713 <span class="comment">    This routine simply invokes the parse routine for the appropriate device</span>
01714 <span class="comment">    that is associated with the file object.  It is the responsibility of that</span>
01715 <span class="comment">    routine to perform the operation.</span>
01716 <span class="comment"></span>
01717 <span class="comment">Arguments:</span>
01718 <span class="comment"></span>
01719 <span class="comment">    ParseObject - Pointer to the file object that the name is to be opened or</span>
01720 <span class="comment">        created relative to.</span>
01721 <span class="comment"></span>
01722 <span class="comment">    ObjectType - Type of the object being opened.</span>
01723 <span class="comment"></span>
01724 <span class="comment">    AccessState - Running security access state information for operation.</span>
01725 <span class="comment"></span>
01726 <span class="comment">    AccessMode - Access mode of the original caller.</span>
01727 <span class="comment"></span>
01728 <span class="comment">    Attributes - Attributes to be applied to the object.</span>
01729 <span class="comment"></span>
01730 <span class="comment">    CompleteName - Complete name of the object.</span>
01731 <span class="comment"></span>
01732 <span class="comment">    RemainingName - Remaining name of the object.</span>
01733 <span class="comment"></span>
01734 <span class="comment">    Context - Pointer to an Open Packet (OP) from NtCreateFile service.</span>
01735 <span class="comment"></span>
01736 <span class="comment">    SecurityQos - Supplies a pointer to the captured QOS information</span>
01737 <span class="comment">        if available.</span>
01738 <span class="comment"></span>
01739 <span class="comment">    Object - The address of a variable to receive the created file object, if</span>
01740 <span class="comment">        any.</span>
01741 <span class="comment"></span>
01742 <span class="comment">Return Value:</span>
01743 <span class="comment"></span>
01744 <span class="comment">    The function return value is one of the following:</span>
01745 <span class="comment"></span>
01746 <span class="comment">        a)  Success - This indicates that the function succeeded and the object</span>
01747 <span class="comment">            parameter contains the address of the created file object.</span>
01748 <span class="comment"></span>
01749 <span class="comment">        b)  Error - This indicates that the file was not found or created and</span>
01750 <span class="comment">            no file object was created.</span>
01751 <span class="comment"></span>
01752 <span class="comment">        c)  Reparse - This indicates that the remaining name string has been</span>
01753 <span class="comment">            replaced by a new name that is to be parsed.</span>
01754 <span class="comment"></span>
01755 <span class="comment">--*/</span>
01756 
01757 {
01758     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
01759     <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a> op;
01760 
01761     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01762 
01763     <span class="comment">//</span>
01764     <span class="comment">// Get the address of the Open Packet (OP).</span>
01765     <span class="comment">//</span>
01766 
01767     op = (<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">POPEN_PACKET</a>) Context;
01768 
01769     <span class="comment">//</span>
01770     <span class="comment">// Ensure that this routine is actually being invoked because someone is</span>
01771     <span class="comment">// attempting to open a device or a file through NtCreateFile.  This code</span>
01772     <span class="comment">// must be invoked from there (as opposed to some other random object</span>
01773     <span class="comment">// create or open routine).</span>
01774     <span class="comment">//</span>
01775 
01776     <span class="keywordflow">if</span> (op == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
01777         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a7">IO_TYPE_OPEN_PACKET</a> ||
01778         op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o1">Size</a> != <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">OPEN_PACKET</a> )) {
01779         <span class="keywordflow">return</span> STATUS_OBJECT_TYPE_MISMATCH;
01780     }
01781 
01782     <span class="comment">//</span>
01783     <span class="comment">// Get a pointer to the device object for this file.</span>
01784     <span class="comment">//</span>
01785 
01786     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) ParseObject );
01787 
01788     <span class="comment">//</span>
01789     <span class="comment">// Pass the related file object to the device object parse routine.</span>
01790     <span class="comment">//</span>
01791 
01792     op-&gt;<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) ParseObject;
01793 
01794     <span class="comment">//</span>
01795     <span class="comment">// Open or create the specified file.</span>
01796     <span class="comment">//</span>
01797 
01798     <span class="keywordflow">return</span> <a class="code" href="../../d4/d3/parse_8c.html#a6">IopParseDevice</a>( deviceObject,
01799                            ObjectType,
01800                            AccessState,
01801                            AccessMode,
01802                            Attributes,
01803                            CompleteName,
01804                            RemainingName,
01805                            Context,
01806                            <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a14">SecurityQos</a>,
01807                            Object );
01808 }
01809 
01810 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01811"></a><a class="code" href="../../d4/d3/parse_8c.html#a8">01811</a> <a class="code" href="../../d4/d3/parse_8c.html#a8">IopQueryName</a>(
01812     IN PVOID Object,
01813     IN BOOLEAN HasObjectName,
01814     OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
01815     IN ULONG Length,
01816     OUT PULONG ReturnLength
01817     )
01818 
01819 <span class="comment">/*++</span>
01820 <span class="comment"></span>
01821 <span class="comment">Routine Description:</span>
01822 <span class="comment"></span>
01823 <span class="comment">    This function implements the query name procedure for the Object Manager</span>
01824 <span class="comment">    for querying the names of file objects.</span>
01825 <span class="comment"></span>
01826 <span class="comment">Arguments:</span>
01827 <span class="comment"></span>
01828 <span class="comment">    Object - Pointer to the file object whose name is to be retrieved.</span>
01829 <span class="comment"></span>
01830 <span class="comment">    HasObjectName - Indicates whether or not the object has a name.</span>
01831 <span class="comment"></span>
01832 <span class="comment">    ObjectNameInfo - Buffer in which to return the name.</span>
01833 <span class="comment"></span>
01834 <span class="comment">    Length - Specifies the length of the output buffer, in bytes.</span>
01835 <span class="comment"></span>
01836 <span class="comment">    ReturnLength - Specifies the number of bytes actually returned in the</span>
01837 <span class="comment">        output buffer.</span>
01838 <span class="comment"></span>
01839 <span class="comment">Return Value:</span>
01840 <span class="comment"></span>
01841 <span class="comment">    The function return value is the final status of the query operation.</span>
01842 <span class="comment"></span>
01843 <span class="comment">--*/</span>
01844 
01845 {
01846     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01847     ULONG lengthNeeded;
01848     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
01849     PUCHAR buffer;
01850     PWSTR p;
01851     POBJECT_NAME_INFORMATION deviceNameInfo;
01852     PFILE_NAME_INFORMATION fileNameInfo;
01853     ULONG length;
01854 
01855     UNREFERENCED_PARAMETER( HasObjectName );
01856 
01857     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01858 
01859     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET( FILE_NAME_INFORMATION, <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> ) &lt; <span class="keyword">sizeof</span>( OBJECT_NAME_INFORMATION ) );
01860 
01861     <span class="comment">//</span>
01862     <span class="comment">// Ensure that the size of the output buffer is at least the minimum</span>
01863     <span class="comment">// size required to include the basic object name information structure.</span>
01864     <span class="comment">//</span>
01865 
01866     <span class="keywordflow">if</span> (Length &lt; <span class="keyword">sizeof</span>( OBJECT_NAME_INFORMATION )) {
01867         <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
01868         }
01869 
01870     <span class="comment">//</span>
01871     <span class="comment">// Begin by allocating a buffer in which to build the name of the file.</span>
01872     <span class="comment">//</span>
01873 
01874     buffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, Length, '  oI' );
01875     <span class="keywordflow">if</span> (!buffer) {
01876         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01877         }
01878 
01879     <span class="keywordflow">try</span> {
01880 
01881         <span class="comment">//</span>
01882         <span class="comment">// Query the name of the device on which the file is open.</span>
01883         <span class="comment">//</span>
01884 
01885         fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) Object;
01886         deviceNameInfo = (POBJECT_NAME_INFORMATION) buffer;
01887 
01888         status = <a class="code" href="../../d6/d1/obquery_8c.html#a7">ObQueryNameString</a>( (PVOID) fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>,
01889                                     deviceNameInfo,
01890                                     Length,
01891                                     &amp;lengthNeeded );
01892         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01893             <span class="keywordflow">return</span> status;
01894             }
01895 
01896         <span class="comment">//</span>
01897         <span class="comment">// Ensure that there is enough room in the output buffer to return the</span>
01898         <span class="comment">// name and copy it.</span>
01899         <span class="comment">//</span>
01900 
01901         RtlCopyMemory( ObjectNameInfo,
01902                        deviceNameInfo,
01903                        lengthNeeded &gt; Length ? Length : lengthNeeded );
01904         p = (PWSTR) (ObjectNameInfo + 1);
01905         ObjectNameInfo-&gt;Name.Buffer = p;
01906         p = (PWSTR) ((PCHAR) p + deviceNameInfo-&gt;Name.Length);
01907 
01908         <span class="comment">//</span>
01909         <span class="comment">// If the buffer is already full, then return.</span>
01910         <span class="comment">//</span>
01911 
01912         <span class="keywordflow">if</span> (lengthNeeded &gt; Length) {
01913             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
01914             }
01915 
01916         <span class="comment">//</span>
01917         <span class="comment">// Reset the state for the buffer to obtain the filename portion of the</span>
01918         <span class="comment">// name and calculate the remaining length of the caller's buffer.  Note</span>
01919         <span class="comment">// that in the following calculations, there are two assumptions and</span>
01920         <span class="comment">// and dependencies:</span>
01921         <span class="comment">//</span>
01922         <span class="comment">//     1)  The above query of the device name's returned length needed</span>
01923         <span class="comment">//         include a NULL character which will be included at the end</span>
01924         <span class="comment">//         of the entire name.  This is included in the calculations</span>
01925         <span class="comment">//         although it does not appear to be included.</span>
01926         <span class="comment">//</span>
01927         <span class="comment">//     2)  The sizeof the object name information buffer is assumed</span>
01928         <span class="comment">//         (and guaranteed because it can never change) to be larger</span>
01929         <span class="comment">//         than the filename offset in a file name information buffer.</span>
01930         <span class="comment">//         Therefore it is known that the new length of the "buffer"</span>
01931         <span class="comment">//         variable can be set to the remaining length plus at least 4.</span>
01932         <span class="comment">//</span>
01933 
01934         fileNameInfo = (PFILE_NAME_INFORMATION) buffer;
01935         length = Length - lengthNeeded;
01936 
01937         length += FIELD_OFFSET( FILE_NAME_INFORMATION, <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> );
01938 
01939         <span class="keywordflow">if</span> (KeGetPreviousMode() == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a> ||
01940             !(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>)) {
01941 
01942             <span class="comment">//</span>
01943             <span class="comment">// Query the name of the file based using an intermediary buffer.</span>
01944             <span class="comment">//</span>
01945 
01946             status = <a class="code" href="../../d4/d6/iosubs_8c.html#a90">IoQueryFileInformation</a>( fileObject,
01947                                              FileNameInformation,
01948                                              length,
01949                                              (PVOID) fileNameInfo,
01950                                              &amp;lengthNeeded );
01951             }
01952         <span class="keywordflow">else</span> {
01953 
01954             <span class="comment">//</span>
01955             <span class="comment">// This is a kernel mode request for a file that was opened for</span>
01956             <span class="comment">// synchronous I/O.  A special function that does not obtain the</span>
01957             <span class="comment">// file object lock is required, otherwise the request may deadlock</span>
01958             <span class="comment">// since the lock is probably already owned.</span>
01959             <span class="comment">//</span>
01960 
01961             status = <a class="code" href="../../d0/d6/iop_8h.html#a177">IopGetFileName</a>( fileObject,
01962                                      length,
01963                                      fileNameInfo,
01964                                      &amp;lengthNeeded );
01965             }
01966 
01967         <span class="comment">//</span>
01968         <span class="comment">// If an error occurred attempting to obtain the filename return now.  Note</span>
01969         <span class="comment">// that buffer overflow is a warning, not an error.</span>
01970         <span class="comment">//</span>
01971 
01972         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>( status )) {
01973             <span class="keywordflow">if</span> (status == STATUS_INVALID_PARAMETER ||
01974                 status == STATUS_INVALID_DEVICE_REQUEST ||
01975                 status == STATUS_NOT_IMPLEMENTED ||
01976                 status == STATUS_INVALID_INFO_CLASS) {
01977                 lengthNeeded = FIELD_OFFSET( FILE_NAME_INFORMATION, <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> );
01978                 fileNameInfo-&gt;FileNameLength = 0;
01979                 fileNameInfo-&gt;FileName[0] = OBJ_NAME_PATH_SEPARATOR;
01980                 status = STATUS_SUCCESS;
01981                 }
01982             <span class="keywordflow">else</span> {
01983                 <span class="keywordflow">return</span> status;
01984                 }
01985             }
01986 
01987         <span class="comment">//</span>
01988         <span class="comment">// Set the remaining length of the caller's buffer as well as the total</span>
01989         <span class="comment">// length needed to contain the entire name of the file.</span>
01990         <span class="comment">//</span>
01991 
01992         length = lengthNeeded - FIELD_OFFSET( FILE_NAME_INFORMATION, <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> );
01993         lengthNeeded = (ULONG)((PUCHAR) p - (PUCHAR) ObjectNameInfo) + fileNameInfo-&gt;FileNameLength;
01994 
01995         <span class="comment">//</span>
01996         <span class="comment">// Attempt to copy the name of the file into the output buffer.  Note</span>
01997         <span class="comment">// that if the file name does not begin w/a '\', then it is not volume</span>
01998         <span class="comment">// relative, so the name of the file cannot be expressed as the</span>
01999         <span class="comment">// concatenation of the name of the device and the file.  Therefore an</span>
02000         <span class="comment">// error is returned.</span>
02001         <span class="comment">//</span>
02002         <span class="comment">// The only example of this situation known at this time is when one</span>
02003         <span class="comment">// opens a directory by file ID, and then opens a file relative to that</span>
02004         <span class="comment">// directory.  When attempting to query the path, if the caller did not</span>
02005         <span class="comment">// have traverse access to open the directory, then the only name that</span>
02006         <span class="comment">// can be returned is the path name to the file from the directory, but</span>
02007         <span class="comment">// the volume-relative name cannot be returned.  Therefore, the file</span>
02008         <span class="comment">// system returns only the name of the directory and the path to the</span>
02009         <span class="comment">// file, but this is not volume-relative so the only recourse is to</span>
02010         <span class="comment">// return an error.</span>
02011         <span class="comment">//</span>
02012         <span class="comment">// Note that if the caller were to call NtQueryInformationFile and</span>
02013         <span class="comment">// request FileNameInformation, then the name above named will be</span>
02014         <span class="comment">// successfully returned from the file system.</span>
02015         <span class="comment">//</span>
02016 
02017         <span class="keywordflow">if</span> (fileNameInfo-&gt;FileName[0] != OBJ_NAME_PATH_SEPARATOR) {
02018             <span class="keywordflow">return</span> STATUS_OBJECT_PATH_INVALID;
02019             }
02020 
02021         RtlMoveMemory( p,
02022                        fileNameInfo-&gt;FileName,
02023                        length );
02024         p = (PWSTR) ((PCH) p + length);
02025         *p = <span class="charliteral">'\0'</span>;
02026         lengthNeeded += <span class="keyword">sizeof</span>( WCHAR );
02027 
02028         *ReturnLength = lengthNeeded;
02029 
02030         length = (ULONG)((PUCHAR) p - (PUCHAR) ObjectNameInfo);
02031         ObjectNameInfo-&gt;Name.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (length - <span class="keyword">sizeof</span>( *ObjectNameInfo ));
02032         ObjectNameInfo-&gt;Name.MaximumLength =  (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) ((length - <span class="keyword">sizeof</span>( *ObjectNameInfo )) + <span class="keyword">sizeof</span>( WCHAR ));
02033         }
02034 
02035     finally {
02036 
02037         <span class="comment">//</span>
02038         <span class="comment">// Finally, free the temporary buffer.</span>
02039         <span class="comment">//</span>
02040 
02041         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( buffer );
02042         }
02043 
02044     <span class="keywordflow">return</span> status;
02045 }
02046 
02047 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02048"></a><a class="code" href="../../d4/d3/parse_8c.html#a9">02048</a> <a class="code" href="../../d4/d3/parse_8c.html#a9">IopCheckBackupRestorePrivilege</a>(
02049     IN <a class="code" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a> AccessState,
02050     IN OUT PULONG CreateOptions,
02051     IN KPROCESSOR_MODE PreviousMode,
02052     IN ULONG Disposition
02053     )
02054 
02055 <span class="comment">/*++</span>
02056 <span class="comment"></span>
02057 <span class="comment">Routine Description:</span>
02058 <span class="comment"></span>
02059 <span class="comment">    This funcion will determine if the caller is asking for any accesses</span>
02060 <span class="comment">    that may be satisfied by Backup or Restore privileges, and if so,</span>
02061 <span class="comment">    perform the privilge checks.  If the privilege checks succeed, then</span>
02062 <span class="comment">    the appropriate bits will be moved out of the RemainingDesiredAccess</span>
02063 <span class="comment">    field in the AccessState structure and placed into the PreviouslyGrantedAccess</span>
02064 <span class="comment">    field.</span>
02065 <span class="comment"></span>
02066 <span class="comment">    Note that access is not denied if the caller does not have either or</span>
02067 <span class="comment">    both of the privileges, since he may be granted the desired access</span>
02068 <span class="comment">    via the security descriptor on the object.</span>
02069 <span class="comment"></span>
02070 <span class="comment">    This routine will also set a flag in the AccessState structure so that</span>
02071 <span class="comment">    it will not perform these privilege checks again in case we come through</span>
02072 <span class="comment">    this way again due to a reparse.</span>
02073 <span class="comment"></span>
02074 <span class="comment">Arguments:</span>
02075 <span class="comment"></span>
02076 <span class="comment">    AccessState - The AccessState containing the current state of this access</span>
02077 <span class="comment">        attempt.</span>
02078 <span class="comment"></span>
02079 <span class="comment">    CreateOptions - The CreateOptions field from the OPEN_PACKET structure for</span>
02080 <span class="comment">        this open attempt.</span>
02081 <span class="comment"></span>
02082 <span class="comment">    PreviousMode - The processor mode to be used in checking parameters.</span>
02083 <span class="comment"></span>
02084 <span class="comment">    Disposition - The create disposition for this request.</span>
02085 <span class="comment"></span>
02086 <span class="comment">Return Value:</span>
02087 <span class="comment"></span>
02088 <span class="comment">    None.</span>
02089 <span class="comment"></span>
02090 <span class="comment">--*/</span>
02091 
02092 {
02093     ACCESS_MASK desiredAccess;
02094     ACCESS_MASK readAccess;
02095     ACCESS_MASK writeAccess;
02096     PRIVILEGE_SET requiredPrivileges;
02097     BOOLEAN accessGranted;
02098     BOOLEAN keepBackupIntent = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02099     BOOLEAN ForceRestoreCheck = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02100 
02101     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02102 
02103     <span class="comment">//</span>
02104     <span class="comment">// Check to determine whether or not this check has already been made.</span>
02105     <span class="comment">// If so, simply return back to the caller.</span>
02106     <span class="comment">//</span>
02107 
02108     <span class="keywordflow">if</span> (AccessState-&gt;Flags &amp; <a class="code" href="../../d0/d5/se_8h.html#a6">SE_BACKUP_PRIVILEGES_CHECKED</a>) {
02109         <span class="keywordflow">return</span>;
02110     }
02111 
02112     <span class="keywordflow">if</span> (*CreateOptions &amp; FILE_OPEN_FOR_BACKUP_INTENT) {
02113         AccessState-&gt;Flags |= <a class="code" href="../../d0/d5/se_8h.html#a6">SE_BACKUP_PRIVILEGES_CHECKED</a>;
02114 
02115         readAccess = READ_CONTROL | ACCESS_SYSTEM_SECURITY | FILE_GENERIC_READ | FILE_TRAVERSE;
02116         writeAccess = WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | FILE_GENERIC_WRITE | FILE_ADD_FILE | FILE_ADD_SUBDIRECTORY | DELETE;
02117 
02118         desiredAccess = AccessState-&gt;RemainingDesiredAccess;
02119 
02120         <span class="comment">//</span>
02121         <span class="comment">// If the caller has requested MAXIMUM_ALLOWED, then make it appear as</span>
02122         <span class="comment">// if the request was for everything permitted by Backup and Restore,</span>
02123         <span class="comment">// and then grant everything that can actually be granted.</span>
02124         <span class="comment">//</span>
02125 
02126         <span class="keywordflow">if</span> (desiredAccess &amp; MAXIMUM_ALLOWED) {
02127             desiredAccess |= ( readAccess | writeAccess );
02128         }
02129 
02130         <span class="comment">//</span>
02131         <span class="comment">// If the disposition says that we're opening the file, check for both backup</span>
02132         <span class="comment">// and restore privilege, depending on what's in the desired access.</span>
02133         <span class="comment">//</span>
02134         <span class="comment">// If the disposition says that we're creating or trying to overwrite the file,</span>
02135         <span class="comment">// then all we need to do is to check for restore privilege, and if it's there,</span>
02136         <span class="comment">// grant every possible access.</span>
02137         <span class="comment">//</span>
02138 
02139         <span class="keywordflow">if</span> ( Disposition &amp; FILE_OPEN ) {
02140 
02141             <span class="comment">//</span>
02142             <span class="comment">// If the request was for any of the bits in the read access mask, then</span>
02143             <span class="comment">// assume that this is a backup operation, and check for the Backup</span>
02144             <span class="comment">// privielege.  If the caller has it, then grant the intersection of</span>
02145             <span class="comment">// the desired access and read access masks.</span>
02146             <span class="comment">//</span>
02147 
02148             <span class="keywordflow">if</span> (readAccess &amp; desiredAccess) {
02149 
02150                 requiredPrivileges.PrivilegeCount = 1;
02151                 requiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
02152                 requiredPrivileges.Privilege[0].Luid = <a class="code" href="../../d0/d5/se_8h.html#a94">SeBackupPrivilege</a>;
02153                 requiredPrivileges.Privilege[0].Attributes = 0;
02154 
02155                 accessGranted = <a class="code" href="../../d8/d4/privileg_8c.html#a1">SePrivilegeCheck</a>( &amp;requiredPrivileges,
02156                                                   &amp;AccessState-&gt;SubjectSecurityContext,
02157                                                   PreviousMode );
02158 
02159                 <span class="keywordflow">if</span> (accessGranted) {
02160 
02161                     <span class="comment">//</span>
02162                     <span class="comment">// The caller has Backup privilege, so grant the appropriate</span>
02163                     <span class="comment">// accesses.</span>
02164                     <span class="comment">//</span>
02165 
02166                     keepBackupIntent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02167                     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d5/seastate_8c.html#a5">SeAppendPrivileges</a>( AccessState, &amp;requiredPrivileges );
02168                     AccessState-&gt;PreviouslyGrantedAccess |= ( desiredAccess &amp; readAccess );
02169                     AccessState-&gt;RemainingDesiredAccess &amp;= ~readAccess;
02170                     desiredAccess &amp;= ~readAccess;
02171                     AccessState-&gt;Flags |= <a class="code" href="../../d0/d5/se_8h.html#a2">TOKEN_HAS_BACKUP_PRIVILEGE</a>;
02172                 }
02173             }
02174 
02175         } <span class="keywordflow">else</span> {
02176 
02177             ForceRestoreCheck = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02178         }
02179 
02180         <span class="comment">//</span>
02181         <span class="comment">// If the request was for any of the bits in the write access mask, then</span>
02182         <span class="comment">// assume that this is a restore operation, so check for the Restore</span>
02183         <span class="comment">// privilege.  If the caller has it, then grant the intersection of</span>
02184         <span class="comment">// the desired access and write access masks.</span>
02185         <span class="comment">//</span>
02186 
02187         <span class="keywordflow">if</span> ((writeAccess &amp; desiredAccess) || ForceRestoreCheck) {
02188 
02189             requiredPrivileges.PrivilegeCount = 1;
02190             requiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
02191             requiredPrivileges.Privilege[0].Luid = <a class="code" href="../../d0/d5/se_8h.html#a95">SeRestorePrivilege</a>;
02192             requiredPrivileges.Privilege[0].Attributes = 0;
02193 
02194             accessGranted = <a class="code" href="../../d8/d4/privileg_8c.html#a1">SePrivilegeCheck</a>( &amp;requiredPrivileges,
02195                                               &amp;AccessState-&gt;SubjectSecurityContext,
02196                                               PreviousMode );
02197 
02198             <span class="keywordflow">if</span> (accessGranted) {
02199 
02200                 <span class="comment">//</span>
02201                 <span class="comment">// The caller has Restore privilege, so grant the appropriate</span>
02202                 <span class="comment">// accesses.</span>
02203                 <span class="comment">//</span>
02204 
02205                 keepBackupIntent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02206                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d5/seastate_8c.html#a5">SeAppendPrivileges</a>( AccessState, &amp;requiredPrivileges );
02207                 AccessState-&gt;PreviouslyGrantedAccess |= (desiredAccess &amp; writeAccess);
02208                 AccessState-&gt;RemainingDesiredAccess &amp;= ~writeAccess;
02209                 AccessState-&gt;Flags |= <a class="code" href="../../d0/d5/se_8h.html#a3">TOKEN_HAS_RESTORE_PRIVILEGE</a>;
02210             }
02211         }
02212 
02213         <span class="comment">//</span>
02214         <span class="comment">// If either of the access types was granted because the caller had</span>
02215         <span class="comment">// backup or restore privilege, then the backup intent flag is kept.</span>
02216         <span class="comment">// Otherwise, it is cleared so that it is not passed onto the driver</span>
02217         <span class="comment">// so that it is not incorrectly propogated anywhere else, since this</span>
02218         <span class="comment">// caller does not actually have the privilege enabled.</span>
02219         <span class="comment">//</span>
02220 
02221         <span class="keywordflow">if</span> (!keepBackupIntent) {
02222             *CreateOptions &amp;= ~FILE_OPEN_FOR_BACKUP_INTENT;
02223         }
02224     }
02225 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:08 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
